<html><head><style>
html {overflow-y:scroll;}

body {font-size:13px;color:#000000;color:#404040;
background-color:#f1f1f1;margin:20px;}

p,td,ul {
	line-height:130%;
}

body,p,h1,h2,h3,h4,table,td,th,ul,ol,textarea,input {
	font-family:verdana,helvetica,arial,sans-serif;
}

iframe 	{margin:0px;}
img		{border:0;}

table,th,td,input,textarea {
	font-size:100%;
}

h1 {font-size:28px;margin-top:0px;font-weight:normal;page-break-before: always}
h2 {font-size:22px;margin-top:10px;margin-bottom:10px;font-weight:normal;page-break-before: always}
h3 {font-size:17px;font-weight:normal}
h4 {font-size:12px;}
h5 {font-size:11px;}
h6 {font-size:10px;}

h1,h2,h3,h4,h5,h6 {
	background-color:transparent;color:#000000;
}

#top {width:1220px;margin:auto;height:60px;}

#topLogo {text-align:left;float:left;margin-top:20px;margin-left:10px;}

#searchSection {height:60px;margin-right:0px;margin-top:5px;text-align:left;}

#searchText {color:#777777;font-size:11px;font-style:italic;padding-top:3px;}

#translateSection {height:30px;}

#topnav {height:25px;background-color:#d3d3d3;}

#topnavTut {height:20px;width:1190px;margin:auto;word-spacing:12px;font-size:12px;padding-left:10px;padding-right:20px;padding-top:5px;background-color:#d3d3d3;}

a.topnav:link,a.topnav:visited {color:#555555;text-decoration:none;}
a.topnav:hover,a.topnav:active {color:#ff4800;text-decoration:none;}

#topnavSpace {margin-left:290px;}

#belowTopnav {width:1220px;margin:auto;}

#page {width:1024px;float:left;margin-left:10px;margin-top:10px;padding-top:10px;padding-bottom:20px;box-shadow: 0px 0px 20px 3px #d3d3d3;border-radius:4px;background-color:#ffffff;}

div.topLeftRectangle {float:left;width:170px;height:90px;margin-top:10px;margin-right:4px;margin-left:10px;overflow:hidden;}

#mainLeaderboard {width:728px;height:90px;float:none;margin-top:0px;margin-left:0px;overflow:hidden;margin-bottom:15px;}

#pageads {height:100px;margin-bottom:10px;}

#leftcolumn {width:170px;float:left;margin-right:4px;margin-left:10px;}

#leftcolumn h2 {font-size:16px;font-weight:normal;color:#8AC007;}

#leftcolumn hr {color:#e5eecc;background-color:#e5eecc;margin-right:20px;}

#leftcolumn a:link,#leftcolumn a:visited,#leftcolumn a:hover,#leftcolumn a:active {
	display:block;font-size:13px;padding-bottom:4px;background-color:#ffffff;color:#555555;color:#404040;text-decoration:none;
}
#leftcolumn a:hover,#leftcolumn a:active {
	background-color:#ffffff;color:#000000;text-decoration:underline;
}

#main {width:822px;float:left;padding:7px;padding-top:0px;overflow:hidden;}

#rightcolumn h2{font-size:13px;font-weight:normal;color:#8AC007;margin-top:3px;margin-bottom:2px;}

#rightcolumn {width:160px;float:left;font-size:11px;padding-left:5px;margin-left:5px;}

#rightcolumn .rightad a:link,#rightcolumn .rightad a:visited,#rightcolumn .rightad a:hover,#rightcolumn .rightad a:active{
	text-decoration:none;display:block;color:#555555;margin-bottom:3px;padding-top:3px;
}

#rightcolumn .rightad a:hover,#rightcolumn .rightad a:active{
	text-decoration:underline;
}

#rightcolumn .rightad, #rightshare{
	width:150px;border:1px solid #d4d4d4;border-radius:4px;margin-bottom:8px;padding:5px;padding-bottom:10px;text-align:center;background-color:#ffffff;
}

#rightshare {margin-top:8px;}
#rightshare h2{font-size:13px;font-weight:normal;color:#8AC007;margin-top:3px;margin-bottom:2px;}

#sharelist{position:relative;height:16px;margin:0;margin-left:19px;}
#sharelist li{margin:0;padding:0;list-style:none;position:absolute;top:0;}
#sharelist li, #sharelist a{height:16px;display:block;}
#facebook{left:0px;width:16px;background:url('/images/share.png') -16px 0;}
#twitter{left:19px;width:16px;background:url('/images/share.png') -32px 0;}
#email{left:38px;width:16px;background:url('/images/share.png') -80px 0;}
#googleplus{left:57px;width:16px;background:url('/images/share.png') 0 0;}
#linkedin{left:76px;width:16px;background:url('/images/share.png') -48px 0;}
#reddit{left:95px;width:16px;background:url('/images/share.png') -64px 0;}

div.wideSkyscraper {width:160px;height:600px;margin:auto;margin-top:0;overflow:hidden;}

.footer {width:1040px;margin:auto;color:#909090;font-size:11px;text-align:center;padding-left:30px;padding-right:150px;}

#footerImg {float:left;width:200px;text-align:left;padding-left:3px;padding-top:11px;}

#footerAbout {word-spacing:6px;font-size:10px;padding-right:62px;padding-top:19px;float:right;text-align:right;}

#footerText{padding-top:13px;color:#404040;clear:both;color:#555555;margin-right:50px;}

.footer a:link,.footer a:visited {text-decoration:none;color:#404040;background-color:transparent}
.footer a:hover,.footer a:active {text-decoration:underline;color:#404040;background-color:transparent}

div.example {
/*	width:auto;color:#000000;background-color:#e5eecc;margin:0px;padding:5px;border:1px solid #d4d4d4;background-image:linear-gradient( #ffffff , #e5eecc 100px);*/
	width:auto;color:#000000;background-color:#e3e3e3;background-color:#f1f1f1;border: 1px solid #ebebeb; margin:0px;padding:10px;border-radius:4px;
}

div.example_code {
/*	width:auto;background-color:#ffffff;padding:5px;border:1px solid #d4d4d4;font-size:14px;font-family:"courier new";*/
	width:auto;background-color:#ffffff;padding:4px;padding-left:7px;border-left:4px solid #8AC007;font-size:14px;font-family:"courier new";border-radius:4px;
}

div.example_result {
/*	background-color:#ffffff;padding:4px;border:1px solid #d4d4d4;width:auto;*/
	background-color:#ffffff;padding:4px;border-radius:4px;width:auto;
}

div.code {
	width:auto;border:1px solid #d4d4d4;background-color:#f1f1f1;color:#444444;padding:5px;margin:0;
}

div.code div {font-size:14px;}

div.example_code p,div.code p,div.code div {
	font-family:"courier new";
}

div.tryit_ex
{
clear:both;
width:600px;
height:50px;
margin-bottom:5px
}

div.tryit_ex img
{
border:0;
float:left;
margin-right:10px
}

div.tryit_ex h2
{
padding-top:5px
}

table { page-break-inside:auto }
tr    { page-break-inside:avoid; page-break-after:auto }

table.lamp
{
width:100%;
padding:0px;
border:1px solid #d4d4d4;
}

table.lamp th
{
color:#000000;
background-color:white;
padding:10px;
padding-right:5px;
}

table.lamp td
{
padding:4px;
padding-left:0px;
padding-right:10px;
background-color:#ffffff;
}
table.tecspec th,table.tecspec td{
	border:1px solid #d4d4d4;padding:5px;padding-top:7px;padding-bottom:7px;vertical-align:top;text-align:left;
}

table.reference,table.tecspec{
	border-collapse:collapse;width:100%;
        table-layout: auto;
        page-break-inside:auto;
}

table.reference tr:nth-child(odd)	{background-color:#f1f1f1;page-break-inside:avoid; page-break-after:auto}
table.reference tr:nth-child(even)	{background-color:#ffffff;page-break-inside:avoid; page-break-after:auto}

table.reference tr.fixzebra			{background-color:#f1f1f1;}

table.reference th{
	color:#ffffff;background-color:#3390FF;border:1px solid #555555;padding:3px;vertical-align:top;text-align:left;
}

table.reference th a:link,table.reference th a:visited{
	color:#ffffff;
}

table.reference th a:hover,table.reference th a:active{
	color:#EE872A;
}

table.reference td{
	border:1px solid #d4d4d4;padding:5px;padding-top:7px;padding-bottom:7px;vertical-align:top;
}

table.reference td.example_code
{
vertical-align:bottom;
}

table.summary
{
border:1px solid #d4d4d4;
padding:5px;
font-size:100%;
color:#555555;
background-color:#fafad2;
}

h2.example,h2.example_head
{
color:#444444;
/*color:#617f10;*/
background-color:transparent;
margin-top:0px;
}

h2.example {font-weight:normal;font-size:16px;}
h2.example_head {font-size:16px;}

h2.home
{
margin-top:0px;
margin-bottom:5px;
font-size:14px;
padding-top:1px;
padding-bottom:1px;
padding-left:1px;
color:#900B09;
background-color:#ffffff;
}

h2.left
{
color:#404040;
background-color:#ffffff;
font-size:14px;
margin-bottom:4px;
padding-bottom:0px;
margin-top:0px;
padding-top:0px;
font-weight:bold;
}

span.marked 	{color:#e80000;background-color:transparent;}
span.deprecated {color:#e80000;background-color:transparent;}

div.tutintro
{
width:auto;min-height:132px;
}

div.tutintro img
{
float:left;
margin-right:20px;
margin-bottom:10px;
}
div.tutintro p
{
margin-top:0px;
font-size:14px;
}

p.intro
{
font-size:14px;
color:#404040;
background-color:transparent;
margin-top:10px;
}

pre
{
font-family:"courier new";
font-size:13px;
margin-left:0;
margin-bottom:0;
}

img.float {float:left;}
img.navup
{
vertical-align:middle;
height:22px;
width:18px;
border:0px;
}

hr
{
background-color:#d4d4d4;
color:#d4d4d4;
height:1px;
border:0px;
clear:both;
}

a.example {font-weight:bold}

a:link,a:visited {color:#B72801; background-color:transparent}
a:hover,a:active {color:#E97700; background-color:transparent}

a:link,a:visited {color:#000000; background-color:transparent}
a:hover,a:active {color:#B72801; background-color:transparent}


a.plain:link,a.plain:visited {text-decoration:none;color:#900B09;background-color:transparent}
a.plain:hover,a.plain:active {text-decoration:underline;color:#FF0000;background-color:transparent}

a.header:link,a.header:visited {text-decoration:none;color:black;background-color:transparent}
a.header:hover,a.header:active {text-decoration:underline;color:black;background-color:transparent}

table.sitemap a:link,table.sitemap a:visited {text-decoration:none;color:black;background-color:transparent}
table.sitemap a:hover,table.sitemap a:active {text-decoration:underline;color:black;background-color:transparent}


.toprect_txt a:link,.toprect_txt a:visited {text-decoration:none;color:#900B09;background-color:transparent}
.toprect_txt a:hover,.toprect_txt a:active {text-decoration:underline;color:#FF0000;background-color:transparent}


a.m_item:link,a.m_item:visited {text-decoration:none;color:white; background-color:transparent}
a.m_item:hover,a.m_item:active {text-decoration:underline;color:white; background-color:transparent}

a.chapter:link    {text-decoration:none;color:#8AC007;background-color:transparent}
a.chapter:visited {text-decoration:none;color:#8AC007;background-color:transparent}
a.chapter:hover   {text-decoration:underline;color:#8AC007;background-color:transparent}
a.chapter:active  {text-decoration:none;color:#8AC007;background-color:transparent}

a.tryitbtn,a.tryitbtn:link,a.tryitbtn:visited,a.showbtn,a.showbtn:link,a.showbtn:visited
{
display:inline-block;
color:#FFFFFF;
background-color:#8AC007;
font-weight:bold;
font-size:12px;
text-align:center;
padding-left:10px;
padding-right:10px;
padding-top:3px;
padding-bottom:4px;
text-decoration:none;
margin-left:0;
/*margin-left:5px;*/
margin-top:0px;
margin-bottom:5px;
border:1px solid #aaaaaa;
border:1px solid #8AC007;
border-radius:5px;
white-space:nowrap;
}

a.tryitbtn:hover,a.tryitbtn:active,a.showbtn:hover,a.showbtn:active
{
background-color:#ffffff;color:#8AC007;
}

a.playitbtn,a.playitbtn:link,a.playitbtn:visited
{
display:inline-block;
color:#ffffff;
background-color:#FFAD33;
border:1px solid #FFAD33;
font-weight:bold;
font-size:11px;
text-align:center;
padding:10px;
padding-top:1px;
padding-bottom:2px;
text-decoration:none;
margin-left:1px;
border-radius:5px;
white-space:nowrap;
}

a.playitbtn:hover,a.playitbtn:active
{
background-color:#ffffff;color:#FFAD33;
}

a.tryitbtnsyntax:link,a.tryitbtnsyntax:visited,a.tryitbtnsyntax:active,a.tryitbtnsyntax:hover
{
font-family:verdana;
float:right;
padding-top:0px;
padding-bottom:1px;
background-color:#8AC007;
/*border:1px solid #aaaaaa;*/
border:1px solid #8AC007;
}

a.tryitbtnsyntax:active,a.tryitbtnsyntax:hover
{
color:#8AC007;;
background-color:#ffffff;
}

div.chapter,div.nav
{
font-size:17px;margin:0px;padding:0px;width:auto;height:20px;
}

div.chapter div.prev {width:40%;float:left;text-align:left;}
div.chapter div.next {width:48%;float:right;text-align:right;}

div.nav div.prev {width:33%;float:left;text-align:left;}
div.nav div.home {width:33%;float:left;text-align:center;}
div.nav div.next {width:33%;float:right;text-align:right;}

span.color_h1 {color:#8AC007;}
span.left_h2 {color:#8AC007;}

span.new
{
float:right;
color:#FFFFFF;
background-color:#8AC007;
font-weight:bold;
padding-left:1px;
padding-right:1px;
border:1px solid #ffffff;
outline:1px solid #8AC007;
}

.notsupported,.notsupported:hover,.notsupported:active,.notsupported:visited,.notsupported:link
{
color:rgb(197,128,128)
}

#err_form, #err_sent
{
color:#000000;
background-color:#f1f1f1;
border:1px solid #d4d4d4;
background-repeat:repeat-x;
padding:10px;
padding-bottom:0px;
width:auto;
z-index:1;
margin-left:auto;
margin-right:auto;
margin-top:10px;
display:none;
position:relative;
}

#err_form h2, #err_sent h2
{
margin-top:0px;	
}
#err_form label
{
display:block;
margin-bottom:3px;
}
#err_form input
{
border:1px solid gray;
width:590px;
height:16px;
display:block;
padding:4px;
}
#err_form textarea
{
border:1px solid gray;
width:590px;
height:100px;
padding:4px;
display:block;
}
#err_form .submit input
{
border:1px solid gray;
width:100px;
height:18px;
padding:0px;
padding-bottom:2px;
}
.err_close
{
width:68px;
padding:0px;
position:absolute;
top:5px;
right:5px;
text-decoration:underline;
cursor:pointer;
}

table#bottomlinks
{
border:none;
width:100%;
}

#bottomlinks td
{
text-align:left;
padding:10px;
vertical-align:top;
}

.bottomlinksraquo
{
font-weight:bold;
color:#ff4800;
}

#bottomlinks h3
{
font-size:14px;
font-weight:bold;
color:#555555;
}

#bottomlinks a
{
font-size:11px;
color:#555555;
text-decoration:none;
}

.html5badge {background-image:url('/images/html5_badge20.png'); background-repeat:no-repeat; background-position:right; }

.expandingMenu
{
width:170px;
overflow:hidden;
}

.expandingMenuItem
{
width:158px;
padding-left:12px;
margin-top:1px;
margin-bottom:0px;
}

.expandingMenuSelected
{
background-image:url('images/minus_arrow.gif');
background-repeat:no-repeat;
background-position:1px 7px;
}

.expandingMenuNotSelected
{
background-image:url('images/plus_arrow.gif');
background-repeat:no-repeat;
background-position:1px 7px;
}

#leftcolumn .expandingMenuHeader{
	cursor:pointer;margin-left:11px;margin-top:1px;margin-bottom:0px;padding:2px;
}
#leftcolumn .expandingMenuHeader:hover{
	text-decoration:underline;color:#000000;
}


#leftcolumn div.expandingMenuSelected .expandingMenuItem {
	width:170px;padding-left:0px;
}

div#google_translate_element .goog-te-gadget-simple
{
margin-top:2px;height:25px;padding:0px;border:1px solid #d9d9d9;
}

#google_translate_element a
{
font-size:11px;
color:#808080;
font-family:verdana;
}

#google_translate_element a:hover
{
color:#000000;
}

div.cse .gsc-control-cse, div.gsc-control-cse {
background-color: transparent;
border: none;
padding:0px;
margin:0px;
}

td.gsc-search-button input.gsc-search-button {
border-color: #555555;
background-color: #555555;
}

div.goog-te-gadget-simple {
font-size: 11pt;width:160px;
}

img.goog-te-gadget-icon {
margin-top: 3px;
}

td.gsc-search-button input.gsc-search-button-v2 {
width: 13px;
height: 13px;
margin-top: 4px;
padding: 6px 8px;
}

form.gsc-search-box-tools table.gsc-search-box td.gsc-input {
padding-right: 0px;
}

td.gsib_a {padding:0px;padding-top:4px;padding-left:3px;}
</style></head><body><font face="arial"><h1>STM32WB BLE Wireless Interface</h1><p>This document describes the STM32WB BLE Application Commands Interface (ACI) and Host Commands Interface (HCI).</p><p><a href="https://www.st.com/en/microcontrollers-microprocessors/stm32wb-series.html">STM32WBx Series website</a></p><h2>Revision history</h2><p>December 2018 - Rev 1.0 - First release for interface 1.0 </p><p>February 2019 - Rev 1.1 - Modified HCI_HARDWARE_ERROR_EVENT comment</p><p>March 2019 - Rev 1.2 - Removed unused event documentation </p><p>March 2019 - Rev 1.3 - Modification ACI_HAL_FW_ERROR_EVENT error code</p><p>March 2019 - Rev 1.4 - Changed default mask of HCI_SET_EVENT_MASK </p><p>May 2019 - Rev 1.5 - ACI_GATT_NOTIFICATION_EXT_EVENT added</p><p>June 2019 - Rev 1.6 - Changed comment on usage of Char Handles in multiple ACI_GATT commands; Added ACI_GATT_INDICATION_EXT_EVENT</p><p>June 2019 - Rev 1.7 - Changed descriptions of ACI_ATT_READ_BY_TYPE_REQ and ACI_GATT_READ_USING_CHAR_UUID</p><p>July 2019 - Rev 1.8 - Reworked error codes section; Added GAP_ prefix to the GAP procedure bitmap definitions</p><p>September 2019 - Rev 1.9 - Added ACI_GATT_READ_EXT_EVENT; Modified ACI_GAP_CONFIGURE_WHITELIST comment</p><p>October 2019 - Rev 1.10 - Changed descriptions of ACI_GATT_WRITE_WITHOUT_RESP and ACI_GATT_SIGNED_WRITE_WITHOUT_RESP; Removed obsolete configuration data elements</p><p>November 2019 - Rev 1.11 - Completed description of ACI_GAP_INIT; Added specific pairing status definitions</p><p>November 2019 - Rev 1.12 - Fixed status error codes</p><p>January 2020 - Rev 1.13 - Removed DIV unused configuration data; Fixed naming of HCI_LE_READ_REMOTE_FEATURES command and complete event</p><p>March 2020 - Rev 1.14 - Removed unused HCI_Data_Buffer_Overflow event; Fixed naming of FW_Error_Type possible values; Fixed pairing status possible values</p><p>March 2020 - Rev 1.15 - Added GAP scan timeout value</p><p>April 2020 - Rev 1.16 - Fixed various format issues; Added LO and PO columns for command and event tables.</p><p>May 2020 - Rev 1.17 - Updated PO stack features; Added comment in HCI_LE_ADVERTISING_REPORT_EVENT description.</p><p>June 2020 - Rev 1.18 - Added BO column for command and event tables; Fixed advertising commands description; Fixed various format issues.</p><p>June 2020 - Rev 1.19 - Completed interval possible values for ACI_GAP_SET_DIRECT_CONNECTABLE.</p><p>July 2020 - Rev 1.20 - Added HCI_LE_SET_PRIVACY_MODE.</p><p>July 2020 - Rev 1.21 - Updated BO stack features.</p><p>September 2020 - Rev 1.22 - Fixed various minor issues.</p><p>November 2020 - Rev 1.23 - Added connection-oriented channels feature; Added HCI_LE_READ_TRANSMIT_POWER; Updated PO variant.</p><p>December 2020 - Rev 1.24 - Added BF column for command and event tables.</p><p>January 2021 - Rev 1.25 - Added Link_Status possible values.</p><p>January 2021 - Rev 1.26 - Fixed some specification references.</p><p>February 2021 - Rev 1.27 - Added ACI_HAL_SET_SLAVE_LATENCY; Updated comments of ACI_HAL_WRITE_CONFIG_DATA and ACI_HAL_READ_CONFIG_DATA.</p><p>March 2021 - Rev 1.28 - Added additional beacon feature.</p><p>April 2021 - Rev 1.29 - Removed unused ACI_HAL_SET_SMP_ENG_CONFIG.</p><p>May 2021 - Rev 1.30 - Fixed event generated by HCI_SET_CONTROLLER_TO_HOST_FLOW_CONTROL and HCI_HOST_BUFFER_SIZE.</p><p>May 2021 - Rev 1.31 - Added HCI_LE_SET_ADVERTISING_DATA in BF and PO variants.</p><p>June 2021 - Rev 1.32 - Added extended advertising feature; Added HCI_DISCONNECT in BF and PO variants; Removed host privacy; Added ACI_GAP_ADD_DEVICES_TO_LIST; Added HCI_LE_CHANNEL_SELECTION_ALGORITHM_EVENT.</p><p>July 2021 - Rev 1.33 - Removed ACI_GAP_START_NAME_DISCOVERY_PROC.</p><p>July 2021 - Rev 1.34 - Updated error status codes; Added HCI_LE_CONNECTION_UPDATE in BF variant.</p><p>October 2021 - Rev 1.35 - Fixed Scanning_PHYs values; Removed HCI_LE_Directed_Advertising_Report event in BO variant; Fixed names of some HCI commands; Added SMP mode in ACI_HAL_WRITE_CONFIG_DATA.</p><p>October 2021 - Rev 1.36 - Fixed NRPA use; Fixed names of some HCI commands.</p><p>December 2021 - Rev 1.37 - Added ACI_GAP_ADV_SET_RANDOM_ADDRESS; Added comment to ACI_HAL_SCAN_REQ_REPORT_EVENT; Updated scan range for extended advertising.</p><p>January 2022 - Rev 1.38 - Added PHY update feature in BF variant; Added additional beacon feature, HCI_LE_SET_PRIVACY_MODE and HCI_LE_SET_RESOLVABLE_PRIVATE_ADDRESS_TIMEOUT in BF and PO variants; Added ACI_HAL_SET_SLAVE_LATENCY in BF, PO and LO variants; Removed DTM feature from PO variant.</p><p>March 2022 - Rev 1.39 - Fixed Length_Of_Test_Data possible values.</p><p>March 2022 - Rev 1.40 - Fixed LE_Event_Mask default value; Added HCI_LE_READ_RF_PATH_COMPENSATION and HCI_LE_WRITE_RF_PATH_COMPENSATION.</p><p>March 2022 - Rev 1.41 - Aligned with Bluetooth spec. v.5.3.</p><p>April 2022 - Rev 1.42 - Added "LL Only Basic" variant; Added ACI_HAL_GET_LINK_STATUS in BF and PO variants; Added ACI_HAL_GET_ANCHOR_PERIOD in BF, PO and BO variants.</p><p>May 2022 - Rev 1.43 - Fixed default value of HCI_LE_ENHANCED_CONNECTION_COMPLETE_EVENT mask; Added HCI_LE_READ_PEER_RESOLVABLE_ADDRESS, HCI_LE_READ_LOCAL_RESOLVABLE_ADDRESS, HCI_LE_ENCRYPT and DTM commands in BF and PO variants; Removed HCI_LE_READ_RF_PATH_COMPENSATION and HCI_LE_WRITE_RF_PATH_COMPENSATION from LB and BO variants; Fixed Initiating_PHYs description; Indexed extended scan and initiating parameters.</p><p>June 2022 - Rev 1.44 - Added tone feature in BF, PO, LB and BO variants.</p><p>June 2022 - Rev 1.45 - Added note for ACI_GATT_UPDATE_CHAR_VALUE; Added LL scan channel map and "no blacklist" SMP mode in ACI_HAL_WRITE_CONFIG_DATA; Fixed possible values and added slot numbers for ACI_HAL_END_OF_RADIO_ACTIVITY_EVENT; Updated possible output values of ACI_HAL_GET_LINK_STATUS; Added ACI_GATT_STORE_DB; Fixed name of HCI_LE_Directed_Advertising_Report event; Added HCI_LE_LONG_TERM_KEY_REQUEST_EVENT in BF and PO variants; Removed ACI_HAL_GET_PM_DEBUG_INFO in LO variant.</p><p>July 2022 - Rev 1.46 - Fixed Event_Mask default value; Fixed extended scan interval range; Added ACI_HAL_READ_RSSI command; Removed ACI_HAL_READ_RAW_RSSI in LO variant.</p><p>August 2022 - Rev 1.47 - Fixed extended scan window range.</p><p>September 2022 - Rev 1.48 - Added possible values for HCI_HOST_BUFFER_SIZE; Removed ACI_HAL_READ_RADIO_REG, ACI_HAL_WRITE_RADIO_REG, ACI_HAL_RX_START and ACI_HAL_RX_STOP from LO variant.</p><p>October 2022 - Rev 1.49 - Added Enhanced ATT feature; Added new commands: ACI_GATT_SEND_MULT_NOTIFICATION and ACI_GATT_READ_MULTIPLE_VAR_CHAR_VALUE; Added new events: ACI_GATT_EATT_BEARER_EVENT and ACI_GATT_MULT_NOTIFICATION_EVENT; Changed ACI_GATT_ADD_CHAR, ACI_GATT_TX_POOL_AVAILABLE_EVENT and ACI_HAL_GET_LINK_STATUS descriptions; Removed ACI_GATT_PROC_COMPLETE_EVENT from PO variant; Added note for GAP peripheral commands that only support legacy advertising; Fixed formula of RF_Channel.</p><p>November 2022 - Rev 1.50 - Added LL background scan mode in ACI_HAL_WRITE_CONFIG_DATA; Created annex for TX Power Level; Added some missing error codes; Fixed the width of the counter in description of ACI_HAL_LE_TX_TEST_PACKET_NUMBER.</p><p>January 2023 - Rev 1.51 - Completed the description of Connection_Handle for some primitives; Added error code 4 for HCI_HARDWARE_ERROR_EVENT; Completed the description of ACI_GAP_ADDR_NOT_RESOLVED_EVENT.</p><p>February 2023 - Rev 1.52 - Added new ATT error codes; Completed the description of HCI_DISCONNECTION_COMPLETE_EVENT; Removed HCI_READ_RSSI and HCI_LE_READ_BUFFER_SIZE in BO variant; Updated HCI status error codes; Added CSA2 in PO variant.</p><p>March 2023 - Rev 1.53 - Added ACI_GATT_NOTIFICATION_COMPLETE_EVENT; Added GAP service additional record number in ACI_HAL_WRITE_CONFIG_DATA; Completed description of ACI_GATT_ADD_CHAR and ACI_GATT_ADD_CHAR_DESC; Added HCI_LE_GENERATE_DHKEY_V2; Fixed description of HCI_ENCRYPTION_KEY_REFRESH_COMPLETE_EVENT, ACI_GATT_SET_EVENT_MASK, ACI_GAP_SET_EVENT_MASK and ACI_HAL_SET_EVENT_MASK; Added SC key type in ACI_HAL_WRITE_CONFIG_DATA.</p><p>May 2023 - Rev 1.54 - Changed description of ACI_GAP_SET_OOB_DATA, ACI_GAP_GET_OOB_DATA and ACI_GAP_SET_DIRECT_CONNECTABLE; Updated description of scanning and initiator filter policy; Renamed ACI_GAP_CONFIGURE_WHITELIST, ACI_HAL_SET_SLAVE_LATENCY, ACI_GAP_SLAVE_SECURITY_REQ and ACI_GAP_SLAVE_SECURITY_INITIATED_EVENT, as well as some parameter names.</p><p>June 2023 - Rev 1.55 - Changed description of ACI_HAL_SET_TX_POWER_LEVEL; Fixed maximum value of MPS; Changed note for ACI_GATT_UPDATE_CHAR_VALUE; Changed description of PHY_options; Added HCI_LE_ENHANCED_CONNECTION_COMPLETE_EVENT as "Events generated"; Updated HCI_READ_LOCAL_VERSION_INFORMATION; Added some details about bonding table.</p><h2>Contents</h2><p><a href="#HCI/ACI commands_anchor">HCI/ACI commands</a></p><p><a href="#HCI/ACI events_anchor">HCI/ACI events</a></p><p><a href="#Annex_anchor">Annex</a></p><h1><a name="HCI/ACI commands_anchor">HCI/ACI commands</a></h1><p><a href="#HCI commands_anchor">HCI commands</a></p><p><a href="#HCI TESTING commands_anchor">HCI TESTING commands</a></p><p><a href="#ACI HAL commands_anchor">ACI HAL commands</a></p><p><a href="#ACI GAP commands_anchor">ACI GAP commands</a></p><p><a href="#ACI GATT/ATT commands_anchor">ACI GATT/ATT commands</a></p><p><a href="#ACI L2CAP commands_anchor">ACI L2CAP commands</a></p><p>Note: in the command tables, a "Y" in the "BF", "PO", "LO", "LB" or "BO" column, means that the corresponding command applies to the "Basic Features", "Peripheral Only", "Link Layer Only", "Link Layer Only Basic" or "Beacon Only" variant of the BLE stack, respectively.</p><h2><a name="HCI commands_anchor">HCI commands</a></h2><h2></h2><table width="800" border="1" class="reference">
<tr><th>Command</th><th>Opcode</th><th>BF</th><th>PO</th><th>LO</th><th>LB</th><th>BO</th></tr>
<tr><td><a href="#HCI_DISCONNECT_anchor">HCI_DISCONNECT</a></td><td><p>0x0406</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_READ_REMOTE_VERSION_INFORMATION_anchor">HCI_READ_REMOTE_VERSION_INFORMATION</a></td><td><p>0x041D</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_SET_EVENT_MASK_anchor">HCI_SET_EVENT_MASK</a></td><td><p>0x0C01</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td></tr>
<tr><td><a href="#HCI_RESET_anchor">HCI_RESET</a></td><td><p>0x0C03</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td></tr>
<tr><td><a href="#HCI_READ_TRANSMIT_POWER_LEVEL_anchor">HCI_READ_TRANSMIT_POWER_LEVEL</a></td><td><p>0x0C2D</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_SET_CONTROLLER_TO_HOST_FLOW_CONTROL_anchor">HCI_SET_CONTROLLER_TO_HOST_FLOW_CONTROL</a></td><td><p>0x0C31</p>
</td><td></td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_HOST_BUFFER_SIZE_anchor">HCI_HOST_BUFFER_SIZE</a></td><td><p>0x0C33</p>
</td><td></td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_HOST_NUMBER_OF_COMPLETED_PACKETS_anchor">HCI_HOST_NUMBER_OF_COMPLETED_PACKETS</a></td><td><p>0x0C35</p>
</td><td></td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_READ_LOCAL_VERSION_INFORMATION_anchor">HCI_READ_LOCAL_VERSION_INFORMATION</a></td><td><p>0x1001</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td></tr>
<tr><td><a href="#HCI_READ_LOCAL_SUPPORTED_COMMANDS_anchor">HCI_READ_LOCAL_SUPPORTED_COMMANDS</a></td><td><p>0x1002</p>
</td><td></td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td></tr>
<tr><td><a href="#HCI_READ_LOCAL_SUPPORTED_FEATURES_anchor">HCI_READ_LOCAL_SUPPORTED_FEATURES</a></td><td><p>0x1003</p>
</td><td></td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td></tr>
<tr><td><a href="#HCI_READ_BD_ADDR_anchor">HCI_READ_BD_ADDR</a></td><td><p>0x1009</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td></tr>
<tr><td><a href="#HCI_READ_RSSI_anchor">HCI_READ_RSSI</a></td><td><p>0x1405</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_LE_SET_EVENT_MASK_anchor">HCI_LE_SET_EVENT_MASK</a></td><td><p>0x2001</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td></tr>
<tr><td><a href="#HCI_LE_READ_BUFFER_SIZE_anchor">HCI_LE_READ_BUFFER_SIZE</a></td><td><p>0x2002</p>
</td><td></td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_LE_READ_LOCAL_SUPPORTED_FEATURES_anchor">HCI_LE_READ_LOCAL_SUPPORTED_FEATURES</a></td><td><p>0x2003</p>
</td><td></td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td></tr>
<tr><td><a href="#HCI_LE_SET_RANDOM_ADDRESS_anchor">HCI_LE_SET_RANDOM_ADDRESS</a></td><td><p>0x2005</p>
</td><td></td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td></tr>
<tr><td><a href="#HCI_LE_SET_ADVERTISING_PARAMETERS_anchor">HCI_LE_SET_ADVERTISING_PARAMETERS</a></td><td><p>0x2006</p>
</td><td></td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td></tr>
<tr><td><a href="#HCI_LE_READ_ADVERTISING_PHYSICAL_CHANNEL_TX_POWER_anchor">HCI_LE_READ_ADVERTISING_PHYSICAL_CHANNEL_TX_POWER</a></td><td><p>0x2007</p>
</td><td></td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td></tr>
<tr><td><a href="#HCI_LE_SET_ADVERTISING_DATA_anchor">HCI_LE_SET_ADVERTISING_DATA</a></td><td><p>0x2008</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td></tr>
<tr><td><a href="#HCI_LE_SET_SCAN_RESPONSE_DATA_anchor">HCI_LE_SET_SCAN_RESPONSE_DATA</a></td><td><p>0x2009</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td></tr>
<tr><td><a href="#HCI_LE_SET_ADVERTISING_ENABLE_anchor">HCI_LE_SET_ADVERTISING_ENABLE</a></td><td><p>0x200A</p>
</td><td></td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td></tr>
<tr><td><a href="#HCI_LE_SET_SCAN_PARAMETERS_anchor">HCI_LE_SET_SCAN_PARAMETERS</a></td><td><p>0x200B</p>
</td><td></td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td></tr>
<tr><td><a href="#HCI_LE_SET_SCAN_ENABLE_anchor">HCI_LE_SET_SCAN_ENABLE</a></td><td><p>0x200C</p>
</td><td></td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td></tr>
<tr><td><a href="#HCI_LE_CREATE_CONNECTION_anchor">HCI_LE_CREATE_CONNECTION</a></td><td><p>0x200D</p>
</td><td></td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_LE_CREATE_CONNECTION_CANCEL_anchor">HCI_LE_CREATE_CONNECTION_CANCEL</a></td><td><p>0x200E</p>
</td><td></td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_LE_READ_FILTER_ACCEPT_LIST_SIZE_anchor">HCI_LE_READ_FILTER_ACCEPT_LIST_SIZE</a></td><td><p>0x200F</p>
</td><td></td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td></tr>
<tr><td><a href="#HCI_LE_CLEAR_FILTER_ACCEPT_LIST_anchor">HCI_LE_CLEAR_FILTER_ACCEPT_LIST</a></td><td><p>0x2010</p>
</td><td></td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td></tr>
<tr><td><a href="#HCI_LE_ADD_DEVICE_TO_FILTER_ACCEPT_LIST_anchor">HCI_LE_ADD_DEVICE_TO_FILTER_ACCEPT_LIST</a></td><td><p>0x2011</p>
</td><td></td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td></tr>
<tr><td><a href="#HCI_LE_REMOVE_DEVICE_FROM_FILTER_ACCEPT_LIST_anchor">HCI_LE_REMOVE_DEVICE_FROM_FILTER_ACCEPT_LIST</a></td><td><p>0x2012</p>
</td><td></td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td></tr>
<tr><td><a href="#HCI_LE_CONNECTION_UPDATE_anchor">HCI_LE_CONNECTION_UPDATE</a></td><td><p>0x2013</p>
</td><td><p>Y</p>
</td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_LE_SET_HOST_CHANNEL_CLASSIFICATION_anchor">HCI_LE_SET_HOST_CHANNEL_CLASSIFICATION</a></td><td><p>0x2014</p>
</td><td></td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_LE_READ_CHANNEL_MAP_anchor">HCI_LE_READ_CHANNEL_MAP</a></td><td><p>0x2015</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_LE_READ_REMOTE_FEATURES_anchor">HCI_LE_READ_REMOTE_FEATURES</a></td><td><p>0x2016</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_LE_ENCRYPT_anchor">HCI_LE_ENCRYPT</a></td><td><p>0x2017</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_LE_RAND_anchor">HCI_LE_RAND</a></td><td><p>0x2018</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td></tr>
<tr><td><a href="#HCI_LE_ENABLE_ENCRYPTION_anchor">HCI_LE_ENABLE_ENCRYPTION</a></td><td><p>0x2019</p>
</td><td></td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_LE_LONG_TERM_KEY_REQUEST_REPLY_anchor">HCI_LE_LONG_TERM_KEY_REQUEST_REPLY</a></td><td><p>0x201A</p>
</td><td></td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_LE_LONG_TERM_KEY_REQUEST_NEGATIVE_REPLY_anchor">HCI_LE_LONG_TERM_KEY_REQUEST_NEGATIVE_REPLY</a></td><td><p>0x201B</p>
</td><td></td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_LE_READ_SUPPORTED_STATES_anchor">HCI_LE_READ_SUPPORTED_STATES</a></td><td><p>0x201C</p>
</td><td></td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td></tr>
<tr><td><a href="#HCI_LE_SET_DATA_LENGTH_anchor">HCI_LE_SET_DATA_LENGTH</a></td><td><p>0x2022</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_LE_READ_SUGGESTED_DEFAULT_DATA_LENGTH_anchor">HCI_LE_READ_SUGGESTED_DEFAULT_DATA_LENGTH</a></td><td><p>0x2023</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_LE_WRITE_SUGGESTED_DEFAULT_DATA_LENGTH_anchor">HCI_LE_WRITE_SUGGESTED_DEFAULT_DATA_LENGTH</a></td><td><p>0x2024</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_LE_READ_LOCAL_P256_PUBLIC_KEY_anchor">HCI_LE_READ_LOCAL_P256_PUBLIC_KEY</a></td><td><p>0x2025</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_LE_GENERATE_DHKEY_anchor">HCI_LE_GENERATE_DHKEY</a></td><td><p>0x2026</p>
</td><td></td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_LE_ADD_DEVICE_TO_RESOLVING_LIST_anchor">HCI_LE_ADD_DEVICE_TO_RESOLVING_LIST</a></td><td><p>0x2027</p>
</td><td></td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_LE_REMOVE_DEVICE_FROM_RESOLVING_LIST_anchor">HCI_LE_REMOVE_DEVICE_FROM_RESOLVING_LIST</a></td><td><p>0x2028</p>
</td><td></td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_LE_CLEAR_RESOLVING_LIST_anchor">HCI_LE_CLEAR_RESOLVING_LIST</a></td><td><p>0x2029</p>
</td><td></td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_LE_READ_RESOLVING_LIST_SIZE_anchor">HCI_LE_READ_RESOLVING_LIST_SIZE</a></td><td><p>0x202A</p>
</td><td></td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_LE_READ_PEER_RESOLVABLE_ADDRESS_anchor">HCI_LE_READ_PEER_RESOLVABLE_ADDRESS</a></td><td><p>0x202B</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_LE_READ_LOCAL_RESOLVABLE_ADDRESS_anchor">HCI_LE_READ_LOCAL_RESOLVABLE_ADDRESS</a></td><td><p>0x202C</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_LE_SET_ADDRESS_RESOLUTION_ENABLE_anchor">HCI_LE_SET_ADDRESS_RESOLUTION_ENABLE</a></td><td><p>0x202D</p>
</td><td></td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_LE_SET_RESOLVABLE_PRIVATE_ADDRESS_TIMEOUT_anchor">HCI_LE_SET_RESOLVABLE_PRIVATE_ADDRESS_TIMEOUT</a></td><td><p>0x202E</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_LE_READ_MAXIMUM_DATA_LENGTH_anchor">HCI_LE_READ_MAXIMUM_DATA_LENGTH</a></td><td><p>0x202F</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_LE_READ_PHY_anchor">HCI_LE_READ_PHY</a></td><td><p>0x2030</p>
</td><td><p>Y</p>
</td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_LE_SET_DEFAULT_PHY_anchor">HCI_LE_SET_DEFAULT_PHY</a></td><td><p>0x2031</p>
</td><td><p>Y</p>
</td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_LE_SET_PHY_anchor">HCI_LE_SET_PHY</a></td><td><p>0x2032</p>
</td><td><p>Y</p>
</td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_LE_SET_ADVERTISING_SET_RANDOM_ADDRESS_anchor">HCI_LE_SET_ADVERTISING_SET_RANDOM_ADDRESS</a></td><td><p>0x2035</p>
</td><td></td><td></td><td><p>Y</p>
</td><td></td><td></td></tr>
<tr><td><a href="#HCI_LE_SET_EXTENDED_ADVERTISING_PARAMETERS_anchor">HCI_LE_SET_EXTENDED_ADVERTISING_PARAMETERS</a></td><td><p>0x2036</p>
</td><td></td><td></td><td><p>Y</p>
</td><td></td><td></td></tr>
<tr><td><a href="#HCI_LE_SET_EXTENDED_ADVERTISING_DATA_anchor">HCI_LE_SET_EXTENDED_ADVERTISING_DATA</a></td><td><p>0x2037</p>
</td><td></td><td></td><td><p>Y</p>
</td><td></td><td></td></tr>
<tr><td><a href="#HCI_LE_SET_EXTENDED_SCAN_RESPONSE_DATA_anchor">HCI_LE_SET_EXTENDED_SCAN_RESPONSE_DATA</a></td><td><p>0x2038</p>
</td><td></td><td></td><td><p>Y</p>
</td><td></td><td></td></tr>
<tr><td><a href="#HCI_LE_SET_EXTENDED_ADVERTISING_ENABLE_anchor">HCI_LE_SET_EXTENDED_ADVERTISING_ENABLE</a></td><td><p>0x2039</p>
</td><td></td><td></td><td><p>Y</p>
</td><td></td><td></td></tr>
<tr><td><a href="#HCI_LE_READ_MAXIMUM_ADVERTISING_DATA_LENGTH_anchor">HCI_LE_READ_MAXIMUM_ADVERTISING_DATA_LENGTH</a></td><td><p>0x203A</p>
</td><td></td><td></td><td><p>Y</p>
</td><td></td><td></td></tr>
<tr><td><a href="#HCI_LE_READ_NUMBER_OF_SUPPORTED_ADVERTISING_SETS_anchor">HCI_LE_READ_NUMBER_OF_SUPPORTED_ADVERTISING_SETS</a></td><td><p>0x203B</p>
</td><td></td><td></td><td><p>Y</p>
</td><td></td><td></td></tr>
<tr><td><a href="#HCI_LE_REMOVE_ADVERTISING_SET_anchor">HCI_LE_REMOVE_ADVERTISING_SET</a></td><td><p>0x203C</p>
</td><td></td><td></td><td><p>Y</p>
</td><td></td><td></td></tr>
<tr><td><a href="#HCI_LE_CLEAR_ADVERTISING_SETS_anchor">HCI_LE_CLEAR_ADVERTISING_SETS</a></td><td><p>0x203D</p>
</td><td></td><td></td><td><p>Y</p>
</td><td></td><td></td></tr>
<tr><td><a href="#HCI_LE_SET_EXTENDED_SCAN_PARAMETERS_anchor">HCI_LE_SET_EXTENDED_SCAN_PARAMETERS</a></td><td><p>0x2041</p>
</td><td></td><td></td><td><p>Y</p>
</td><td></td><td></td></tr>
<tr><td><a href="#HCI_LE_SET_EXTENDED_SCAN_ENABLE_anchor">HCI_LE_SET_EXTENDED_SCAN_ENABLE</a></td><td><p>0x2042</p>
</td><td></td><td></td><td><p>Y</p>
</td><td></td><td></td></tr>
<tr><td><a href="#HCI_LE_EXTENDED_CREATE_CONNECTION_anchor">HCI_LE_EXTENDED_CREATE_CONNECTION</a></td><td><p>0x2043</p>
</td><td></td><td></td><td><p>Y</p>
</td><td></td><td></td></tr>
<tr><td><a href="#HCI_LE_READ_TRANSMIT_POWER_anchor">HCI_LE_READ_TRANSMIT_POWER</a></td><td><p>0x204B</p>
</td><td></td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td></tr>
<tr><td><a href="#HCI_LE_READ_RF_PATH_COMPENSATION_anchor">HCI_LE_READ_RF_PATH_COMPENSATION</a></td><td><p>0x204C</p>
</td><td></td><td></td><td><p>Y</p>
</td><td></td><td></td></tr>
<tr><td><a href="#HCI_LE_WRITE_RF_PATH_COMPENSATION_anchor">HCI_LE_WRITE_RF_PATH_COMPENSATION</a></td><td><p>0x204D</p>
</td><td></td><td></td><td><p>Y</p>
</td><td></td><td></td></tr>
<tr><td><a href="#HCI_LE_SET_PRIVACY_MODE_anchor">HCI_LE_SET_PRIVACY_MODE</a></td><td><p>0x204E</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_LE_GENERATE_DHKEY_V2_anchor">HCI_LE_GENERATE_DHKEY_V2</a></td><td><p>0x205E</p>
</td><td></td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
</table><h2><a name="HCI_DISCONNECT_anchor">HCI_DISCONNECT</a></h2><h3>Description</h3><p>The <a href="#HCI_DISCONNECT_anchor">HCI_DISCONNECT</a> is used to terminate an existing connection. The Connection_Handle command parameter indicates which connection is to be disconnected. The Reason command parameter indicates the reason for ending the connection. The remote Controller will receive the Reason command parameter in the <a href="#HCI_DISCONNECTION_COMPLETE_EVENT_anchor">HCI_DISCONNECTION_COMPLETE_EVENT</a> event. All synchronous connections on a physical link should be disconnected before the ACL connection on the same physical connection is disconnected.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.1.6].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Reason</p>
</td><td><p>1</p>
</td><td><p>The reason for ending the connection.</p>
</td><td><li>0x05: Authentication Failure</li><li>0x13: Remote User Terminated Connection</li><li>0x14: Remote Device Terminated Connection due to Low Resources</li><li>0x15: Remote Device Terminated Connection due to Power Off</li><li>0x1A: Unsupported Remote Feature</li><li>0x3B: Unacceptable Connection Parameters</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#HCI_DISCONNECTION_COMPLETE_EVENT_anchor">HCI_DISCONNECTION_COMPLETE_EVENT</a></li><h2><a name="HCI_READ_REMOTE_VERSION_INFORMATION_anchor">HCI_READ_REMOTE_VERSION_INFORMATION</a></h2><h3>Description</h3><p>This command will obtain the values for the version information for the remote device identified by the Connection_Handle parameter. The Connection_Handle must be a Connection_Handle for an ACL or LE connection.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.1.23].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#HCI_READ_REMOTE_VERSION_INFORMATION_COMPLETE_EVENT_anchor">HCI_READ_REMOTE_VERSION_INFORMATION_COMPLETE_EVENT</a></li><h2><a name="HCI_SET_EVENT_MASK_anchor">HCI_SET_EVENT_MASK</a></h2><h3>Description</h3><p>The Set_Event_Mask command is used to control which events are generated by the HCI for the Host. If the bit in the Event_Mask is set to a one, then the event associated with that bit will be enabled. For an LE Controller, the LE Meta Event bit in the Event_Mask shall enable or disable all LE events in the LE Meta Event. The Host has to deal with each event that occurs. The event mask allows the Host to control how much it is interrupted.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.3.1].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Event_Mask</p>
</td><td><p>8</p>
</td><td><p>Event mask. Default: 0x2000FFFFFFFFFFFF</p>
</td><td><p>Bitmask of:</p><li>0x0000000000000000: No events specified</li><li>0x0000000000000010: Disconnection Complete Event</li><li>0x0000000000000080: Encryption Change Event</li><li>0x0000000000000800: Read Remote Version Information Complete Event</li><li>0x0000000000008000: Hardware Error Event</li><li>0x0000000002000000: Data Buffer Overflow Event (not supported on STM32WB)</li><li>0x0000800000000000: Encryption Key Refresh Complete Event</li><li>0x2000000000000000: LE Meta-Event</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_RESET_anchor">HCI_RESET</a></h2><h3>Description</h3><p>The Reset command resets the Link Layer on an LE Controller. The Reset command shall not affect the used HCI transport layer since the HCI transport layers may have reset mechanisms of their own. After the reset is completed, the current operational state is lost, the Controller enters standby mode and the Controller automatically reverts to the default values for the parameters for which default values are defined in the specification.<br>Note: The Reset command does not necessarily perform a hardware reset. This is implementation defined.<br>The Host shall not send additional HCI commands before the Command Complete event related to the Reset command has been received.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.3.2].</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_READ_TRANSMIT_POWER_LEVEL_anchor">HCI_READ_TRANSMIT_POWER_LEVEL</a></h2><h3>Description</h3><p>This command reads the values for the Transmit_Power_Level parameter for the specified Connection_Handle. The Connection_Handle shall be a Connection_Handle for an ACL connection.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.3.35].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Type</p>
</td><td><p>1</p>
</td><td><p>Current or maximum transmit power level.</p>
</td><td><li>0x00: Read Current Transmit Power Level.</li><li>0x01: Read Maximum Transmit Power Level.</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Transmit_Power_Level</p>
</td><td><p>1</p>
</td><td><p>Size: 1 Octet (signed integer).
Units: dBm.</p>
</td><td><li>-30 ... 20</li></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_SET_CONTROLLER_TO_HOST_FLOW_CONTROL_anchor">HCI_SET_CONTROLLER_TO_HOST_FLOW_CONTROL</a></h2><h3>Description</h3><p>This command is used by the Host to turn flow control on or off for data and/or voice sent in the direction from the Controller to the Host. If flow control is turned off, the Host should not send the Host_Number_Of_Completed_Packets command. That command will be ignored by the Controller if it is sent by the Host and flow control is off. If flow control is turned on for HCI ACL Data Packets and off for HCI synchronous Data Packets, Host_Number_Of_Completed_Packets commands sent by the Host should only contain Connection_Handles for ACL connections. If flow control is turned off for HCI ACL Data Packets and on for HCI synchronous Data Packets, Host_Number_Of_Completed_Packets commands sent by the Host should only contain Connection_Handles for synchronous connections. If flow control is turned on for HCI ACL Data Packets and HCI synchronous Data Packets, the Host will send Host_Number_Of_Completed_Packets commands both for ACL connections and synchronous connections.<br>The Flow_Control_Enable parameter shall only be changed if no connections exist.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.3.38].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Flow_Control_Enable</p>
</td><td><p>1</p>
</td><td><p>Enable/Disable the Flow Control</p>
</td><td><li>0x00: Flow control off in direction from Controller to Host. Default.</li><li>0x01: Flow control on for HCI ACL Data Packets and off for HCI synchronous.Data Packets in direction from Controller to Host.</li><li>0x02: Flow control off for HCI ACL Data Packets and on for HCI synchronous.Data Packets in direction from Controller to Host.</li><li>0x03: Flow control on both for HCI ACL Data Packets and HCI synchronous.Data Packets in direction from Controller to Host.</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_HOST_BUFFER_SIZE_anchor">HCI_HOST_BUFFER_SIZE</a></h2><h3>Description</h3><p>The Host_Buffer_Size command is used by the Host to notify the Controller about the maximum size of the data portion of HCI ACL and synchronous Data Packets sent from the Controller to the Host. The Controller shall segment the data to be transmitted from the Controller to the Host according to these sizes, so that the HCI Data Packets will contain data with up to these sizes. The Host_Buffer_Size command also notifies the Controller about the total number of HCI ACL and synchronous Data Packets that can be stored in the data buffers of the Host. If flow control from the Controller to the Host is turned off, and the Host_Buffer_Size command has not been issued by the Host, this means that the Controller will send HCI Data Packets to the Host with any lengths the Controller wants to use, and it is assumed that the data buffer sizes of the Host are unlimited. If flow control from the Controller to the Host is turned on, the Host_Buffer_Size command shall after a power-on or a reset always be sent by the Host before the first Host_Number_Of_Completed_Packets command is sent.<br>The Set Controller To Host Flow Control Command is used to turn flow control on or off.<br>The Host_ACL_Data_Packet_Length command parameter will be used to determine the size of the L2CAP segments contained in ACL Data Packets, which are transferred from the Controller to the Host.<br>The Host_Synchronous_Data_Packet_Length command parameter is used to determine the maximum size of HCI synchronous Data Packets. Both the Host and the Controller shall support command and event packets, where the data portion (excluding header) contained in the packets is 255 octets in size.<br>The Host_Total_Num_ACL_Data_Packets command parameter contains the total number of HCI ACL Data Packets that can be stored in the data buffers of the Host. The Controller will determine how the buffers are to be divided between different Connection_Handles.<br>The Host_Total_Num_Synchronous_Data_Packets command parameter gives the same information for HCI synchronous Data Packets.<br>Note: The Host_ACL_Data_Packet_Length and Host_Synchronous_Data_Packet_Length command parameters do not include the length of the HCI Data Packet header.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.3.39].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Host_ACL_Data_Packet_Length</p>
</td><td><p>2</p>
</td><td><p>Maximum length (in octets) of the data portion of each HCI ACL Data Packet that the Host is able to accept.</p>
</td><td><li>251 ... 65535</li></td></tr>
<tr><td><p>Host_Synchronous_Data_Packet_Length</p>
</td><td><p>1</p>
</td><td><p>Maximum length (in octets) of the data portion of each HCI synchronous Data Packet that the Host is able to accept. Not used.</p>
</td><td></tr>
<tr><td><p>Host_Total_Num_ACL_Data_Packets</p>
</td><td><p>2</p>
</td><td><p>Total number of HCI ACL Data Packets that can be stored in the data buffers of the Host.</p>
</td><td><li>1 ... 65535</li></td></tr>
<tr><td><p>Host_Total_Num_Synchronous_Data_Packets</p>
</td><td><p>2</p>
</td><td><p>Total number of HCI synchronous Data Packets that can be stored in the data buffers of the Host. Not used.</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_HOST_NUMBER_OF_COMPLETED_PACKETS_anchor">HCI_HOST_NUMBER_OF_COMPLETED_PACKETS</a></h2><h3>Description</h3><p>The Host_Number_Of_Completed_Packets command is used by the Host to indicate to the Controller the number of HCI Data Packets that have been completed for each Connection_Handle since the previous Host_Number_Of_Completed_Packets command was sent to the Controller. This means that the corresponding buffer space has been freed in the Host. Based on this information, and the Host_Total_Num_ACL_Data_Packets and Host_Total_Num_Synchronous_Data_Packets command parameters of the Host_Buffer_Size command, the Controller can determine for which Connection_Handles the following HCI Data Packets should be sent to the Host. The command should only be issued by the Host if flow control in the direction from the Controller to the Host is on and there is at least one connection, or if the Controller is in local loopback mode. Otherwise, the command will be ignored by the Controller. When the Host has completed one or more HCI Data Packet(s) it shall send a Host_Number_Of_Completed_Packets command to the Controller, until it finally reports that all pending HCI Data Packets have been completed. The frequency at which this command is sent is manufacturer specific.<br>The Set Controller To Host Flow Control Command is used to turn flow control on or off. If flow control from the Controller to the Host is turned on, the Host_Buffer_Size command shall always be sent by the Host after a power-on or a reset before the first Host_Number_Of_Completed_Packets command is sent.<br>Note: The Host_Number_Of_Completed_Packets command is a special command in the sense that no event is normally generated after the command has completed. The command may be sent at any time by the Host when there is at least one connection, or if the Controller is in local loopback mode independent of other commands. The normal flow control for commands is not used for the Host_Number_Of_Completed_Packets command.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.3.40].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Number_Of_Handles</p>
</td><td><p>1</p>
</td><td><p>The number of Connection_Handles and Host_Num_Of_Completed_Packets        parameters pairs contained in this command.</p>
</td><td><p>0-255</p>
</td></tr>
<tr><td><p>Connection_Handle[i]</p>
</td><td><p>Number_Of_Handles * 2</p>
</td><td><p>Connection_Handle</p>
</td><td><p>0x0000-0x0EFF</p>
</td></tr>
<tr><td><p>Host_Num_Of_Completed_Packets[i]</p>
</td><td><p>Number_Of_Handles * 2</p>
</td><td><p>The number of HCI Data Packets         that have been completed for the associated Connection_Handle since the previous time the event was returned.</p>
</td><td><p>0x0000-0xFFFF</p>
</td></tr>
</table><h3>Output parameters</h3><p>None</p><h3>Events generated</h3><p>Normally, no event is generated after the Host_Number_Of_Completed_Packets command has completed. However, if the Host_Number_Of_Completed_Packets command contains one or more invalid parameters, the Controller shall return a Command Complete event with a failure status indicating the Invalid HCI Command Parameters error code. The Host may send the Host_Number_Of_Completed_Packets command at any time when there is at least one connection, or if the Controller is in local loopback mode. The normal flow control for commands is not used for this command.</p><h2><a name="HCI_READ_LOCAL_VERSION_INFORMATION_anchor">HCI_READ_LOCAL_VERSION_INFORMATION</a></h2><h3>Description</h3><p>This command reads the values for the version information for the local Controller.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.4.1].</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>HCI_Version</p>
</td><td><p>1</p>
</td><td><p>Version of the HCI Specification supported by the Controller. See Bluetooth Assigned Numbers.</p>
</td><td></tr>
<tr><td><p>HCI_Subversion</p>
</td><td><p>2</p>
</td><td><p>Revision of the HCI implementation in the Controller. This value is vendor-specific.</p>
</td><td></tr>
<tr><td><p>LMP_Version</p>
</td><td><p>1</p>
</td><td><p>Version of the Current LMP supported by the Controller. See Bluetooth Assigned Numbers.</p>
</td><td></tr>
<tr><td><p>Company_Identifier</p>
</td><td><p>2</p>
</td><td><p>Company identifier for the manufacturer of the Controller. See Bluetooth Assigned Numbers.</p>
</td><td></tr>
<tr><td><p>LMP_Subversion</p>
</td><td><p>2</p>
</td><td><p>Subversion of the Current LMP in the Controller. This value is vendor-specific.</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_READ_LOCAL_SUPPORTED_COMMANDS_anchor">HCI_READ_LOCAL_SUPPORTED_COMMANDS</a></h2><h3>Description</h3><p>This command reads the list of HCI commands supported for the local Controller. This command shall return the Supported_Commands configuration parameter. It is implied that if a command is listed as supported, the feature underlying that command is also supported.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.4.2].</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Supported_Commands</p>
</td><td><p>64</p>
</td><td><p>Bit mask for each HCI Command. If a bit is 1, the Controller supports the corresponding command and the features required for the command.
Unsupported or undefined commands shall be set to 0.</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_READ_LOCAL_SUPPORTED_FEATURES_anchor">HCI_READ_LOCAL_SUPPORTED_FEATURES</a></h2><h3>Description</h3><p>This command requests a list of the supported features for the local Controller. This command will return a list of the LMP features. For details see Part C, Link Manager Protocol Specification.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.4.3].</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>LMP_Features</p>
</td><td><p>8</p>
</td><td><p>Bit Mask List of LMP features.</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_READ_BD_ADDR_anchor">HCI_READ_BD_ADDR</a></h2><h3>Description</h3><p>On an LE Controller, this command shall read the Public Device Address as defined in [Vol 6] Part B, Section 1.3, Device Address. If this Controller does not have a Public Device Address, the value 0x000000000000 shall be returned.<br>On an LE Controller, the public address shall be the same as the BD_ADDR.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.4.6].</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>BD_ADDR</p>
</td><td><p>6</p>
</td><td><p>BD_ADDR ( Bluetooth Device Address) of the Device.</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_READ_RSSI_anchor">HCI_READ_RSSI</a></h2><h3>Description</h3><p>This command reads the Received Signal Strength Indication (RSSI) value from a Controller. For an LE transport, a Connection_Handle is used as the Handle command parameter and return parameter. The meaning of the RSSI metric is an absolute receiver signal strength value in dBm to +/- 6 dB accuracy. If the RSSI cannot be read, the RSSI metric shall be set to 127.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.5.4].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>RSSI</p>
</td><td><p>1</p>
</td><td><p>RSSI (signed integer).
Units: dBm.</p>
</td><td><li>127: RSSI not available</li><li>-127 ... 20</li></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_SET_EVENT_MASK_anchor">HCI_LE_SET_EVENT_MASK</a></h2><h3>Description</h3><p>The LE_Set_Event_Mask command is used to control which LE events are generated by the HCI for the Host. If the bit in the LE_Event_Mask is set to a one, then the event associated with that bit will be enabled. The Host has to deal with each event that is generated by an LE Controller. The event mask allows the Host to control which events will interrupt it.<br>For LE events to be generated, the LE Meta-Event bit in the Event_Mask shall also be set. If that bit is not set, then LE events shall not be generated, regardless of how the LE_Event_Mask is set.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.1].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>LE_Event_Mask</p>
</td><td><p>8</p>
</td><td><p>LE event mask. Default: 0x000000000003185F.</p>
</td><td><p>Bitmask of:</p><li>0x0000000000000000: No LE events specified</li><li>0x0000000000000001: LE Connection Complete Event</li><li>0x0000000000000002: LE Advertising Report Event</li><li>0x0000000000000004: LE Connection Update Complete Event</li><li>0x0000000000000008: LE Read Remote Used Features Complete Event</li><li>0x0000000000000010: LE Long Term Key Request Event</li><li>0x0000000000000020: LE Remote Connection Parameter Request Event</li><li>0x0000000000000040: LE Data Length Change Event</li><li>0x0000000000000080: LE Read Local P-256 Public Key Complete Event</li><li>0x0000000000000100: LE Generate DHKey Complete Event</li><li>0x0000000000000200: LE Enhanced Connection Complete Event</li><li>0x0000000000000400: LE Direct Advertising Report Event</li><li>0x0000000000000800: LE PHY Update Complete Event</li><li>0x0000000000001000: LE Extended Advertising Report Event</li><li>0x0000000000002000: LE Periodic Advertising Sync Established Event</li><li>0x0000000000004000: LE Periodic Advertising Report Event</li><li>0x0000000000008000: LE Periodic Advertising Sync Lost Event</li><li>0x0000000000010000: LE Extended Scan Timeout Event</li><li>0x0000000000020000: LE Extended Advertising Set Terminated Event</li><li>0x0000000000040000: LE Scan Request Received Event</li><li>0x0000000000080000: LE Channel Selection Algorithm Event</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_READ_BUFFER_SIZE_anchor">HCI_LE_READ_BUFFER_SIZE</a></h2><h3>Description</h3><p>The LE_Read_Buffer_Size command is used to read the maximum size of the data portion of HCI LE ACL Data Packets sent from the Host to the Controller.<br>The Host will segment the data transmitted to the Controller according to these values, so that the HCI Data Packets will contain data with up to this size. The LE_Read_Buffer_Size command also returns the total number of HCI LE ACL Data Packets that can be stored in the data buffers of the Controller. The LE_Read_Buffer_Size command must be issued by the Host before it sends any data to an LE Controller (see Section 4.1.1).<br>If the Controller returns a length value of zero, the Host shall use the Read_Buffer_Size command to determine the size of the data buffers.<br>Note: Both the Read_Buffer_Size and LE_Read_Buffer_Size commands may return buffer length and number of packets parameter values that are nonzero.<br>The HC_LE_ACL_Data_Packet_Length return parameter shall be used to determine the size of the L2CAP PDU segments contained in ACL Data Packets, which are transferred from the Host to the Controller to be broken up into packets by the Link Layer. Both the Host and the Controller shall support command and event packets, where the data portion (excluding header) contained in the packets is 255 octets in size. The HC_Total_Num_LE_ACL_Data_Packets return parameter contains the total number of HCI ACL Data Packets that can be stored in the data buffers of the Controller. The Host determines how the buffers are to be divided between different Connection Handles.<br>Note: The HC_LE_ACL_Data_Packet_Length return parameter does not include the length of the HCI Data Packet header.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.2].</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>HC_LE_ACL_Data_Packet_Length</p>
</td><td><p>2</p>
</td><td><p>Used to determine the maximum size of the L2CAP PDU segments that are contained in ACL data packets, and which are transferred from the Host to the Controller to be broken up into packets by the Link Layer.</p>
</td><td><li>0x0000: No dedicated LE Buffer exists.</li><li>0x001B ... 0x00FF: Maximum length (in octets) of the data portion of each HCI ACL data packet.</li></td></tr>
<tr><td><p>HC_Total_Num_LE_ACL_Data_Packets</p>
</td><td><p>1</p>
</td><td><p>Contains the total number of HCI ACL Data packets that can be stored in the data buffers of the Controller.</p>
</td><td><li>0x00: No dedicated LE Buffer exists.</li><li>0x01 ... 0xFF: The total number of HCI ACL data packets that can be stored in the data buffers of the Controller.</li></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_READ_LOCAL_SUPPORTED_FEATURES_anchor">HCI_LE_READ_LOCAL_SUPPORTED_FEATURES</a></h2><h3>Description</h3><p>This command requests the list of the supported LE features for the Controller.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.3].</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>LE_Features</p>
</td><td><p>8</p>
</td><td><p>Bit Mask List of LE features. See Bluetooth Core specification.</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_SET_RANDOM_ADDRESS_anchor">HCI_LE_SET_RANDOM_ADDRESS</a></h2><h3>Description</h3><p>The LE_Set_Random_Address command is used by the Host to set the LE Random Device Address in the Controller (see [Vol 6] Part B, Section 1.3).<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.4].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Random_Address</p>
</td><td><p>6</p>
</td><td><p>Random Device Address.</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_SET_ADVERTISING_PARAMETERS_anchor">HCI_LE_SET_ADVERTISING_PARAMETERS</a></h2><h3>Description</h3><p>The LE_Set_Advertising_Parameters command is used by the Host to set the advertising parameters.<br>The Advertising_Interval_Min shall be less than or equal to the Advertising_Interval_Max.<br>The Advertising_Interval_Min and Advertising_Interval_Max should not be the same value to enable the Controller to determine the best advertising interval given other activities.<br>For high duty cycle directed advertising, i.e. when Advertising_Type is 0x01 (ADV_DIRECT_IND, high duty cycle), the Advertising_Interval_Min and Advertising_Interval_Max parameters are not used and shall be ignored.<br>The Advertising_Type is used to determine the packet type that is used for advertising when advertising is enabled.<br>The Advertising_Interval_Min and Advertising_Interval_Max shall not be set to less than 0x00A0 (100 ms) if the Advertising_Type is set to 0x02 (ADV_SCAN_IND) or 0x03 (ADV_NONCONN_IND). The Own_Address_Type determines if the advertising packets are identified with the Public Device Address of the device, or a Random Device Address as written by the LE_Set_Random_Address command.<br>If directed advertising is performed, i.e. when Advertising_Type is set to 0x01 (ADV_DIRECT_IND, high duty cycle) or 0x04 (ADV_DIRECT_IND, low duty cycle mode), then the Direct_Address_Type and Direct_Address shall be valid, otherwise they shall be ignored by the Controller and not used.<br>The Advertising_Channel_Map is a bit field that indicates the advertising channels that shall be used when transmitting advertising packets. At least one channel bit shall be set in the Advertising_Channel_Map parameter.<br>The Advertising_Filter_Policy parameter shall be ignored when directed advertising is enabled.<br>The Host shall not issue this command when advertising is enabled in the Controller; if it is the Command Disallowed error code shall be used.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.5].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Advertising_Interval_Min</p>
</td><td><p>2</p>
</td><td><p>Minimum advertising interval.
Time = N * 0.625 ms.</p>
</td><td><li>0x0020 (20.000 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>Advertising_Interval_Max</p>
</td><td><p>2</p>
</td><td><p>Maximum advertising interval.
Time = N * 0.625 ms.</p>
</td><td><li>0x0020 (20.000 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>Advertising_Type</p>
</td><td><p>1</p>
</td><td><p>Advertising type.</p>
</td><td><li>0x00: ADV_IND (Connectable undirected advertising)</li><li>0x01: ADV_DIRECT_IND, high duty cycle (Connectable high duty cycle directed advertising)</li><li>0x02: ADV_SCAN_IND (Scannable undirected advertising)</li><li>0x03: ADV_NONCONN_IND (Non connectable undirected advertising)</li><li>0x04: ADV_DIRECT_IND_LDC, low duty cycle (Connectable low duty cycle directed advertising)</li></td></tr>
<tr><td><p>Own_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Own address type.</p>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li><li>0x02: Resolvable Private Address if available, otherwise Public Address</li><li>0x03: Resolvable Private Address if available, otherwise Random Address</li></td></tr>
<tr><td><p>Peer_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Address type of the peer device.</p>
</td><td><li>0x00: Public Device Address or Public Identity Address</li><li>0x01: Random Device Address or Random (static) Identity Address</li></td></tr>
<tr><td><p>Peer_Address</p>
</td><td><p>6</p>
</td><td><p>Public Device Address, Random Device Address, Public Identity Address, or Random (static) Identity Address of the device to be connected.</p>
</td><td></tr>
<tr><td><p>Advertising_Channel_Map</p>
</td><td><p>1</p>
</td><td><p>Advertising channel map.</p>
</td><td><p>Bitmask of:</p><li>0x01: Channel 37 shall be used</li><li>0x02: Channel 38 shall be used</li><li>0x04: Channel 39 shall be used</li></td></tr>
<tr><td><p>Advertising_Filter_Policy</p>
</td><td><p>1</p>
</td><td><p>Advertising filter policy.</p>
</td><td><li>0x00: Allow Scan Request from Any, Allow Connect Request from Any</li><li>0x01: Allow Scan Request from Filter Accept List Only, Allow Connect Request from Any</li><li>0x02: Allow Scan Request from Any, Allow Connect Request from Filter Accept List Only</li><li>0x03: Allow Scan Request from Filter Accept List Only, Allow Connect Request from Filter Accept List Only</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_READ_ADVERTISING_PHYSICAL_CHANNEL_TX_POWER_anchor">HCI_LE_READ_ADVERTISING_PHYSICAL_CHANNEL_TX_POWER</a></h2><h3>Description</h3><p>The LE_Read_Advertising_Physical_Channel_Tx_Power command is used by the Host to read the transmit power level used for LE advertising physical channel packets.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.6].</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Transmit_Power_Level</p>
</td><td><p>1</p>
</td><td><p>Size: 1 Octet (signed integer)
Units: dBm
Accuracy: +/- 4 dBm</p>
</td><td><li>-20 ... 10</li></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_SET_ADVERTISING_DATA_anchor">HCI_LE_SET_ADVERTISING_DATA</a></h2><h3>Description</h3><p>The LE_Set_Advertising_Data command is used to set the data used in advertising packets that have a data field.<br>Only the significant part of the Advertising_Data is transmitted in the advertising packets, as defined in [Vol 3] Part C, Section 11.,<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.7].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Advertising_Data_Length</p>
</td><td><p>1</p>
</td><td><p>The number of significant octets in the following data field</p>
</td><td></tr>
<tr><td><p>Advertising_Data</p>
</td><td><p>31</p>
</td><td><p>31 octets of data formatted as defined in [Vol 3] Part C, Section 11.</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_SET_SCAN_RESPONSE_DATA_anchor">HCI_LE_SET_SCAN_RESPONSE_DATA</a></h2><h3>Description</h3><p>This command is used to provide data used in Scanning Packets that have a data field.<br>Only the significant part of the Scan_Response_Data is transmitted in the Scanning Packets, as defined in [Vol 3] Part C, Section 11.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.8].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Scan_Response_Data_Length</p>
</td><td><p>1</p>
</td><td><p>The number of significant octets in the following data field</p>
</td><td></tr>
<tr><td><p>Scan_Response_Data</p>
</td><td><p>31</p>
</td><td><p>31 octets of data formatted as defined in [Vol 3] Part C, Section 11.</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_SET_ADVERTISING_ENABLE_anchor">HCI_LE_SET_ADVERTISING_ENABLE</a></h2><h3>Description</h3><p>The LE_Set_Advertising_Enable command is used to request the Controller to start or stop advertising. The Controller manages the timing of advertisements as per the advertising parameters given in the LE_Set_Advertising_Parameters command.<br>The Controller shall continue advertising until the Host issues an LE_Set_Advertising_Enable command with Advertising_Enable set to 0x00 (Advertising is disabled) or until a connection is created or until the Advertising is timed out due to high duty cycle Directed Advertising. In these cases, advertising is then disabled.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.9].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Advertising_Enable</p>
</td><td><p>1</p>
</td><td><p>Enable/disable advertising.</p>
</td><td><li>0x00: Advertising is disabled</li><li>0x01: Advertising is enabled</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><li><a href="#HCI_LE_CONNECTION_COMPLETE_EVENT_anchor">HCI_LE_CONNECTION_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_SET_SCAN_PARAMETERS_anchor">HCI_LE_SET_SCAN_PARAMETERS</a></h2><h3>Description</h3><p>The LE_Set_Scan_Parameters command is used to set the scan parameters.<br>The LE_Scan_Type parameter controls the type of scan to perform.<br>The LE_Scan_Interval and LE_Scan_Window parameters are recommendations from the Host on how long (LE_Scan_Window) and how frequently (LE_Scan_Interval) the Controller should scan (See [Vol 6] Part B, Section 4.4.3). The LE_Scan_Window parameter shall always be set to a value smaller or equal to the value set for the LE_Scan_Interval parameter. If they are set to the same value scanning should be run continuously.<br>The Own_Address_Type parameter determines the address used (Public or Random Device Address) when performing active scan.<br>The Host shall not issue this command when scanning is enabled in the Controller; if it is the Command Disallowed error code shall be used.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.10].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>LE_Scan_Type</p>
</td><td><p>1</p>
</td><td><p>Passive or active scanning. With passive scanning, no scan request PDUs are sent.</p>
</td><td><li>0x00: Passive scanning</li><li>0x01: Active scanning</li></td></tr>
<tr><td><p>LE_Scan_Interval</p>
</td><td><p>2</p>
</td><td><p>This is defined as the time interval from when the Controller started its last LE scan until it begins the subsequent LE scan.
Time = N * 0.625 ms.</p>
</td><td><li>0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>LE_Scan_Window</p>
</td><td><p>2</p>
</td><td><p>Amount of time for the duration of the LE scan. LE_Scan_Window shall be less than or equal to LE_Scan_Interval.
Time = N * 0.625 ms.</p>
</td><td><li>0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>Own_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Own address type.</p>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li><li>0x02: Resolvable Private Address if available, otherwise Public Address</li><li>0x03: Resolvable Private Address if available, otherwise Random Address</li></td></tr>
<tr><td><p>Scanning_Filter_Policy</p>
</td><td><p>1</p>
</td><td><p>The scanning filter policy determines how the scanner's Link Layer processes advertising and scan response PDUs.
There is a choice of two primary filter policies: unfiltered and filtered.
Unfiltered: the Link Layer processes all advertising and scan response PDUs (i.e., the Filter Accept List is not used).
Filtered: the Link Layer processes advertising and scan response PDUs only from devices in the Filter Accept List.
With extended scanning filter policies, a directed advertising PDU accepted by the primary filter policy shall nevertheless be ignored unless either the TargetA field is identical to the scanner's device address, or TargetA field is a resolvable private address.</p>
</td><td><li>0x00: Basic unfiltered scanning filter policy</li><li>0x01: Basic filtered scanning filter policy</li><li>0x02: Extended unfiltered scanning filter policy</li><li>0x03: Extended filtered scanning filter policy</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_SET_SCAN_ENABLE_anchor">HCI_LE_SET_SCAN_ENABLE</a></h2><h3>Description</h3><p>The LE_Set_Scan_Enable command is used to start scanning. Scanning is used to discover advertising devices nearby.<br>The Filter_Duplicates parameter controls whether the Link Layer shall filter duplicate advertising reports to the Host, or if the Link Layer should generate advertising reports for each packet received.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.11].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>LE_Scan_Enable</p>
</td><td><p>1</p>
</td><td><p>Enable/disable scan.</p>
</td><td><li>0x00: Scanning disabled</li><li>0x01: Scanning enabled</li></td></tr>
<tr><td><p>Filter_Duplicates</p>
</td><td><p>1</p>
</td><td><p>Enable/disable duplicate filtering.</p>
</td><td><li>0x00: Duplicate filtering disabled</li><li>0x01: Duplicate filtering enabled</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><li><a href="#HCI_LE_ADVERTISING_REPORT_EVENT_anchor">HCI_LE_ADVERTISING_REPORT_EVENT</a></li><h2><a name="HCI_LE_CREATE_CONNECTION_anchor">HCI_LE_CREATE_CONNECTION</a></h2><h3>Description</h3><p>The LE_Create_Connection command is used to create a Link Layer connection to a connectable advertiser.<br>The LE_Scan_Interval and LE_Scan_Window parameters are recommendations from the Host on how long (LE_Scan_Window) and how frequently (LE_Scan_Interval) the Controller should scan. The LE_Scan_Window parameter shall be set to a value smaller or equal to the value set for the LE_Scan_Interval parameter. If both are set to the same value, scanning should run continuously.<br>The Initiator_Filter_Policy is used to determine whether the Filter Accept List is used. If the Filter Accept List is not used, the Peer_Address_Type and the Peer_Address parameters specify the address type and address of the advertising device to connect to.<br>The Link Layer shall set the address in the CONNECT_REQ packets to either the Public Device Address or the Random Device Addressed based on the Own_Address_Type parameter.<br>The Conn_Interval_Min and Conn_Interval_Max parameters define the minimum and maximum allowed connection interval. The Conn_Interval_Min parameter shall not be greater than the Conn_Interval_Max parameter.<br>The Conn_Latency parameter defines the maximum allowed connection latency.<br>The Supervision_Timeout parameter defines the link supervision timeout for the connection. The Supervision_Timeout in milliseconds shall be larger than (1 + Conn_Latency) * Conn_Interval_Max * 2, where Conn_Interval_Max is given in milliseconds.<br>The Minimum_CE_Length and Maximum_CE_Length parameters are informative parameters providing the Controller with the expected minimum and maximum length of the connection events. The Minimum_CE_Length parameter shall be less than or equal to the Maximum_CE_Length parameter.<br>The Host shall not issue this command when another LE_Create_Connection is pending in the Controller; if this does occur the Controller shall return the Command Disallowed error code shall be used.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.12].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>LE_Scan_Interval</p>
</td><td><p>2</p>
</td><td><p>This is defined as the time interval from when the Controller started its last LE scan until it begins the subsequent LE scan.
Time = N * 0.625 ms.</p>
</td><td><li>0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>LE_Scan_Window</p>
</td><td><p>2</p>
</td><td><p>Amount of time for the duration of the LE scan. LE_Scan_Window shall be less than or equal to LE_Scan_Interval.
Time = N * 0.625 ms.</p>
</td><td><li>0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>Initiator_Filter_Policy</p>
</td><td><p>1</p>
</td><td><p>Initiator filter policy.</p>
</td><td><li>0x00: Filter Accept List is not used to determine which advertiser to connect to</li><li>0x01: Filter Accept List is used to determine which advertiser to connect to (Peer_Address_Type and Peer_Address are ignored)</li></td></tr>
<tr><td><p>Peer_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Address type
0x00 Public Device Address
0x01 Random Device Address
0x02 Public Identity Address (Corresponds to Resolved Private Address)
0x03 Random (Static) Identity Address (Corresponds to Resolved Private Address)</p>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li><li>0x02: Public Identity Address</li><li>0x03: Random (Static) Identity Address</li></td></tr>
<tr><td><p>Peer_Address</p>
</td><td><p>6</p>
</td><td><p>Public Device Address or Random Device Address of the device to be connected.</p>
</td><td></tr>
<tr><td><p>Own_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Own address type.</p>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li><li>0x02: Resolvable Private Address if available, otherwise Public Address</li><li>0x03: Resolvable Private Address if available, otherwise Random Address</li></td></tr>
<tr><td><p>Conn_Interval_Min</p>
</td><td><p>2</p>
</td><td><p>Minimum value for the connection event interval.
Time = N * 1.25 ms.</p>
</td><td><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Conn_Interval_Max</p>
</td><td><p>2</p>
</td><td><p>Maximum value for the connection event interval.
Time = N * 1.25 ms.</p>
</td><td><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Conn_Latency</p>
</td><td><p>2</p>
</td><td><p>Maximum Peripheral latency for the connection in number of connection events.</p>
</td><td><li>0x0000 ... 0x01F3</li></td></tr>
<tr><td><p>Supervision_Timeout</p>
</td><td><p>2</p>
</td><td><p>Supervision timeout for the LE Link.
It shall be a multiple of 10 ms and larger than (1 + connPeripheralLatency) * connInterval * 2.
Time = N * 10 ms.</p>
</td><td><li>0x000A (100 ms)  ... 0x0C80 (32000 ms) </li></td></tr>
<tr><td><p>Minimum_CE_Length</p>
</td><td><p>2</p>
</td><td><p>Information parameter about the minimum length of connection needed for this LE connection.
Time = N * 0.625 ms.</p>
</td><td><li>0x0000 (0.000 ms)  ... 0xFFFF (40959.375 ms) </li></td></tr>
<tr><td><p>Maximum_CE_Length</p>
</td><td><p>2</p>
</td><td><p>Information parameter about the maximum length of connection needed for this LE connection.
Time = N * 0.625 ms.</p>
</td><td><li>0x0000 (0.000 ms)  ... 0xFFFF (40959.375 ms) </li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#HCI_LE_CONNECTION_COMPLETE_EVENT_anchor">HCI_LE_CONNECTION_COMPLETE_EVENT</a></li><li><a href="#HCI_LE_ENHANCED_CONNECTION_COMPLETE_EVENT_anchor">HCI_LE_ENHANCED_CONNECTION_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_CREATE_CONNECTION_CANCEL_anchor">HCI_LE_CREATE_CONNECTION_CANCEL</a></h2><h3>Description</h3><p>The LE_Create_Connection_Cancel command is used to cancel the LE_Create_Connection command. This command shall only be issued after the LE_Create_Connection command has been issued, a Command Status event has been received for the LE Create Connection command and before the LE Connection Complete event.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.13].</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><li><a href="#HCI_LE_CONNECTION_COMPLETE_EVENT_anchor">HCI_LE_CONNECTION_COMPLETE_EVENT</a></li><li><a href="#HCI_LE_ENHANCED_CONNECTION_COMPLETE_EVENT_anchor">HCI_LE_ENHANCED_CONNECTION_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_READ_FILTER_ACCEPT_LIST_SIZE_anchor">HCI_LE_READ_FILTER_ACCEPT_LIST_SIZE</a></h2><h3>Description</h3><p>This command is used to read the total number of Filter Accept List entries that can be stored in the Controller.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.14].</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Filter_Accept_List_Size</p>
</td><td><p>1</p>
</td><td><p>Total number of Filter Accept List entries that can be stored in the Controller.</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_CLEAR_FILTER_ACCEPT_LIST_anchor">HCI_LE_CLEAR_FILTER_ACCEPT_LIST</a></h2><h3>Description</h3><p>This command is used to clear the Filter Accept List stored in the Controller.<br>This command can be used at any time except when:<br>- the advertising filter policy uses the Filter Accept List and advertising is enabled.<br>- the scanning filter policy uses the Filter Accept List and scanning is enabled.<br>- the initiator filter policy uses the Filter Accept List and an HCI_LE_Create_Connection or HCI_LE_Extended_Create_Connection command is pending.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.15].</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_ADD_DEVICE_TO_FILTER_ACCEPT_LIST_anchor">HCI_LE_ADD_DEVICE_TO_FILTER_ACCEPT_LIST</a></h2><h3>Description</h3><p>This command is used to add a single device to the Filter Accept List stored in the Controller.<br>This command can be used at any time except when:<br>- the advertising filter policy uses the Filter Accept List and advertising is enabled.<br>- the scanning filter policy uses the Filter Accept List and scanning is enabled.<br>- the initiator filter policy uses the Filter Accept List and an HCI_LE_Create_Connection or HCI_LE_Extended_Create_Connection command is pending.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.16].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Address_Type</p>
</td><td><p>1</p>
</td><td><p>Address type.</p>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li></td></tr>
<tr><td><p>Address</p>
</td><td><p>6</p>
</td><td><p>Public Device Address or Random Device Address.</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_REMOVE_DEVICE_FROM_FILTER_ACCEPT_LIST_anchor">HCI_LE_REMOVE_DEVICE_FROM_FILTER_ACCEPT_LIST</a></h2><h3>Description</h3><p>This command is used to remove a single device from the Filter Accept List stored in the Controller.<br>This command can be used at any time except when:<br>- the advertising filter policy uses the Filter Accept List and advertising is enabled.<br>- the scanning filter policy uses the Filter Accept List and scanning is enabled.<br>- the initiator filter policy uses the Filter Accept List and an HCI_LE_Create_Connection or HCI_LE_Extended_Create_Connection command is pending.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.17].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Address_Type</p>
</td><td><p>1</p>
</td><td><p>Address type.</p>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li></td></tr>
<tr><td><p>Address</p>
</td><td><p>6</p>
</td><td><p>Public Device Address or Random Device Address.</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_CONNECTION_UPDATE_anchor">HCI_LE_CONNECTION_UPDATE</a></h2><h3>Description</h3><p>The LE_Connection_Update command is used to change the Link Layer connection parameters of a connection. This command is supported only on Central side.<br>The Conn_Interval_Min and Conn_Interval_Max parameters are used to define the minimum and maximum allowed connection interval. The Conn_Interval_Min parameter shall not be greater than the Conn_Interval_Max parameter.<br>The Conn_Latency parameter shall define the maximum allowed connection latency.<br>The Supervision_Timeout parameter shall define the link supervision timeout for the LE link. The Supervision_Timeout in milliseconds shall be larger than (1 + Conn_Latency) * Conn_Interval_Max * 2, where Conn_Interval_Max is given in milliseconds.<br>The Minimum_CE_Length and Maximum_CE_Length are information parameters providing the Controller with a hint about the expected minimum and maximum length of the connection events. The Minimum_CE_Length shall be less than or equal to the Maximum_CE_Length.<br>The actual parameter values selected by the Link Layer may be different from the parameter values provided by the Host through this command.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.18].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Conn_Interval_Min</p>
</td><td><p>2</p>
</td><td><p>Minimum value for the connection event interval.
Time = N * 1.25 ms.</p>
</td><td><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Conn_Interval_Max</p>
</td><td><p>2</p>
</td><td><p>Maximum value for the connection event interval.
Time = N * 1.25 ms.</p>
</td><td><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Conn_Latency</p>
</td><td><p>2</p>
</td><td><p>Maximum Peripheral latency for the connection in number of connection events.</p>
</td><td><li>0x0000 ... 0x01F3</li></td></tr>
<tr><td><p>Supervision_Timeout</p>
</td><td><p>2</p>
</td><td><p>Supervision timeout for the LE Link.
It shall be a multiple of 10 ms and larger than (1 + connPeripheralLatency) * connInterval * 2.
Time = N * 10 ms.</p>
</td><td><li>0x000A (100 ms)  ... 0x0C80 (32000 ms) </li></td></tr>
<tr><td><p>Minimum_CE_Length</p>
</td><td><p>2</p>
</td><td><p>Information parameter about the minimum length of connection needed for this LE connection.
Time = N * 0.625 ms.</p>
</td><td><li>0x0000 (0.000 ms)  ... 0xFFFF (40959.375 ms) </li></td></tr>
<tr><td><p>Maximum_CE_Length</p>
</td><td><p>2</p>
</td><td><p>Information parameter about the maximum length of connection needed for this LE connection.
Time = N * 0.625 ms.</p>
</td><td><li>0x0000 (0.000 ms)  ... 0xFFFF (40959.375 ms) </li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#HCI_LE_CONNECTION_UPDATE_COMPLETE_EVENT_anchor">HCI_LE_CONNECTION_UPDATE_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_SET_HOST_CHANNEL_CLASSIFICATION_anchor">HCI_LE_SET_HOST_CHANNEL_CLASSIFICATION</a></h2><h3>Description</h3><p>The LE_Set_Host_Channel_Classification command allows the Host to specify a channel classification for data channels based on its "local information". This classification persists until overwritten with a subsequent LE_Set_Host_Channel_Classification command or until the Controller is reset using the Reset command (see [Vol 6] Part B, Section 4.5.8.1).<br>If this command is used, the Host should send it within 10 seconds of knowing that the channel classification has changed. The interval between two successive commands sent shall be at least one second.<br>This command shall only be used when the local device supports the Central role.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.19].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>LE_Channel_Map</p>
</td><td><p>5</p>
</td><td><p>This parameter contains 37 1-bit fields.
The nth such field (in the range 0 to 36) contains the value for the link layer channel index n.
Channel n is bad = 0.
Channel n is unknown = 1.
The most significant bits are reserved and shall be set to 0.
At least one channel shall be marked as unknown.</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_READ_CHANNEL_MAP_anchor">HCI_LE_READ_CHANNEL_MAP</a></h2><h3>Description</h3><p>The LE_Read_Channel_Map command returns the current Channel_Map for the specified Connection_Handle. The returned value indicates the state of the Channel_Map specified by the last transmitted or received Channel_Map (in a CONNECT_REQ or LL_CHANNEL_MAP_REQ message) for the specified Connection_Handle, regardless of whether the Central has received an acknowledgment.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.20].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>LE_Channel_Map</p>
</td><td><p>5</p>
</td><td><p>This parameter contains 37 1-bit fields.
The nth such field (in the range 0 to 36) contains the value for the
link layer channel index n.
Channel n is unused = 0.
Channel n is used = 1.
The most significant bits are reserved and shall be set to 0.</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_READ_REMOTE_FEATURES_anchor">HCI_LE_READ_REMOTE_FEATURES</a></h2><h3>Description</h3><p>This command requests a list of the used LE features from the remote device.<br>This command shall return a list of the used LE features. For details see [Vol 6] Part B, Section 4.6.<br>This command may be issued on both the Central and Peripheral.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.21].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#HCI_LE_READ_REMOTE_FEATURES_COMPLETE_EVENT_anchor">HCI_LE_READ_REMOTE_FEATURES_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_ENCRYPT_anchor">HCI_LE_ENCRYPT</a></h2><h3>Description</h3><p>The LE_Encrypt command is used to request the Controller to encrypt the Plaintext_Data in the command using the Key given in the command and returns the Encrypted_Data to the Host. The AES-128 bit block cypher is defined in NIST Publication FIPS-197 (http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf).<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.22].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Key</p>
</td><td><p>16</p>
</td><td><p>128 bit key for the encryption of the data given in the command.</p>
</td><td></tr>
<tr><td><p>Plaintext_Data</p>
</td><td><p>16</p>
</td><td><p>128 bit data block that is requested to be encrypted.</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Encrypted_Data</p>
</td><td><p>16</p>
</td><td><p>128 bit encrypted data block.</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_RAND_anchor">HCI_LE_RAND</a></h2><h3>Description</h3><p>The LE_Rand command is used to request the Controller to generate 8 octets of random data to be sent to the Host. The Random_Number shall be generated according to [Vol 2] Part H, Section 2 if the LE Feature (LL Encryption) is supported.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.23].</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Random_Number</p>
</td><td><p>8</p>
</td><td><p>Random Number</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_ENABLE_ENCRYPTION_anchor">HCI_LE_ENABLE_ENCRYPTION</a></h2><h3>Description</h3><p>The LE_Enable_Encryption command is used to authenticate the given encryption key associated with the remote device specified by the connection handle, and once authenticated will encrypt the connection. The parameters are as defined in [Vol 3] Part H, Section 2.4.4.<br>If the connection is already encrypted then the Controller shall pause connection encryption before attempting to authenticate the given encryption key, and then re-encrypt the connection. While encryption is paused no user data shall be transmitted.<br>On an authentication failure, the connection shall be automatically disconnected by the Link Layer. If this command succeeds, then the connection shall be encrypted.<br>This command shall only be used when the local device's role is Central.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.24].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Random_Number</p>
</td><td><p>8</p>
</td><td><p>64 bit random number.</p>
</td><td></tr>
<tr><td><p>Encrypted_Diversifier</p>
</td><td><p>2</p>
</td><td><p>16 bit encrypted diversifier.</p>
</td><td></tr>
<tr><td><p>Long_Term_Key</p>
</td><td><p>16</p>
</td><td><p>128 bit long term key.</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#HCI_ENCRYPTION_CHANGE_EVENT_anchor">HCI_ENCRYPTION_CHANGE_EVENT</a></li><li><a href="#HCI_ENCRYPTION_KEY_REFRESH_COMPLETE_EVENT_anchor">HCI_ENCRYPTION_KEY_REFRESH_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_LONG_TERM_KEY_REQUEST_REPLY_anchor">HCI_LE_LONG_TERM_KEY_REQUEST_REPLY</a></h2><h3>Description</h3><p>The LE_Long_Term_Key_Request_Reply command is used to reply to an LE Long Term Key Request event from the Controller, and specifies the Long_Term_Key parameter that shall be used for this Connection_Handle. The Long_Term_Key is used as defined in [Vol 6] Part B, Section 5.1.3.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.25].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Long_Term_Key</p>
</td><td><p>16</p>
</td><td><p>128 bit long term key.</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_LONG_TERM_KEY_REQUEST_NEGATIVE_REPLY_anchor">HCI_LE_LONG_TERM_KEY_REQUEST_NEGATIVE_REPLY</a></h2><h3>Description</h3><p>The LE_Long_Term_Key_Request_Negative_Reply command is used to reply to an LE Long Term Key Request event from the Controller if the Host cannot provide a Long Term Key for this Connection_Handle.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.26].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_READ_SUPPORTED_STATES_anchor">HCI_LE_READ_SUPPORTED_STATES</a></h2><h3>Description</h3><p>The LE_Read_Supported_States command reads the states and state combinations that the link layer supports. See [Vol 6] Part B, Section 1.1.1.<br>LE_States is an 8-octet bit field. If a bit is set to 1 then this state or state combination is supported by the Controller. Multiple bits in LE_States may be set to 1 to indicate support for multiple state and state combinations.<br>All the Advertising type with the Initiate State combinations shall be set only if the corresponding Advertising types and Central role combination are set.<br>All the Scanning types and the Initiate State combinations shall be set only if the corresponding Scanning types and Central role combination are set.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.27].</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>LE_States</p>
</td><td><p>8</p>
</td><td><p>State or state combination is supported by the Controller.</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_SET_DATA_LENGTH_anchor">HCI_LE_SET_DATA_LENGTH</a></h2><h3>Description</h3><p>The LE_Set_Data_Length command allows the Host to suggest maximum transmission packet size and maximum packet transmission time (connMaxTxOctets and connMaxTxTime - see Bluetooth spec. Vol 6 [Part B] 4.5.10) to be used for a given connection. The Controller may use smaller or larger values based on local information.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.33].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>TxOctets</p>
</td><td><p>2</p>
</td><td><p>Preferred maximum number of payload octets that the local Controller should include in a single Link Layer packet on this connection.</p>
</td><td><li>0x001B ... 0x00FB</li></td></tr>
<tr><td><p>TxTime</p>
</td><td><p>2</p>
</td><td><p>Preferred maximum number of microseconds that the local Controller should use to transmit a single Link Layer packet on this connection.</p>
</td><td><li>0x0148 ... 0x4290</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_READ_SUGGESTED_DEFAULT_DATA_LENGTH_anchor">HCI_LE_READ_SUGGESTED_DEFAULT_DATA_LENGTH</a></h2><h3>Description</h3><p>This command allows the Host to read the Host's suggested values (SuggestedMaxTxOctets and SuggestedMaxTxTime) for the Controller's maximum transmitted number of payload octets and maximum packet transmission time to be used for new connections.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.34].</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>SuggestedMaxTxOctets</p>
</td><td><p>2</p>
</td><td><p>The Host's suggested value for the Controller's maximum transmitted number of payload octets to be used for new connections.</p>
</td><td><li>0x001B ... 0x00FB</li></td></tr>
<tr><td><p>SuggestedMaxTxTime</p>
</td><td><p>2</p>
</td><td><p>The Host's suggested value for the Controller's maximum packet transmission time to be used for new connections.</p>
</td><td><li>0x0148 ... 0x4290</li></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_WRITE_SUGGESTED_DEFAULT_DATA_LENGTH_anchor">HCI_LE_WRITE_SUGGESTED_DEFAULT_DATA_LENGTH</a></h2><h3>Description</h3><p>This command allows the Host to specify its suggested values for the Controller's maximum transmission number of payload octets and maximum packet transmission time to be used for new connections. The Controller may use smaller or larger values for connInitialMaxTxOctets and connInitialMaxTxTime based on local information.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.35].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>SuggestedMaxTxOctets</p>
</td><td><p>2</p>
</td><td><p>The Host's suggested value for the Controller's maximum transmitted number of payload octets to be used for new connections.</p>
</td><td><li>0x001B ... 0x00FB</li></td></tr>
<tr><td><p>SuggestedMaxTxTime</p>
</td><td><p>2</p>
</td><td><p>The Host's suggested value for the Controller's maximum packet transmission time to be used for new connections.</p>
</td><td><li>0x0148 ... 0x4290</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_READ_LOCAL_P256_PUBLIC_KEY_anchor">HCI_LE_READ_LOCAL_P256_PUBLIC_KEY</a></h2><h3>Description</h3><p>This command is used to return the local P-256 public key from the Controller. The Controller shall generate a new P-256 public/private key pair upon receipt of this command.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.36].</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#HCI_LE_READ_LOCAL_P256_PUBLIC_KEY_COMPLETE_EVENT_anchor">HCI_LE_READ_LOCAL_P256_PUBLIC_KEY_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_GENERATE_DHKEY_anchor">HCI_LE_GENERATE_DHKEY</a></h2><h3>Description</h3><p>This command is used to initiate generation of a Diffie-Hellman key in the Controller for use over the LE transport. This command takes the remote P-256 public key as input. The Diffie-Hellman key generation uses the private key generated by LE_Read_Local_P256_Public_Key command.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.37].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Remote_P256_Public_Key</p>
</td><td><p>64</p>
</td><td><p>The remote P-256 public key in X, Y format:
Octets 31-0: X coordinate
Octets 63-32: Y coordinate
Little Endian Format</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#HCI_LE_GENERATE_DHKEY_COMPLETE_EVENT_anchor">HCI_LE_GENERATE_DHKEY_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_ADD_DEVICE_TO_RESOLVING_LIST_anchor">HCI_LE_ADD_DEVICE_TO_RESOLVING_LIST</a></h2><h3>Description</h3><p>This command is used to add one device to the list of address translations used to resolve Resolvable Private Addresses in the Controller.<br>This command cannot be used when address translation is enabled in the Controller and:<br>- Advertising is enabled<br>- Scanning is enabled<br>- Create connection command is outstanding<br>This command can be used at any time when address translation is disabled in the Controller.<br>When a Controller cannot add a device to the resolving list because the list is full, it shall respond with error code 0x07 (Memory Capacity Exceeded).<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.38].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Peer_Identity_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Identity address type</p>
</td><td><li>0x00: Public Identity Address</li><li>0x01: Random (static) Identity Address</li></td></tr>
<tr><td><p>Peer_Identity_Address</p>
</td><td><p>6</p>
</td><td><p>Public or Random (static) Identity Address of the peer device</p>
</td><td></tr>
<tr><td><p>Peer_IRK</p>
</td><td><p>16</p>
</td><td><p>IRK of the peer device</p>
</td><td></tr>
<tr><td><p>Local_IRK</p>
</td><td><p>16</p>
</td><td><p>IRK of the local device</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_REMOVE_DEVICE_FROM_RESOLVING_LIST_anchor">HCI_LE_REMOVE_DEVICE_FROM_RESOLVING_LIST</a></h2><h3>Description</h3><p>This command is used to remove one device from the list of address translations used to resolve Resolvable Private Addresses in the controller.<br>This command cannot be used when address translation is enabled in the Controller and:<br>- Advertising is enabled<br>- Scanning is enabled<br>- Create connection command is outstanding<br>This command can be used at any time when address translation is disabled in the Controller.<br>When a Controller cannot remove a device from the resolving list because it is not found, it shall respond with error code 0x02 (Unknown Connection Identifier).<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.39].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Peer_Identity_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Identity address type</p>
</td><td><li>0x00: Public Identity Address</li><li>0x01: Random (static) Identity Address</li></td></tr>
<tr><td><p>Peer_Identity_Address</p>
</td><td><p>6</p>
</td><td><p>Public or Random (static) Identity Address of the peer device</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_CLEAR_RESOLVING_LIST_anchor">HCI_LE_CLEAR_RESOLVING_LIST</a></h2><h3>Description</h3><p>This command is used to remove all devices from the list of address translations used to resolve Resolvable Private Addresses in the Controller.<br>This command cannot be used when address translation is enabled in the Controller and:<br>- Advertising is enabled<br>- Scanning is enabled<br>- Create connection command is outstanding<br>This command can be used at any time when address translation is disabled in the Controller.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.40].</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_READ_RESOLVING_LIST_SIZE_anchor">HCI_LE_READ_RESOLVING_LIST_SIZE</a></h2><h3>Description</h3><p>This command is used to read the total number of address translation entries in the resolving list that can be stored in the Controller.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.41].</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Resolving_List_Size</p>
</td><td><p>1</p>
</td><td><p>Number of address translation entries in the resolving list</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_READ_PEER_RESOLVABLE_ADDRESS_anchor">HCI_LE_READ_PEER_RESOLVABLE_ADDRESS</a></h2><h3>Description</h3><p>This command is used to get the current peer Resolvable Private Address being used for the corresponding peer Public and Random (static) Identity Address. The peer's resolvable address being used may change after the command is called.<br>This command can be used at any time.<br>When a Controller cannot find a Resolvable Private Address associated with the Peer Identity Address, it shall respond with error code 0x02 (Unknown Connection Identifier).<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.42].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Peer_Identity_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Identity address type</p>
</td><td><li>0x00: Public Identity Address</li><li>0x01: Random (static) Identity Address</li></td></tr>
<tr><td><p>Peer_Identity_Address</p>
</td><td><p>6</p>
</td><td><p>Public or Random (static) Identity Address of the peer device</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Peer_Resolvable_Address</p>
</td><td><p>6</p>
</td><td><p>Resolvable Private Address being used by the peer device</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_READ_LOCAL_RESOLVABLE_ADDRESS_anchor">HCI_LE_READ_LOCAL_RESOLVABLE_ADDRESS</a></h2><h3>Description</h3><p>This command is used to get the current local Resolvable Private Address being used for the corresponding peer Identity Address. The local's resolvable address being used may change after the command is called.<br>This command can be used at any time.<br>When a Controller cannot find a Resolvable Private Address associated with the Peer Identity Address, it shall respond with error code 0x02 (Unknown Connection Identifier).<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.43].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Peer_Identity_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Identity address type</p>
</td><td><li>0x00: Public Identity Address</li><li>0x01: Random (static) Identity Address</li></td></tr>
<tr><td><p>Peer_Identity_Address</p>
</td><td><p>6</p>
</td><td><p>Public or Random (static) Identity Address of the peer device</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Local_Resolvable_Address</p>
</td><td><p>6</p>
</td><td><p>Resolvable Private Address being used by the local device</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_SET_ADDRESS_RESOLUTION_ENABLE_anchor">HCI_LE_SET_ADDRESS_RESOLUTION_ENABLE</a></h2><h3>Description</h3><p>This command is used to enable resolution of Resolvable Private Addresses in the Controller. This causes the Controller to use the resolving list whenever the Controller receives a local or peer Resolvable Private Address.<br>This command can be used at any time except when:<br>- Advertising is enabled<br>- Scanning is enabled<br>- Create connection command is outstanding<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.44].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Address_Resolution_Enable</p>
</td><td><p>1</p>
</td><td><p>Enable/disable address resolution in the controller.
0x00: Address Resolution in controller disabled (default),
0x01: Address Resolution in controller enabled</p>
</td><td><li>0x00: Address Resolution in controller disabled (default)</li><li>0x01: Address Resolution in controller enabled</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_SET_RESOLVABLE_PRIVATE_ADDRESS_TIMEOUT_anchor">HCI_LE_SET_RESOLVABLE_PRIVATE_ADDRESS_TIMEOUT</a></h2><h3>Description</h3><p>This command is used to set the length of time the controller uses a Resolvable Private Address before a new resolvable private address is generated and starts being used. This timeout applies to all addresses generated by the controller.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.45].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>RPA_Timeout</p>
</td><td><p>2</p>
</td><td><p>RPA_Timeout measured in seconds.
Range for N: 0x0001 - 0xA1B8 (1 sec - approximately 11.5 hours)
Default: N= 0x0384 (900 secs or 15 minutes)</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_READ_MAXIMUM_DATA_LENGTH_anchor">HCI_LE_READ_MAXIMUM_DATA_LENGTH</a></h2><h3>Description</h3><p>This command allows the Host to read the Controller's maximum supported payload octets and packet duration times for transmission and reception (supportedMaxTxOctets and supportedMaxTxTime, supportedMaxRxOctets, and supportedMaxRxTime.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.46].</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>supportedMaxTxOctets</p>
</td><td><p>2</p>
</td><td><p>Maximum number of payload octets that the local Controller supports for transmission of a single Link Layer packet on a data connection.</p>
</td><td><li>0x001B ... 0x00FB</li></td></tr>
<tr><td><p>supportedMaxTxTime</p>
</td><td><p>2</p>
</td><td><p>Maximum time, in microseconds, that the local Controller supports for transmission of a single Link Layer packet on a data connection.</p>
</td><td><li>0x0148 ... 0x4290</li></td></tr>
<tr><td><p>supportedMaxRxOctets</p>
</td><td><p>2</p>
</td><td><p>Maximum number of payload octets that the local Controller supports for reception of a single Link Layer packet on a data connection.</p>
</td><td><li>0x001B ... 0x00FB</li></td></tr>
<tr><td><p>supportedMaxRxTime</p>
</td><td><p>2</p>
</td><td><p>Maximum time, in microseconds, that the local Controller supports for reception of a single Link Layer packet on a data connection.</p>
</td><td><li>0x0148 ... 0x4290</li></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_READ_PHY_anchor">HCI_LE_READ_PHY</a></h2><h3>Description</h3><p>This command is used to read the current transmitter PHY and receiver PHY on the connection identified by the Connection_Handle.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.47].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>TX_PHY</p>
</td><td><p>1</p>
</td><td><p>Transmitter PHY in use.</p>
</td><td><li>0x01: The transmitter PHY for the connection is LE 1M</li><li>0x02: The transmitter PHY for the connection is LE 2M</li><li>0x03: The transmitter PHY for the connection is LE Coded (not supported on STM32WB)</li></td></tr>
<tr><td><p>RX_PHY</p>
</td><td><p>1</p>
</td><td><p>Receiver PHY in use.</p>
</td><td><li>0x01: The receiver PHY for the connection is LE 1M</li><li>0x02: The receiver PHY for the connection is LE 2M</li><li>0x03: The receiver PHY for the connection is LE Coded (not supported on STM32WB)</li></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_SET_DEFAULT_PHY_anchor">HCI_LE_SET_DEFAULT_PHY</a></h2><h3>Description</h3><p>This command allows the Host to specify its preferred values for the transmitter PHY and receiver PHY to be used for all subsequent connections over the LE transport.<br>The ALL_PHYS parameter is a bit field that allows the Host to specify, for each<br>direction, whether it has no preference among the PHYs that the Controller supports in a given direction or whether it has specified particular PHYs that it prefers in the TX_PHYS or RX_PHYS parameter.<br>The TX_PHYS parameter is a bit field that indicates the transmitter PHYs that the Host prefers the Controller to use. If the ALL_PHYS parameter specifies that the Host has no preference, the TX_PHYS parameter is ignored; otherwise at least one bit shall be set to 1.<br>The RX_PHYS parameter is a bit field that indicates the receiver PHYs that the Host prefers the Controller to use. If the ALL_PHYS parameter specifies that the Host has no preference, the RX_PHYS parameter is ignored; otherwise at least one bit shall be set to 1.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.48].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>ALL_PHYS</p>
</td><td><p>1</p>
</td><td><p>Host preferences for TX PHY and RX PHY</p>
</td><td><li>0x00 ... 0x03</li></td></tr>
<tr><td><p>TX_PHYS</p>
</td><td><p>1</p>
</td><td><p>Host preferences for TX PHY (no LE coded support on STM32WB)</p>
</td><td><li>0x00 ... 0x03</li></td></tr>
<tr><td><p>RX_PHYS</p>
</td><td><p>1</p>
</td><td><p>Host preferences for RX PHY (no LE coded support on STM32WB)</p>
</td><td><li>0x00 ... 0x03</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_SET_PHY_anchor">HCI_LE_SET_PHY</a></h2><h3>Description</h3><p>This command is used to set the PHY preferences for the connection identified by the Connection_Handle. The Controller might not be able to make the change (e.g. because the peer does not support the requested PHY) or may decide that the current PHY is preferable.<br>The ALL_PHYS parameter is a bit field that allows the Host to specify, for each direction, whether it has no preference among the PHYs that the Controller supports in a given direction or whether it has specified particular PHYs that it prefers in the TX_PHYS or RX_PHYS parameter.<br>The TX_PHYS parameter is a bit field that indicates the transmitter PHYs that the Host prefers the Controller to use. If the ALL_PHYS parameter specifies that the Host has no preference, the TX_PHYS parameter is ignored; otherwise at least one bit shall be set to 1.<br>The RX_PHYS parameter is a bit field that indicates the receiver PHYs that the Host prefers the Controller to use. If the ALL_PHYS parameter specifies that the Host has no preference, the RX_PHYS parameter is ignored; otherwise at least one bit shall be set to 1.<br>If, for at least one direction, the Host has specified a preference and the current PHY is not one of those preferred, the Controller shall request a change. Otherwise the Controller may, but need not, request a change.<br>The PHY preferences provided by the LE Set PHY command override those provided via the LE Set Default PHY command (Section 7.8.48) or any preferences previously set using the LE Set PHY command on the same connection.<br>The PHY_options parameter is a bit field that allows the Host to specify options for PHYs. The default value for a new connection shall be all zero bits. The Controller may override any preferred coding for transmitting on the LE Coded PHY.<br>The Host may specify a preferred coding even if it prefers not to use the LE Coded transmitter PHY since the Controller may override the PHY preference.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.49].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>ALL_PHYS</p>
</td><td><p>1</p>
</td><td><p>Host preferences for TX PHY and RX PHY</p>
</td><td><li>0x00 ... 0x03</li></td></tr>
<tr><td><p>TX_PHYS</p>
</td><td><p>1</p>
</td><td><p>Host preferences for TX PHY (no LE coded support on STM32WB)</p>
</td><td><li>0x00 ... 0x03</li></td></tr>
<tr><td><p>RX_PHYS</p>
</td><td><p>1</p>
</td><td><p>Host preferences for RX PHY (no LE coded support on STM32WB)</p>
</td><td><li>0x00 ... 0x03</li></td></tr>
<tr><td><p>PHY_options</p>
</td><td><p>2</p>
</td><td><p>Bit field used to specify options for PHYs (not used on STM32WB)</p>
</td><td><li>0x0000: the Host has no preferred coding when transmitting on the LE Coded PHY</li><li>0x0001: the Host prefers that S=2 coding be used when transmitting on the LE Coded PHY</li><li>0x0002: the Host prefers that S=8 coding be used when transmitting on the LE Coded PHY</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#HCI_LE_PHY_UPDATE_COMPLETE_EVENT_anchor">HCI_LE_PHY_UPDATE_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_SET_ADVERTISING_SET_RANDOM_ADDRESS_anchor">HCI_LE_SET_ADVERTISING_SET_RANDOM_ADDRESS</a></h2><h3>Description</h3><p>This command is used by the Host to set the random device address specified by the Random_Address parameter.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.52].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Advertising_Handle</p>
</td><td><p>1</p>
</td><td><p>Used to identify an advertising set.</p>
</td><td><li>0x00 ... 0xEF</li></td></tr>
<tr><td><p>Random_Address</p>
</td><td><p>6</p>
</td><td><p>Random Device Address.</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_SET_EXTENDED_ADVERTISING_PARAMETERS_anchor">HCI_LE_SET_EXTENDED_ADVERTISING_PARAMETERS</a></h2><h3>Description</h3><p>This command is used by the Host to set the extended advertising parameters.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.53].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Advertising_Handle</p>
</td><td><p>1</p>
</td><td><p>Used to identify an advertising set.</p>
</td><td><li>0x00 ... 0xEF</li></td></tr>
<tr><td><p>Adv_Event_Properties</p>
</td><td><p>2</p>
</td><td><p>Type of advertising event.</p>
</td><td><p>Bitmask of:</p><li>0x0001: Connectable advertising</li><li>0x0002: Scannable advertising</li><li>0x0004: Directed advertising</li><li>0x0008: High Duty Cycle Directed Connectable advertising</li><li>0x0010: Use legacy advertising PDUs</li><li>0x0020: Anonymous advertising</li><li>0x0040: Include TxPower in at least one advertising PDU</li></td></tr>
<tr><td><p>Primary_Adv_Interval_Min</p>
</td><td><p>3</p>
</td><td><p>Minimum advertising interval.
Time = N * 0.625 ms.</p>
</td><td><li>0x000020 (20.000 ms)  ... 0xFFFFFF (10485759.375 ms) </li></td></tr>
<tr><td><p>Primary_Adv_Interval_Max</p>
</td><td><p>3</p>
</td><td><p>Maximum advertising interval.
Time = N * 0.625 ms.</p>
</td><td><li>0x000020 (20.000 ms)  ... 0xFFFFFF (10485759.375 ms) </li></td></tr>
<tr><td><p>Primary_Adv_Channel_Map</p>
</td><td><p>1</p>
</td><td><p>Advertising channel map.</p>
</td><td><p>Bitmask of:</p><li>0x01: Channel 37 shall be used</li><li>0x02: Channel 38 shall be used</li><li>0x04: Channel 39 shall be used</li></td></tr>
<tr><td><p>Own_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Own address type.</p>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li><li>0x02: Resolvable Private Address if available, otherwise Public Address</li><li>0x03: Resolvable Private Address if available, otherwise Random Address</li></td></tr>
<tr><td><p>Peer_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Address type of the peer device.</p>
</td><td><li>0x00: Public Device Address or Public Identity Address</li><li>0x01: Random Device Address or Random (static) Identity Address</li></td></tr>
<tr><td><p>Peer_Address</p>
</td><td><p>6</p>
</td><td><p>Public Device Address, Random Device Address, Public Identity Address, or Random (static) Identity Address of the device to be connected.</p>
</td><td></tr>
<tr><td><p>Adv_Filter_Policy</p>
</td><td><p>1</p>
</td><td><p>Advertising filter policy</p>
</td><td><li>0x00: Process scan and connection requests from all devices (i.e., the Filter Accept List is not in use)</li><li>0x01: Process connection requests from all devices and scan requests only from devices that are in the Filter Accept List.</li><li>0x02: Process scan requests from all devices and connection requests only from devices that are in the Filter Accept List.</li><li>0x03: Process scan and connection requests only from devices in the Filter Accept List.</li></td></tr>
<tr><td><p>Adv_TX_Power</p>
</td><td><p>1</p>
</td><td><p>Advertising TX power. Units: dBm.</p>
</td><td><li>-127 ... 20</li></td></tr>
<tr><td><p>Primary_Adv_PHY</p>
</td><td><p>1</p>
</td><td><p>Primary advertising PHY.</p>
</td><td><li>0x01: Primary advertisement PHY is LE 1M</li><li>0x03: Primary advertisement PHY is LE Coded (not supported on STM32WB)</li></td></tr>
<tr><td><p>Secondary_Adv_Max_Skip</p>
</td><td><p>1</p>
</td><td><p>Secondary advertising maximum skip.</p>
</td><td><li>0x00: AUX_ADV_IND shall be sent prior to the next advertising event</li><li>0x01 ... 0xFF: Maximum advertising events the Controller can skip before sending the AUX_ADV_IND packets on the secondary advertising physical channel</li></td></tr>
<tr><td><p>Secondary_Adv_PHY</p>
</td><td><p>1</p>
</td><td><p>Secondary advertising PHY.</p>
</td><td><li>0x01: Secondary advertisement PHY is LE 1M</li><li>0x02: Secondary advertisement PHY is LE 2M</li><li>0x03: Secondary advertisement PHY is LE Coded (not supported on STM32WB)</li></td></tr>
<tr><td><p>Adv_SID</p>
</td><td><p>1</p>
</td><td><p>Value of the Advertising SID subfield in the ADI field of the PDU.</p>
</td><td><li>0x00 ... 0x0F</li></td></tr>
<tr><td><p>Scan_Req_Notification_Enable</p>
</td><td><p>1</p>
</td><td><p>Scan request notifications.</p>
</td><td><li>0x00: Scan request notifications disabled</li><li>0x01: Scan request notifications enabled</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Selected_TX_Power</p>
</td><td><p>1</p>
</td><td><p>Power level selected by the Controller. Units: dBm.</p>
</td><td><li>-127 ... 20</li></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_SET_EXTENDED_ADVERTISING_DATA_anchor">HCI_LE_SET_EXTENDED_ADVERTISING_DATA</a></h2><h3>Description</h3><p>This command is used to set the data used in extended advertising PDUs that have a data field.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.54].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Advertising_Handle</p>
</td><td><p>1</p>
</td><td><p>Used to identify an advertising set.</p>
</td><td><li>0x00 ... 0xEF</li></td></tr>
<tr><td><p>Operation</p>
</td><td><p>1</p>
</td><td><p>Advertising operation.</p>
</td><td><li>0x00: Intermediate fragment of fragmented extended advertising data</li><li>0x01: First fragment of fragmented extended advertising data</li><li>0x02: Last fragment of fragmented extended advertising data</li><li>0x03: Complete extended advertising data</li><li>0x04: Unchanged data (just update the Advertising DID)</li></td></tr>
<tr><td><p>Fragment_Preference</p>
</td><td><p>1</p>
</td><td><p>Fragment preference.</p>
</td><td><li>0x00: The Controller may fragment all data</li><li>0x01: The Controller should not fragment or should minimize fragmentation of data</li></td></tr>
<tr><td><p>Advertising_Data_Length</p>
</td><td><p>1</p>
</td><td><p>Length of Advertising_Data in octets</p>
</td><td></tr>
<tr><td><p>Advertising_Data</p>
</td><td><p>Advertising_Data_Length</p>
</td><td><p>Data formatted as defined in Bluetooth spec. v.5.4 [Vol 3, Part C, 11].</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_SET_EXTENDED_SCAN_RESPONSE_DATA_anchor">HCI_LE_SET_EXTENDED_SCAN_RESPONSE_DATA</a></h2><h3>Description</h3><p>This command is used to provide scan response data used in scanning response PDUs during extended advertising.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.55].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Advertising_Handle</p>
</td><td><p>1</p>
</td><td><p>Used to identify an advertising set.</p>
</td><td><li>0x00 ... 0xEF</li></td></tr>
<tr><td><p>Operation</p>
</td><td><p>1</p>
</td><td><p>Scan response operation.</p>
</td><td><li>0x00: Intermediate fragment of fragmented scan response data</li><li>0x01: First fragment of fragmented scan response data</li><li>0x02: Last fragment of fragmented scan response data</li><li>0x03: Complete scan response data</li></td></tr>
<tr><td><p>Fragment_Preference</p>
</td><td><p>1</p>
</td><td><p>Fragment preference.</p>
</td><td><li>0x00: The Controller may fragment all data</li><li>0x01: The Controller should not fragment or should minimize fragmentation of data</li></td></tr>
<tr><td><p>Scan_Response_Data_Length</p>
</td><td><p>1</p>
</td><td><p>Length of Scan_Response_Data in octets</p>
</td><td></tr>
<tr><td><p>Scan_Response_Data</p>
</td><td><p>Scan_Response_Data_Length</p>
</td><td><p>Data formatted as defined in Bluetooth spec. v.5.4 [Vol 3, Part C, 11].</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_SET_EXTENDED_ADVERTISING_ENABLE_anchor">HCI_LE_SET_EXTENDED_ADVERTISING_ENABLE</a></h2><h3>Description</h3><p>This command is used to request the Controller to enable or disable one or more advertising sets using the advertising sets identified by the Advertising_Handle[i] parameter.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.56].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Enable</p>
</td><td><p>1</p>
</td><td><p>Enable/disable advertising.</p>
</td><td><li>0x00: Advertising is disabled</li><li>0x01: Advertising is enabled</li></td></tr>
<tr><td><p>Num_Sets</p>
</td><td><p>1</p>
</td><td><p>Number of advertising sets.</p>
</td><td><li>0x00: Disable all advertising sets</li><li>0x01 ... 0x3F: Number of advertising sets to enable or disable</li></td></tr>
<tr><td><p>Advertising_Handle[i]</p>
</td><td><p>1</p>
</td><td><p>Used to identify an advertising set.</p>
</td><td><li>0x00 ... 0xEF</li></td></tr>
<tr><td><p>Duration[i]</p>
</td><td><p>2</p>
</td><td><p>Duration of advertising set.
Time = N * 10 ms.</p>
</td><td><li>0x0000 (0 ms) : No advertising duration.</li><li>0x0001 (10 ms)  ... 0xFFFF (655350 ms) : Advertising duration</li></td></tr>
<tr><td><p>Max_Extended_Advertising_Events[i]</p>
</td><td><p>1</p>
</td><td><p>Maximum number of advertising events.</p>
</td><td><li>0x00: No maximum number of advertising events</li><li>0x01 ... 0xFF: Maximum number of extended advertising events the Controller shall attempt to send prior to terminating the extended advertising</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><li><a href="#HCI_LE_ADVERTISING_SET_TERMINATED_EVENT_anchor">HCI_LE_ADVERTISING_SET_TERMINATED_EVENT</a></li><li><a href="#HCI_LE_ENHANCED_CONNECTION_COMPLETE_EVENT_anchor">HCI_LE_ENHANCED_CONNECTION_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_READ_MAXIMUM_ADVERTISING_DATA_LENGTH_anchor">HCI_LE_READ_MAXIMUM_ADVERTISING_DATA_LENGTH</a></h2><h3>Description</h3><p>This command is used to read the maximum length of data supported by the Controller for use as advertisement data or scan response data in an extended advertising event.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.57].</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Max_Advertising_Data_Length</p>
</td><td><p>2</p>
</td><td><p>Maximum supported advertising data length.</p>
</td><td><li>0x001F ... 0x0672</li></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_READ_NUMBER_OF_SUPPORTED_ADVERTISING_SETS_anchor">HCI_LE_READ_NUMBER_OF_SUPPORTED_ADVERTISING_SETS</a></h2><h3>Description</h3><p>This command is used to read the maximum number of advertising sets supported by the Controller at the same time during extended advertising.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.58].</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Num_Supported_Advertising_Sets</p>
</td><td><p>1</p>
</td><td><p>Number of advertising sets supported at the same time.</p>
</td><td><li>0x01 ... 0xF0</li></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_REMOVE_ADVERTISING_SET_anchor">HCI_LE_REMOVE_ADVERTISING_SET</a></h2><h3>Description</h3><p>This command is used to remove an advertising set from the Controller.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.59].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Advertising_Handle</p>
</td><td><p>1</p>
</td><td><p>Used to identify an advertising set.</p>
</td><td><li>0x00 ... 0xEF</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_CLEAR_ADVERTISING_SETS_anchor">HCI_LE_CLEAR_ADVERTISING_SETS</a></h2><h3>Description</h3><p>This command is used to remove all existing advertising sets from the Controller.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.60].</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_SET_EXTENDED_SCAN_PARAMETERS_anchor">HCI_LE_SET_EXTENDED_SCAN_PARAMETERS</a></h2><h3>Description</h3><p>This command is used to set the extended scan parameters to be used on the advertising physical channels.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.64].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Own_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Own address type.</p>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li><li>0x02: Resolvable Private Address if available, otherwise Public Address</li><li>0x03: Resolvable Private Address if available, otherwise Random Address</li></td></tr>
<tr><td><p>Scanning_Filter_Policy</p>
</td><td><p>1</p>
</td><td><p>The scanning filter policy determines how the scanner's Link Layer processes advertising and scan response PDUs.
There is a choice of two primary filter policies: unfiltered and filtered.
Unfiltered: the Link Layer processes all advertising and scan response PDUs (i.e., the Filter Accept List is not used).
Filtered: the Link Layer processes advertising and scan response PDUs only from devices in the Filter Accept List.
With extended scanning filter policies, a directed advertising PDU accepted by the primary filter policy shall nevertheless be ignored unless either the TargetA field is identical to the scanner's device address, or TargetA field is a resolvable private address.</p>
</td><td><li>0x00: Basic unfiltered scanning filter policy</li><li>0x01: Basic filtered scanning filter policy</li><li>0x02: Extended unfiltered scanning filter policy</li><li>0x03: Extended filtered scanning filter policy</li></td></tr>
<tr><td><p>Scanning_PHYs</p>
</td><td><p>1</p>
</td><td><p>Scan PHYs.</p>
</td><td><p>Bitmask of:</p><li>0x01: Scan advertisements on the LE 1M PHY</li><li>0x04: Scan advertisements on the LE Coded PHY (not supported on STM32WB)</li></td></tr>
<tr><td><p>Scan_Type[i]</p>
</td><td><p>1</p>
</td><td><p>Passive or active scanning. With passive scanning, no scan request PDUs are sent.</p>
</td><td><li>0x00: Passive scanning</li><li>0x01: Active scanning</li></td></tr>
<tr><td><p>Scan_Interval[i]</p>
</td><td><p>2</p>
</td><td><p>Time interval from when the Controller started its last scan until it begins the subsequent scan on the primary advertising physical channel.
Time = N * 0.625 ms.</p>
</td><td><li>0x0004 (2.500 ms)  ... 0x5DC0 (15000.000 ms) : STM32WB</li><li>0x0004 (2.500 ms)  ... 0xFFFF (40959.375 ms) : STM32WBA</li></td></tr>
<tr><td><p>Scan_Window[i]</p>
</td><td><p>2</p>
</td><td><p>Duration of the scan on the primary advertising physical channel.
Time = N * 0.625 ms.</p>
</td><td><li>0x0004 (2.500 ms)  ... 0x5DC0 (15000.000 ms) : STM32WB</li><li>0x0004 (2.500 ms)  ... 0xFFFF (40959.375 ms) : STM32WBA</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_SET_EXTENDED_SCAN_ENABLE_anchor">HCI_LE_SET_EXTENDED_SCAN_ENABLE</a></h2><h3>Description</h3><p>This command is used to enable or disable extended scanning.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.65].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Enable</p>
</td><td><p>1</p>
</td><td><p>Enable/disable scan.</p>
</td><td><li>0x00: Scanning disabled</li><li>0x01: Scanning enabled</li></td></tr>
<tr><td><p>Filter_Duplicates</p>
</td><td><p>1</p>
</td><td><p>Duplicate filtering.</p>
</td><td><li>0x00: Duplicate filtering disabled</li><li>0x01: Duplicate filtering enabled</li><li>0x02: Duplicate filtering enabled, reset for each scan period</li></td></tr>
<tr><td><p>Duration</p>
</td><td><p>2</p>
</td><td><p>Scan duration.
Time = N * 10 ms.</p>
</td><td><li>0x0000 (0 ms) : Scan continuously until explicitly disable</li><li>0x0001 (10 ms)  ... 0xFFFF (655350 ms) : Scan duration</li></td></tr>
<tr><td><p>Period</p>
</td><td><p>2</p>
</td><td><p>Scan period.
Time = N * 1.28 s.</p>
</td><td><li>0x0000 (0 ms) : Scan continuously</li><li>0x0001 (1280 ms)  ... 0xFFFF (83884800 ms) : Time interval from when the Controller started its last Scan_Duration until it begins the subsequent Scan_Duration</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><li><a href="#HCI_LE_EXTENDED_ADVERTISING_REPORT_EVENT_anchor">HCI_LE_EXTENDED_ADVERTISING_REPORT_EVENT</a></li><h2><a name="HCI_LE_EXTENDED_CREATE_CONNECTION_anchor">HCI_LE_EXTENDED_CREATE_CONNECTION</a></h2><h3>Description</h3><p>This command is used to create an ACL connection to a connectable advertiser by means of extended scanning.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.66].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Initiator_Filter_Policy</p>
</td><td><p>1</p>
</td><td><p>Initiator filter policy.</p>
</td><td><li>0x00: Filter Accept List is not used to determine which advertiser to connect to</li><li>0x01: Filter Accept List is used to determine which advertiser to connect to (Peer_Address_Type and Peer_Address are ignored)</li></td></tr>
<tr><td><p>Own_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Own address type.</p>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li><li>0x02: Resolvable Private Address if available, otherwise Public Address</li><li>0x03: Resolvable Private Address if available, otherwise Random Address</li></td></tr>
<tr><td><p>Peer_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Address type of the peer device.</p>
</td><td><li>0x00: Public Device Address or Public Identity Address</li><li>0x01: Random Device Address or Random (static) Identity Address</li></td></tr>
<tr><td><p>Peer_Address</p>
</td><td><p>6</p>
</td><td><p>Public Device Address, Random Device Address, Public Identity Address, or Random (static) Identity Address of the device to be connected.</p>
</td><td></tr>
<tr><td><p>Initiating_PHYs</p>
</td><td><p>1</p>
</td><td><p>Initiating PHYs.</p>
</td><td><p>Bitmask of:</p><li>0x01: Scan connectable advertisements on the LE 1M PHY- Connection parameters for the LE 1M PHY</li><li>0x02: Connection parameters for the LE 2M PHY</li><li>0x04: Scan connectable advertisements on the LE Coded PHY (not supported on STM32WB)</li></td></tr>
<tr><td><p>Scan_Interval[i]</p>
</td><td><p>2</p>
</td><td><p>Time interval from when the Controller started its last scan until it begins the subsequent scan on the primary advertising physical channel.
Time = N * 0.625 ms.</p>
</td><td><li>0x0004 (2.500 ms)  ... 0x5DC0 (15000.000 ms) : STM32WB</li><li>0x0004 (2.500 ms)  ... 0xFFFF (40959.375 ms) : STM32WBA</li></td></tr>
<tr><td><p>Scan_Window[i]</p>
</td><td><p>2</p>
</td><td><p>Duration of the scan on the primary advertising physical channel.
Time = N * 0.625 ms.</p>
</td><td><li>0x0004 (2.500 ms)  ... 0x5DC0 (15000.000 ms) : STM32WB</li><li>0x0004 (2.500 ms)  ... 0xFFFF (40959.375 ms) : STM32WBA</li></td></tr>
<tr><td><p>Conn_Interval_Min[i]</p>
</td><td><p>2</p>
</td><td><p>Minimum value for the connection event interval.
Time = N * 1.25 ms.</p>
</td><td><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Conn_Interval_Max[i]</p>
</td><td><p>2</p>
</td><td><p>Maximum value for the connection event interval.
Time = N * 1.25 ms.</p>
</td><td><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Conn_Latency[i]</p>
</td><td><p>2</p>
</td><td><p>Maximum Peripheral latency for the connection in number of connection events.</p>
</td><td><li>0x0000 ... 0x01F3</li></td></tr>
<tr><td><p>Supervision_Timeout[i]</p>
</td><td><p>2</p>
</td><td><p>Supervision timeout for the LE Link.
It shall be a multiple of 10 ms and larger than (1 + connPeripheralLatency) * connInterval * 2.
Time = N * 10 ms.</p>
</td><td><li>0x000A (100 ms)  ... 0x0C80 (32000 ms) </li></td></tr>
<tr><td><p>Min_CE_Length[i]</p>
</td><td><p>2</p>
</td><td><p>Information parameter about the minimum length of connection needed for this LE connection.
Time = N * 0.625 ms.</p>
</td><td><li>0x0000 (0.000 ms)  ... 0xFFFF (40959.375 ms) </li></td></tr>
<tr><td><p>Max_CE_Length[i]</p>
</td><td><p>2</p>
</td><td><p>Information parameter about the maximum length of connection needed for this LE connection.
Time = N * 0.625 ms.</p>
</td><td><li>0x0000 (0.000 ms)  ... 0xFFFF (40959.375 ms) </li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#HCI_LE_ENHANCED_CONNECTION_COMPLETE_EVENT_anchor">HCI_LE_ENHANCED_CONNECTION_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_READ_TRANSMIT_POWER_anchor">HCI_LE_READ_TRANSMIT_POWER</a></h2><h3>Description</h3><p>This command is used to read the minimum and maximum transmit powers supported by the Controller.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.74].</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Min_TX_Power</p>
</td><td><p>1</p>
</td><td><p>Signed integer.
Units: dBm.</p>
</td><td><li>-127 ... 20</li></td></tr>
<tr><td><p>Max_TX_Power</p>
</td><td><p>1</p>
</td><td><p>Signed integer.
Units: dBm.</p>
</td><td><li>-127 ... 20</li></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_READ_RF_PATH_COMPENSATION_anchor">HCI_LE_READ_RF_PATH_COMPENSATION</a></h2><h3>Description</h3><p>This command is used to read the RF path compensation value parameters used in the Tx power level and RSSI calculation.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.75].</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>RF_TX_Path_Compensation</p>
</td><td><p>2</p>
</td><td><p>RF TX Path Compensation Value (16-bit signed integer).
Units: 0.1 dB.</p>
</td><td><li>-1280 ... 1280</li></td></tr>
<tr><td><p>RF_RX_Path_Compensation</p>
</td><td><p>2</p>
</td><td><p>RF RX Path Compensation Value (16-bit signed integer).
Units: 0.1 dB.</p>
</td><td><li>-1280 ... 1280</li></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_WRITE_RF_PATH_COMPENSATION_anchor">HCI_LE_WRITE_RF_PATH_COMPENSATION</a></h2><h3>Description</h3><p>This command is used to indicate the RF path gain or loss between the RF transceiver and the antenna contributed by intermediate components. A positive value means a net RF path gain and a negative value means a net RF path loss.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.76].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>RF_TX_Path_Compensation</p>
</td><td><p>2</p>
</td><td><p>RF TX Path Compensation Value (16-bit signed integer).
Units: 0.1 dB.</p>
</td><td><li>-1280 ... 1280</li></td></tr>
<tr><td><p>RF_RX_Path_Compensation</p>
</td><td><p>2</p>
</td><td><p>RF RX Path Compensation Value (16-bit signed integer).
Units: 0.1 dB.</p>
</td><td><li>-1280 ... 1280</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_SET_PRIVACY_MODE_anchor">HCI_LE_SET_PRIVACY_MODE</a></h2><h3>Description</h3><p>This command is used to allow the Host to specify the privacy mode to be used for a given entry on the resolving list.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.77].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Peer_Identity_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Identity address type</p>
</td><td><li>0x00: Public Identity Address</li><li>0x01: Random (static) Identity Address</li></td></tr>
<tr><td><p>Peer_Identity_Address</p>
</td><td><p>6</p>
</td><td><p>Public or Random (static) Identity Address of the peer device</p>
</td><td></tr>
<tr><td><p>Privacy_Mode</p>
</td><td><p>1</p>
</td><td><p>Privacy Mode.</p>
</td><td><li>0x00: Use Network Privacy Mode</li><li>0x01: Use Device Privacy Mode</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_GENERATE_DHKEY_V2_anchor">HCI_LE_GENERATE_DHKEY_V2</a></h2><h3>Description</h3><p>This command is used to initiate generation of a Diffie-Hellman key in the Controller for use over the LE transport. This command takes the remote P-256 public key as input. The Diffie-Hellman key generation uses the private key generated by the HCI_LE_Read_Local_P-256_Public_Key command or the private debug key.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.37].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Remote_P256_Public_Key</p>
</td><td><p>64</p>
</td><td><p>The remote P-256 public key in X, Y format:
Octets 31-0: X coordinate
Octets 63-32: Y coordinate
Little Endian Format</p>
</td><td></tr>
<tr><td><p>Key_Type</p>
</td><td><p>1</p>
</td><td><p>Type of private key used for the Diffie-Hellman key generation.</p>
</td><td><li>0x00: Use the generated private key</li><li>0x01: Use the debug private key</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#HCI_LE_GENERATE_DHKEY_COMPLETE_EVENT_anchor">HCI_LE_GENERATE_DHKEY_COMPLETE_EVENT</a></li><h2><a name="HCI TESTING commands_anchor">HCI TESTING commands</a></h2><h2></h2><table width="800" border="1" class="reference">
<tr><th>Command</th><th>Opcode</th><th>BF</th><th>PO</th><th>LO</th><th>LB</th><th>BO</th></tr>
<tr><td><a href="#HCI_LE_RECEIVER_TEST_anchor">HCI_LE_RECEIVER_TEST</a></td><td><p>0x201D</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td></tr>
<tr><td><a href="#HCI_LE_TRANSMITTER_TEST_anchor">HCI_LE_TRANSMITTER_TEST</a></td><td><p>0x201E</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td></tr>
<tr><td><a href="#HCI_LE_TEST_END_anchor">HCI_LE_TEST_END</a></td><td><p>0x201F</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td></tr>
<tr><td><a href="#HCI_LE_RECEIVER_TEST_V2_anchor">HCI_LE_RECEIVER_TEST_V2</a></td><td><p>0x2033</p>
</td><td><p>Y</p>
</td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_LE_TRANSMITTER_TEST_V2_anchor">HCI_LE_TRANSMITTER_TEST_V2</a></td><td><p>0x2034</p>
</td><td><p>Y</p>
</td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
</table><h2><a name="HCI_LE_RECEIVER_TEST_anchor">HCI_LE_RECEIVER_TEST</a></h2><h3>Description</h3><p>This command is used to start a test where the DUT receives test reference packets at a fixed interval. The tester generates the test reference packets.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.28].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>RX_Frequency</p>
</td><td><p>1</p>
</td><td><p>N = (F - 2402) / 2
Frequency Range : 2402 MHz to 2480 MHz</p>
</td><td><li>0x00 ... 0x27</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_TRANSMITTER_TEST_anchor">HCI_LE_TRANSMITTER_TEST</a></h2><h3>Description</h3><p>This command is used to start a test where the DUT generates test reference packets at a fixed interval. The Controller shall transmit at maximum power.<br>An LE Controller supporting the LE_Transmitter_Test command shall support Packet_Payload values 0x00, 0x01 and 0x02. An LE Controller may support other values of Packet_Payload.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.29].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>TX_Frequency</p>
</td><td><p>1</p>
</td><td><p>N = (F - 2402) / 2
Frequency Range : 2402 MHz to 2480 MHz</p>
</td><td><li>0x00 ... 0x27</li></td></tr>
<tr><td><p>Length_Of_Test_Data</p>
</td><td><p>1</p>
</td><td><p>Length in bytes of payload data in each packet.</p>
</td><td><li>0x00 ... 0x25: for BO variant</li><li>0x00 ... 0xFF: otherwise</li></td></tr>
<tr><td><p>Packet_Payload</p>
</td><td><p>1</p>
</td><td><p>Type of packet payload.</p>
</td><td><li>0x00: Pseudo-Random bit sequence 9</li><li>0x01: Pattern of alternating bits '11110000'</li><li>0x02: Pattern of alternating bits '10101010'</li><li>0x03: Pseudo-Random bit sequence 15</li><li>0x04: Pattern of All '1' bits</li><li>0x05: Pattern of All '0' bits</li><li>0x06: Pattern of alternating bits '00001111'</li><li>0x07: Pattern of alternating bits '0101'</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_TEST_END_anchor">HCI_LE_TEST_END</a></h2><h3>Description</h3><p>This command is used to stop any test which is in progress. The Number_Of_Packets for a transmitter test shall be reported as 0x0000. The Number_Of_Packets is an unsigned number and contains the number of received packets.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.30].</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Number_Of_Packets</p>
</td><td><p>2</p>
</td><td><p>Number of packets received</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_RECEIVER_TEST_V2_anchor">HCI_LE_RECEIVER_TEST_V2</a></h2><h3>Description</h3><p>This command is used to start a test where the DUT receives test reference packets at a fixed interval. The tester generates the test reference packets.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.28].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>RX_Frequency</p>
</td><td><p>1</p>
</td><td><p>N = (F - 2402) / 2
Frequency Range : 2402 MHz to 2480 MHz</p>
</td><td><li>0x00 ... 0x27</li></td></tr>
<tr><td><p>PHY</p>
</td><td><p>1</p>
</td><td><p>PHY to use for test packet</p>
</td><td><li>0x01: Transmitter set to use the LE 1M PHY</li><li>0x02: Transmitter set to use the LE 2M PHY</li><li>0x03: Transmitter set to use the LE Coded PHY with S=8 data coding</li><li>0x04: Transmitter set to use the LE Coded PHY with S=2 data coding</li></td></tr>
<tr><td><p>Modulation_Index</p>
</td><td><p>1</p>
</td><td><p>Modulation index capability of the transmitter</p>
</td><td><li>0x00: Assume transmitter will have a standard modulation index</li><li>0x01: Assume transmitter will have a stable modulation index</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_TRANSMITTER_TEST_V2_anchor">HCI_LE_TRANSMITTER_TEST_V2</a></h2><h3>Description</h3><p>This command is used to start a test where the DUT generates test reference packets at a fixed interval. The Controller shall transmit at maximum power.<br>An LE Controller supporting this command shall support Packet_Payload values 0x00, 0x01 and 0x02. An LE Controller supporting the LE Coded PHY shall also support Packet_Payload value 0x04 (not supported by STM32WB). An LE Controller may support other values of Packet_Payload.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.8.29].</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>TX_Frequency</p>
</td><td><p>1</p>
</td><td><p>N = (F - 2402) / 2
Frequency Range : 2402 MHz to 2480 MHz</p>
</td><td><li>0x00 ... 0x27</li></td></tr>
<tr><td><p>Length_Of_Test_Data</p>
</td><td><p>1</p>
</td><td><p>Length in bytes of payload data in each packet.</p>
</td><td><li>0x00 ... 0x25: for BO variant</li><li>0x00 ... 0xFF: otherwise</li></td></tr>
<tr><td><p>Packet_Payload</p>
</td><td><p>1</p>
</td><td><p>Type of packet payload.</p>
</td><td><li>0x00: Pseudo-Random bit sequence 9</li><li>0x01: Pattern of alternating bits '11110000'</li><li>0x02: Pattern of alternating bits '10101010'</li><li>0x03: Pseudo-Random bit sequence 15</li><li>0x04: Pattern of All '1' bits</li><li>0x05: Pattern of All '0' bits</li><li>0x06: Pattern of alternating bits '00001111'</li><li>0x07: Pattern of alternating bits '0101'</li></td></tr>
<tr><td><p>PHY</p>
</td><td><p>1</p>
</td><td><p>PHY to use for test packet</p>
</td><td><li>0x01: Transmitter set to use the LE 1M PHY</li><li>0x02: Transmitter set to use the LE 2M PHY</li><li>0x03: Transmitter set to use the LE Coded PHY with S=8 data coding</li><li>0x04: Transmitter set to use the LE Coded PHY with S=2 data coding</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI HAL commands_anchor">ACI HAL commands</a></h2><h2></h2><table width="800" border="1" class="reference">
<tr><th>Command</th><th>Opcode</th><th>BF</th><th>PO</th><th>LO</th><th>LB</th><th>BO</th></tr>
<tr><td><a href="#ACI_HAL_GET_FW_BUILD_NUMBER_anchor">ACI_HAL_GET_FW_BUILD_NUMBER</a></td><td><p>0xFC00</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td></tr>
<tr><td><a href="#ACI_HAL_WRITE_CONFIG_DATA_anchor">ACI_HAL_WRITE_CONFIG_DATA</a></td><td><p>0xFC0C</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td></tr>
<tr><td><a href="#ACI_HAL_READ_CONFIG_DATA_anchor">ACI_HAL_READ_CONFIG_DATA</a></td><td><p>0xFC0D</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td></tr>
<tr><td><a href="#ACI_HAL_SET_TX_POWER_LEVEL_anchor">ACI_HAL_SET_TX_POWER_LEVEL</a></td><td><p>0xFC0F</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td></tr>
<tr><td><a href="#ACI_HAL_LE_TX_TEST_PACKET_NUMBER_anchor">ACI_HAL_LE_TX_TEST_PACKET_NUMBER</a></td><td><p>0xFC14</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#ACI_HAL_TONE_START_anchor">ACI_HAL_TONE_START</a></td><td><p>0xFC15</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td></tr>
<tr><td><a href="#ACI_HAL_TONE_STOP_anchor">ACI_HAL_TONE_STOP</a></td><td><p>0xFC16</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td></tr>
<tr><td><a href="#ACI_HAL_GET_LINK_STATUS_anchor">ACI_HAL_GET_LINK_STATUS</a></td><td><p>0xFC17</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#ACI_HAL_SET_RADIO_ACTIVITY_MASK_anchor">ACI_HAL_SET_RADIO_ACTIVITY_MASK</a></td><td><p>0xFC18</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td></tr>
<tr><td><a href="#ACI_HAL_GET_ANCHOR_PERIOD_anchor">ACI_HAL_GET_ANCHOR_PERIOD</a></td><td><p>0xFC19</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td></tr>
<tr><td><a href="#ACI_HAL_SET_EVENT_MASK_anchor">ACI_HAL_SET_EVENT_MASK</a></td><td><p>0xFC1A</p>
</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_HAL_GET_PM_DEBUG_INFO_anchor">ACI_HAL_GET_PM_DEBUG_INFO</a></td><td><p>0xFC1C</p>
</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_HAL_SET_PERIPHERAL_LATENCY_anchor">ACI_HAL_SET_PERIPHERAL_LATENCY</a></td><td><p>0xFC20</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#ACI_HAL_READ_RSSI_anchor">ACI_HAL_READ_RSSI</a></td><td><p>0xFC22</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td></tr>
<tr><td><a href="#ACI_HAL_READ_RADIO_REG_anchor">ACI_HAL_READ_RADIO_REG</a></td><td><p>0xFC30</p>
</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_HAL_WRITE_RADIO_REG_anchor">ACI_HAL_WRITE_RADIO_REG</a></td><td><p>0xFC31</p>
</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_HAL_READ_RAW_RSSI_anchor">ACI_HAL_READ_RAW_RSSI</a></td><td><p>0xFC32</p>
</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_HAL_RX_START_anchor">ACI_HAL_RX_START</a></td><td><p>0xFC33</p>
</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_HAL_RX_STOP_anchor">ACI_HAL_RX_STOP</a></td><td><p>0xFC34</p>
</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_HAL_STACK_RESET_anchor">ACI_HAL_STACK_RESET</a></td><td><p>0xFC3B</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td></tr>
</table><h2><a name="ACI_HAL_GET_FW_BUILD_NUMBER_anchor">ACI_HAL_GET_FW_BUILD_NUMBER</a></h2><h3>Description</h3><p>This command returns the build number associated with the firmware version currently running</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Build_Number</p>
</td><td><p>2</p>
</td><td><p>Build number of the firmware.</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_HAL_WRITE_CONFIG_DATA_anchor">ACI_HAL_WRITE_CONFIG_DATA</a></h2><h3>Description</h3><p>This command writes a value to a configure data structure. It is useful to setup directly some parameters for the BLE stack.<br>Note: the static random address set by this command is taken into account by the GAP only when it receives the <a href="#ACI_GAP_INIT_anchor">ACI_GAP_INIT</a> command.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Offset</p>
</td><td><p>1</p>
</td><td><p>Offset of the element in the configuration data structure which has to be written.</p>
</td><td><li>0x00: CONFIG_DATA_PUBADDR_OFFSET;
Bluetooth public address; 6 bytes</li><li>0x08: CONFIG_DATA_ER_OFFSET;
Encryption root key used to derive LTK (legacy) and CSRK; 16 bytes</li><li>0x18: CONFIG_DATA_IR_OFFSET;
Identity root key used to derive DHK (legacy) and IRK; 16 bytes</li><li>0x2E: CONFIG_DATA_RANDOM_ADDRESS_OFFSET;
Static Random Address; 6 bytes</li><li>0x34: CONFIG_DATA_GAP_ADD_REC_NBR_OFFSET;
GAP service additional record number</li><li>0x35: CONFIG_DATA_SC_KEY_TYPE_OFFSET;
Secure Connections key type (0: "normal", 1: "debug"); 1 byte</li><li>0xB0: CONFIG_DATA_SMP_MODE_OFFSET;
SMP mode (0: "normal", 1: "bypass", 2: "no blacklist"); 1 byte</li><li>0xC0: CONFIG_DATA_LL_SCAN_CHAN_MAP_OFFSET (only for STM32WB);
LL scan channel map (same format as Primary_Adv_Channel_Map); 1 byte</li><li>0xC1: CONFIG_DATA_LL_BG_SCAN_MODE_OFFSET (only for STM32WB);
LL background scan mode (0: "BG scan disabled", 1: "BG scan enabled"); 1 byte</li></td></tr>
<tr><td><p>Length</p>
</td><td><p>1</p>
</td><td><p>Length of data to be written</p>
</td><td></tr>
<tr><td><p>Value</p>
</td><td><p>Length</p>
</td><td><p>Data to be written</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_HAL_READ_CONFIG_DATA_anchor">ACI_HAL_READ_CONFIG_DATA</a></h2><h3>Description</h3><p>This command requests the value in the configure data structure. The number of read bytes changes for different Offset.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Offset</p>
</td><td><p>1</p>
</td><td><p>Offset of the element in the configuration data structure
which has to be read.</p>
</td><td><li>0x00: CONFIG_DATA_PUBADDR_OFFSET;
Bluetooth public address; 6 bytes</li><li>0x08: CONFIG_DATA_ER_OFFSET;
Encryption root key used to derive LTK (legacy) and CSRK; 16 bytes</li><li>0x18: CONFIG_DATA_IR_OFFSET
Identity root key used to derive DHK (legacy) and IRK; 16 bytes</li><li>0x2E: CONFIG_DATA_RANDOM_ADDRESS_OFFSET;
Static Random Address; 6 bytes</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Data_Length</p>
</td><td><p>1</p>
</td><td><p>Length of Data in octets</p>
</td><td></tr>
<tr><td><p>Data</p>
</td><td><p>Data_Length</p>
</td><td><p>Data field associated with Offset parameter</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_HAL_SET_TX_POWER_LEVEL_anchor">ACI_HAL_SET_TX_POWER_LEVEL</a></h2><h3>Description</h3><p>This command sets the TX power level of the device. By controlling the PA level, that determines the output power level (dBm) at the IC pin.<br>When the system starts up or reboots, the default TX power level is used, which is the maximum value. Once this command is given, the output power changes instantly, regardless if there is Bluetooth communication going on or not. For example, for debugging purpose, the device can be set to advertise all the time. By using this command, one can then observe the evolution of the TX signal strength.<br>The system keeps the last received TX power level from the command, i.e. the 2nd command overwrites the previous TX power level. The new TX power level remains until another ACI_HAL_SET_TX_POWER_LEVEL command, or the system reboots. However, note that the advertising extensions commands allow, per advertising set, to override the value of TX power determined by ACI_HAL_SET_TX_POWER_LEVEL command (e.g. see <a href="#ACI_GAP_ADV_SET_CONFIGURATION_anchor">ACI_GAP_ADV_SET_CONFIGURATION</a>).<br>Refer to <a href="#Annex_anchor">Annex</a> for the dBm corresponding values of PA_Level parameter.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>En_High_Power</p>
</td><td><p>1</p>
</td><td><p>Enable High Power mode - Deprecated and ignored</p>
</td><td><li>0x00: Standard Power</li><li>0x01: High Power</li></td></tr>
<tr><td><p>PA_Level</p>
</td><td><p>1</p>
</td><td><p>Power amplifier output level.</p>
</td><td><li>0x00 ... 0x23</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_HAL_LE_TX_TEST_PACKET_NUMBER_anchor">ACI_HAL_LE_TX_TEST_PACKET_NUMBER</a></h2><h3>Description</h3><p>This command returns the number of packets sent in Direct Test Mode.<br>When the Direct TX test is started, a 16-bit counter is used to count how many packets have been transmitted. <br>This command can be used to check how many packets have been sent during the Direct TX test.<br>The counter starts from 0 and counts upwards. The counter can wrap and start from 0 again. The counter is not cleared until the next Direct TX test starts. </p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Number_Of_Packets</p>
</td><td><p>4</p>
</td><td><p>Number of packets sent during the last Direct TX test.</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_HAL_TONE_START_anchor">ACI_HAL_TONE_START</a></h2><h3>Description</h3><p>This command starts a carrier frequency, i.e. a tone, on a specific channel. The frequency sine wave at the specific channel may be used for debugging purpose only. The channel ID is a parameter from 0x00 to 0x27 for the 40 BLE channels, e.g. 0x00 for 2.402 GHz, 0x01 for 2.404 GHz etc.<br>This command should not be used when normal Bluetooth activities are ongoing.<br>The tone should be stopped by <a href="#ACI_HAL_TONE_STOP_anchor">ACI_HAL_TONE_STOP</a> command.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>RF_Channel</p>
</td><td><p>1</p>
</td><td><p>BLE Channel ID, from 0x00 to 0x27 meaning (2.402 + 0.002*0xXX) GHz
Device will continuously emit 0s, that means that the tone will be at the channel center frequency minus the maximum frequency deviation (250 kHz).</p>
</td><td><li>0x00 ... 0x27</li></td></tr>
<tr><td><p>Freq_offset</p>
</td><td><p>1</p>
</td><td><p>Frequency Offset for tone channel</p>
</td><td><li>0x00 ... 0xFF</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_HAL_TONE_STOP_anchor">ACI_HAL_TONE_STOP</a></h2><h3>Description</h3><p>This command is used to stop the previously started <a href="#ACI_HAL_TONE_START_anchor">ACI_HAL_TONE_START</a> command.</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_HAL_GET_LINK_STATUS_anchor">ACI_HAL_GET_LINK_STATUS</a></h2><h3>Description</h3><p>This command returns the status of the 8 Bluetooth Low Energy links managed by the device</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Link_Status</p>
</td><td><p>8</p>
</td><td><p>Array of link status (8 links). Each link status is 1 byte.</p>
</td><td><li>0x00: Idle</li><li>0x01: Advertising</li><li>0x02: Connected in Peripheral role</li><li>0x03: Scanning</li><li>0x04: Reserved</li><li>0x05: Connected in Central role</li><li>0x06: TX test mode</li><li>0x07: RX test mode</li><li>0x81: Advertising with Additional Beacon</li></td></tr>
<tr><td><p>Link_Connection_Handle</p>
</td><td><p>16</p>
</td><td><p>Array of connection handles (2 bytes) for 8 links. Valid only if the link status is &quot;connected&quot; (0x02 or 0x05)</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_HAL_SET_RADIO_ACTIVITY_MASK_anchor">ACI_HAL_SET_RADIO_ACTIVITY_MASK</a></h2><h3>Description</h3><p>This command set the bitmask associated to <a href="#ACI_HAL_END_OF_RADIO_ACTIVITY_EVENT_anchor">ACI_HAL_END_OF_RADIO_ACTIVITY_EVENT</a>.<br>Only the radio activities enabled in the mask will be reported to application by <a href="#ACI_HAL_END_OF_RADIO_ACTIVITY_EVENT_anchor">ACI_HAL_END_OF_RADIO_ACTIVITY_EVENT</a></p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Radio_Activity_Mask</p>
</td><td><p>2</p>
</td><td><p>Bitmask of radio events</p>
</td><td><p>Bitmask of:</p><li>0x0001: Idle</li><li>0x0002: Advertising</li><li>0x0004: Peripheral connection</li><li>0x0008: Scanning</li><li>0x0020: Central connection</li><li>0x0040: TX test mode</li><li>0x0080: RX test mode</li><li>0x0200: Periodic advertising (only for STM32WBA)</li><li>0x0400: Periodic sync (only for STM32WBA)</li><li>0x0800: Iso broadcast (only for STM32WBA)</li><li>0x1000: Iso sync (only for STM32WBA)</li><li>0x2000: Iso peripheral connection (only for STM32WBA)</li><li>0x4000: Iso central connection (only for STM32WBA)</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><li><a href="#ACI_HAL_END_OF_RADIO_ACTIVITY_EVENT_anchor">ACI_HAL_END_OF_RADIO_ACTIVITY_EVENT</a></li><h2><a name="ACI_HAL_GET_ANCHOR_PERIOD_anchor">ACI_HAL_GET_ANCHOR_PERIOD</a></h2><h3>Description</h3><p>This command returns information about the Anchor Period to help application in selecting slot timings when operating in multi-link scenarios.</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Anchor_Period</p>
</td><td><p>4</p>
</td><td><p>Current anchor period.
T = N * 0.625 ms.</p>
</td><td></tr>
<tr><td><p>Max_Free_Slot</p>
</td><td><p>4</p>
</td><td><p>Maximum available time that can be allocated for a new slot.
T = N * 0.625 ms.</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_HAL_SET_EVENT_MASK_anchor">ACI_HAL_SET_EVENT_MASK</a></h2><h3>Description</h3><p>This command is used to enable/disable the generation of HAL events. If the bit in the Event_Mask is set to a one, then the event associated with that bit will be enabled.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Event_Mask</p>
</td><td><p>4</p>
</td><td><p>Mask to enable/disable generation of HAL events</p>
</td><td><p>Bitmask of:</p><li>0x00000000: No events specified (Default)</li><li>0x00000001: ACI_HAL_SCAN_REQ_REPORT_EVENT</li><li>0x00000002: ACI_HAL_SYNC_EVENT (only for STM32WBA)</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_HAL_GET_PM_DEBUG_INFO_anchor">ACI_HAL_GET_PM_DEBUG_INFO</a></h2><h3>Description</h3><p>This command is used to retrieve TX, RX and total buffer count allocated for ACL packets.</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Allocated_For_TX</p>
</td><td><p>1</p>
</td><td><p>MBlocks allocated for TXing</p>
</td><td></tr>
<tr><td><p>Allocated_For_RX</p>
</td><td><p>1</p>
</td><td><p>MBlocks allocated for RXing</p>
</td><td></tr>
<tr><td><p>Allocated_MBlocks</p>
</td><td><p>1</p>
</td><td><p>Overall allocated MBlocks</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_HAL_SET_PERIPHERAL_LATENCY_anchor">ACI_HAL_SET_PERIPHERAL_LATENCY</a></h2><h3>Description</h3><p>This command is used to disable/enable the Peripheral latency feature during a connection. Note that, by default, the Peripheral latency is enabled at connection time.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Enable</p>
</td><td><p>1</p>
</td><td><p>Enable/disable Peripheral latency.</p>
</td><td><li>0x00: Peripheral latency is disabled</li><li>0x01: Peripheral latency is enabled</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_HAL_READ_RSSI_anchor">ACI_HAL_READ_RSSI</a></h2><h3>Description</h3><p>This command returns the value of the RSSI.</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>RSSI</p>
</td><td><p>1</p>
</td><td><p>RSSI (signed integer).
Units: dBm.</p>
</td><td><li>127: RSSI not available</li><li>-127 ... 20</li></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_HAL_READ_RADIO_REG_anchor">ACI_HAL_READ_RADIO_REG</a></h2><h3>Description</h3><p>This command Reads Register value from the RF module.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Register_Address</p>
</td><td><p>1</p>
</td><td><p>Address of the register to be read</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>reg_val</p>
</td><td><p>1</p>
</td><td><p>Register value</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_HAL_WRITE_RADIO_REG_anchor">ACI_HAL_WRITE_RADIO_REG</a></h2><h3>Description</h3><p>This command writes Register value to the RF module.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Register_Address</p>
</td><td><p>1</p>
</td><td><p>Address of the register to be written</p>
</td><td></tr>
<tr><td><p>Register_Value</p>
</td><td><p>1</p>
</td><td><p>Value to be written</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_HAL_READ_RAW_RSSI_anchor">ACI_HAL_READ_RAW_RSSI</a></h2><h3>Description</h3><p>This command returns the raw value of the RSSI.</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Value</p>
</td><td><p>3</p>
</td><td><p>RAW RSSI value</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_HAL_RX_START_anchor">ACI_HAL_RX_START</a></h2><h3>Description</h3><p>This command does set up the RF to listen to a specific RF channel.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>RF_Channel</p>
</td><td><p>1</p>
</td><td><p>BLE Channel ID, from 0x00 to 0x27 meaning (2.402 + 0.002*0xXX) GHz
Device will continuously emit 0s, that means that the tone will be at the channel center frequency minus the maximum frequency deviation (250 kHz).</p>
</td><td><li>0x00 ... 0x27</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_HAL_RX_STOP_anchor">ACI_HAL_RX_STOP</a></h2><h3>Description</h3><p>This command stops a previous ACI_HAL_RX_START command.</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_HAL_STACK_RESET_anchor">ACI_HAL_STACK_RESET</a></h2><h3>Description</h3><p>This command is equivalent to HCI_RESET but ensures the sleep mode is entered immediately after its completion.</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI GAP commands_anchor">ACI GAP commands</a></h2><h2></h2><table width="800" border="1" class="reference">
<tr><th>Command</th><th>Opcode</th><th>BF</th><th>PO</th><th>LO</th><th>LB</th><th>BO</th></tr>
<tr><td><a href="#ACI_GAP_SET_NON_DISCOVERABLE_anchor">ACI_GAP_SET_NON_DISCOVERABLE</a></td><td><p>0xFC81</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_SET_LIMITED_DISCOVERABLE_anchor">ACI_GAP_SET_LIMITED_DISCOVERABLE</a></td><td><p>0xFC82</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_SET_DISCOVERABLE_anchor">ACI_GAP_SET_DISCOVERABLE</a></td><td><p>0xFC83</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_SET_DIRECT_CONNECTABLE_anchor">ACI_GAP_SET_DIRECT_CONNECTABLE</a></td><td><p>0xFC84</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_SET_IO_CAPABILITY_anchor">ACI_GAP_SET_IO_CAPABILITY</a></td><td><p>0xFC85</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_SET_AUTHENTICATION_REQUIREMENT_anchor">ACI_GAP_SET_AUTHENTICATION_REQUIREMENT</a></td><td><p>0xFC86</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_SET_AUTHORIZATION_REQUIREMENT_anchor">ACI_GAP_SET_AUTHORIZATION_REQUIREMENT</a></td><td><p>0xFC87</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_PASS_KEY_RESP_anchor">ACI_GAP_PASS_KEY_RESP</a></td><td><p>0xFC88</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_AUTHORIZATION_RESP_anchor">ACI_GAP_AUTHORIZATION_RESP</a></td><td><p>0xFC89</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_INIT_anchor">ACI_GAP_INIT</a></td><td><p>0xFC8A</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_SET_NON_CONNECTABLE_anchor">ACI_GAP_SET_NON_CONNECTABLE</a></td><td><p>0xFC8B</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_SET_UNDIRECTED_CONNECTABLE_anchor">ACI_GAP_SET_UNDIRECTED_CONNECTABLE</a></td><td><p>0xFC8C</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_PERIPHERAL_SECURITY_REQ_anchor">ACI_GAP_PERIPHERAL_SECURITY_REQ</a></td><td><p>0xFC8D</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_UPDATE_ADV_DATA_anchor">ACI_GAP_UPDATE_ADV_DATA</a></td><td><p>0xFC8E</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_DELETE_AD_TYPE_anchor">ACI_GAP_DELETE_AD_TYPE</a></td><td><p>0xFC8F</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_GET_SECURITY_LEVEL_anchor">ACI_GAP_GET_SECURITY_LEVEL</a></td><td><p>0xFC90</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_SET_EVENT_MASK_anchor">ACI_GAP_SET_EVENT_MASK</a></td><td><p>0xFC91</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_CONFIGURE_FILTER_ACCEPT_LIST_anchor">ACI_GAP_CONFIGURE_FILTER_ACCEPT_LIST</a></td><td><p>0xFC92</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_TERMINATE_anchor">ACI_GAP_TERMINATE</a></td><td><p>0xFC93</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_CLEAR_SECURITY_DB_anchor">ACI_GAP_CLEAR_SECURITY_DB</a></td><td><p>0xFC94</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_ALLOW_REBOND_anchor">ACI_GAP_ALLOW_REBOND</a></td><td><p>0xFC95</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_START_LIMITED_DISCOVERY_PROC_anchor">ACI_GAP_START_LIMITED_DISCOVERY_PROC</a></td><td><p>0xFC96</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_START_GENERAL_DISCOVERY_PROC_anchor">ACI_GAP_START_GENERAL_DISCOVERY_PROC</a></td><td><p>0xFC97</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_START_AUTO_CONNECTION_ESTABLISH_PROC_anchor">ACI_GAP_START_AUTO_CONNECTION_ESTABLISH_PROC</a></td><td><p>0xFC99</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_START_GENERAL_CONNECTION_ESTABLISH_PROC_anchor">ACI_GAP_START_GENERAL_CONNECTION_ESTABLISH_PROC</a></td><td><p>0xFC9A</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_START_SELECTIVE_CONNECTION_ESTABLISH_PROC_anchor">ACI_GAP_START_SELECTIVE_CONNECTION_ESTABLISH_PROC</a></td><td><p>0xFC9B</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_CREATE_CONNECTION_anchor">ACI_GAP_CREATE_CONNECTION</a></td><td><p>0xFC9C</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_TERMINATE_GAP_PROC_anchor">ACI_GAP_TERMINATE_GAP_PROC</a></td><td><p>0xFC9D</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_START_CONNECTION_UPDATE_anchor">ACI_GAP_START_CONNECTION_UPDATE</a></td><td><p>0xFC9E</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_SEND_PAIRING_REQ_anchor">ACI_GAP_SEND_PAIRING_REQ</a></td><td><p>0xFC9F</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_RESOLVE_PRIVATE_ADDR_anchor">ACI_GAP_RESOLVE_PRIVATE_ADDR</a></td><td><p>0xFCA0</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_SET_BROADCAST_MODE_anchor">ACI_GAP_SET_BROADCAST_MODE</a></td><td><p>0xFCA1</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_START_OBSERVATION_PROC_anchor">ACI_GAP_START_OBSERVATION_PROC</a></td><td><p>0xFCA2</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_GET_BONDED_DEVICES_anchor">ACI_GAP_GET_BONDED_DEVICES</a></td><td><p>0xFCA3</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_IS_DEVICE_BONDED_anchor">ACI_GAP_IS_DEVICE_BONDED</a></td><td><p>0xFCA4</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_NUMERIC_COMPARISON_VALUE_CONFIRM_YESNO_anchor">ACI_GAP_NUMERIC_COMPARISON_VALUE_CONFIRM_YESNO</a></td><td><p>0xFCA5</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_PASSKEY_INPUT_anchor">ACI_GAP_PASSKEY_INPUT</a></td><td><p>0xFCA6</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_GET_OOB_DATA_anchor">ACI_GAP_GET_OOB_DATA</a></td><td><p>0xFCA7</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_SET_OOB_DATA_anchor">ACI_GAP_SET_OOB_DATA</a></td><td><p>0xFCA8</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_ADD_DEVICES_TO_RESOLVING_LIST_anchor">ACI_GAP_ADD_DEVICES_TO_RESOLVING_LIST</a></td><td><p>0xFCA9</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_REMOVE_BONDED_DEVICE_anchor">ACI_GAP_REMOVE_BONDED_DEVICE</a></td><td><p>0xFCAA</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_ADD_DEVICES_TO_LIST_anchor">ACI_GAP_ADD_DEVICES_TO_LIST</a></td><td><p>0xFCAB</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_ADDITIONAL_BEACON_START_anchor">ACI_GAP_ADDITIONAL_BEACON_START</a></td><td><p>0xFCB0</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_ADDITIONAL_BEACON_STOP_anchor">ACI_GAP_ADDITIONAL_BEACON_STOP</a></td><td><p>0xFCB1</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_ADDITIONAL_BEACON_SET_DATA_anchor">ACI_GAP_ADDITIONAL_BEACON_SET_DATA</a></td><td><p>0xFCB2</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_ADV_SET_CONFIGURATION_anchor">ACI_GAP_ADV_SET_CONFIGURATION</a></td><td><p>0xFCC0</p>
</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_ADV_SET_ENABLE_anchor">ACI_GAP_ADV_SET_ENABLE</a></td><td><p>0xFCC1</p>
</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_ADV_SET_ADV_DATA_anchor">ACI_GAP_ADV_SET_ADV_DATA</a></td><td><p>0xFCC2</p>
</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_ADV_SET_SCAN_RESP_DATA_anchor">ACI_GAP_ADV_SET_SCAN_RESP_DATA</a></td><td><p>0xFCC3</p>
</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_ADV_REMOVE_SET_anchor">ACI_GAP_ADV_REMOVE_SET</a></td><td><p>0xFCC4</p>
</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_ADV_CLEAR_SETS_anchor">ACI_GAP_ADV_CLEAR_SETS</a></td><td><p>0xFCC5</p>
</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_ADV_SET_RANDOM_ADDRESS_anchor">ACI_GAP_ADV_SET_RANDOM_ADDRESS</a></td><td><p>0xFCC6</p>
</td><td></td><td></td><td></td><td></td><td></td></tr>
</table><h2><a name="ACI_GAP_SET_NON_DISCOVERABLE_anchor">ACI_GAP_SET_NON_DISCOVERABLE</a></h2><h3>Description</h3><p>Puts the device in non-discoverable mode. This command disables the LL advertising.<br>Note: this command only supports legacy advertising.</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_SET_LIMITED_DISCOVERABLE_anchor">ACI_GAP_SET_LIMITED_DISCOVERABLE</a></h2><h3>Description</h3><p>Puts the device in limited discoverable mode (as defined in Bluetooth spec. v.5.4 [Vol 3, Part C, 9.2.3]). The device will be discoverable for maximum period of TGAP (lim_adv_timeout) = 180 seconds (from errata). The advertising can be disabled at any time by issuing <a href="#ACI_GAP_SET_NON_DISCOVERABLE_anchor">ACI_GAP_SET_NON_DISCOVERABLE</a> command.<br>The Adv_Interval_Min and Adv_Interval_Max parameters are optional. If both are set to 0, the GAP will use default values for adv intervals for limited discoverable mode (250 ms and 500 ms respectively).<br>To allow a fast connection, the host can set Local_Name, Service_Uuid_List, Conn_Interval_Min and Conn_Interval_Max. If provided, these data will be inserted into the advertising packet payload as AD data. These parameters are optional in this command. These values can be set in advertised data using <a href="#ACI_GAP_UPDATE_ADV_DATA_anchor">ACI_GAP_UPDATE_ADV_DATA</a> command separately.<br>The total size of data in advertising packet cannot exceed 31 bytes.<br>With this command, the BLE Stack will also add automatically the following standard AD types:<br>- AD Flags<br>- Power Level<br>When advertising timeout happens (i.e. limited discovery period has elapsed), controller generates <a href="#ACI_GAP_LIMITED_DISCOVERABLE_EVENT_anchor">ACI_GAP_LIMITED_DISCOVERABLE_EVENT</a> event.<br>Note: this command only supports legacy advertising.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Advertising_Type</p>
</td><td><p>1</p>
</td><td><p>Advertising type</p>
</td><td><li>0x00: ADV_IND (Connectable undirected advertising)</li><li>0x02: ADV_SCAN_IND (Scannable undirected advertising)</li><li>0x03: ADV_NONCONN_IND (Non connectable undirected advertising)</li></td></tr>
<tr><td><p>Advertising_Interval_Min</p>
</td><td><p>2</p>
</td><td><p>Minimum advertising interval.
Time = N * 0.625 ms.</p>
</td><td><li>0x0020 (20.000 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>Advertising_Interval_Max</p>
</td><td><p>2</p>
</td><td><p>Maximum advertising interval.
Time = N * 0.625 ms.</p>
</td><td><li>0x0020 (20.000 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>Own_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Own address type: if Privacy is disabled, the address can be public or static random; otherwise, it can be a resolvable private address or a non-resolvable private address.</p>
</td><td><li>0x00: Public address</li><li>0x01: Static random address</li><li>0x02: Resolvable private address</li><li>0x03: Non-resolvable private address</li></td></tr>
<tr><td><p>Advertising_Filter_Policy</p>
</td><td><p>1</p>
</td><td><p>Advertising filter policy: not applicable (the value of Advertising_Filter_Policy parameter is not used inside the Stack)</p>
</td><td></tr>
<tr><td><p>Local_Name_Length</p>
</td><td><p>1</p>
</td><td><p>Length of the local_name field in octets.
If length is set to 0x00, Local_Name parameter is not used.</p>
</td><td></tr>
<tr><td><p>Local_Name</p>
</td><td><p>Local_Name_Length</p>
</td><td><p>Local name of the device. First byte must be 0x08 for Shortened Local Name or 0x09 for Complete Local Name. No NULL character at the end.</p>
</td><td></tr>
<tr><td><p>Service_Uuid_length</p>
</td><td><p>1</p>
</td><td><p>Length of the Service Uuid List in octets.
If there is no service to be advertised, set this field to 0x00.</p>
</td><td></tr>
<tr><td><p>Service_Uuid_List</p>
</td><td><p>Service_Uuid_length</p>
</td><td><p>This is the list of the UUIDs as defined in Volume 3, Section 11 of GAP Specification. First byte is the AD Type.</p>
</td><td></tr>
<tr><td><p>Conn_Interval_Min</p>
</td><td><p>2</p>
</td><td><p>Connection interval minimum value suggested by Peripheral.
If Conn_Interval_Min and Conn_Interval_Max are not 0x0000, Peripheral Connection Interval Range AD structure will be added in advertising data.
Connection interval is defined in the following manner:
connIntervalmin = Conn_Interval_Min x 1.25ms.</p>
</td><td><li>0x0000 (NaN) </li><li>0xFFFF (NaN) : No specific minimum</li><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Conn_Interval_Max</p>
</td><td><p>2</p>
</td><td><p>Connection interval maximum value suggested by Peripheral.
If Conn_Interval_Min and Conn_Interval_Max are not 0x0000, Peripheral Connection Interval Range AD structure will be added in advertising data.
Connection interval is defined in the following manner:
connIntervalmax = Conn_Interval_Max x 1.25ms</p>
</td><td><li>0x0000 (NaN) </li><li>0xFFFF (NaN) : No specific maximum</li><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_GAP_LIMITED_DISCOVERABLE_EVENT_anchor">ACI_GAP_LIMITED_DISCOVERABLE_EVENT</a></li><h2><a name="ACI_GAP_SET_DISCOVERABLE_anchor">ACI_GAP_SET_DISCOVERABLE</a></h2><h3>Description</h3><p>Puts the device in general discoverable mode (as defined in Bluetooth spec. v.5.4 [Vol 3, Part C, 9.2.4]). The device will be discoverable until the host issues the <a href="#ACI_GAP_SET_NON_DISCOVERABLE_anchor">ACI_GAP_SET_NON_DISCOVERABLE</a> command. The Adv_Interval_Min and Adv_Interval_Max parameters are optional. If both are set to 0, the GAP uses the default values for adv intervals for general discoverable mode.<br>When using connectable undirected advertising events:<br>- Adv_Interval_Min = 30 ms <br>- Adv_Interval_Max = 60 ms<br>When using non-connectable advertising events or scannable undirected advertising events:<br>- Adv_Interval_Min = 100 ms <br>- Adv_Interval_Max = 150 ms <br>Host can set the Local Name, a Service UUID list and the Peripheral Connection Interval Range.<br>If provided, these data will be inserted into the advertising packet payload as AD data.<br>These parameters are optional in this command. These values can be also set using <a href="#ACI_GAP_UPDATE_ADV_DATA_anchor">ACI_GAP_UPDATE_ADV_DATA</a> command separately.<br>The total size of data in advertising packet cannot exceed 31 bytes.<br>With this command, the BLE Stack will also add automatically the following standard AD types:<br>- AD Flags<br>- TX Power Level<br>Note: this command only supports legacy advertising.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Advertising_Type</p>
</td><td><p>1</p>
</td><td><p>Advertising type</p>
</td><td><li>0x00: ADV_IND (Connectable undirected advertising)</li><li>0x02: ADV_SCAN_IND (Scannable undirected advertising)</li><li>0x03: ADV_NONCONN_IND (Non connectable undirected advertising)</li></td></tr>
<tr><td><p>Advertising_Interval_Min</p>
</td><td><p>2</p>
</td><td><p>Minimum advertising interval.
Time = N * 0.625 ms.</p>
</td><td><li>0x0020 (20.000 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>Advertising_Interval_Max</p>
</td><td><p>2</p>
</td><td><p>Maximum advertising interval.
Time = N * 0.625 ms.</p>
</td><td><li>0x0020 (20.000 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>Own_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Own address type: if Privacy is disabled, the address can be public or static random; otherwise, it can be a resolvable private address or a non-resolvable private address.</p>
</td><td><li>0x00: Public address</li><li>0x01: Static random address</li><li>0x02: Resolvable private address</li><li>0x03: Non-resolvable private address</li></td></tr>
<tr><td><p>Advertising_Filter_Policy</p>
</td><td><p>1</p>
</td><td><p>Advertising filter policy: not applicable (the value of Advertising_Filter_Policy parameter is not used inside the Stack)</p>
</td><td></tr>
<tr><td><p>Local_Name_Length</p>
</td><td><p>1</p>
</td><td><p>Length of the local_name field in octets.
If length is set to 0x00, Local_Name parameter is not used.</p>
</td><td></tr>
<tr><td><p>Local_Name</p>
</td><td><p>Local_Name_Length</p>
</td><td><p>Local name of the device. First byte must be 0x08 for Shortened Local Name or 0x09 for Complete Local Name. No NULL character at the end.</p>
</td><td></tr>
<tr><td><p>Service_Uuid_length</p>
</td><td><p>1</p>
</td><td><p>Length of the Service Uuid List in octets.
If there is no service to be advertised, set this field to 0x00.</p>
</td><td></tr>
<tr><td><p>Service_Uuid_List</p>
</td><td><p>Service_Uuid_length</p>
</td><td><p>This is the list of the UUIDs as defined in Volume 3, Section 11 of GAP Specification. First byte is the AD Type.</p>
</td><td></tr>
<tr><td><p>Conn_Interval_Min</p>
</td><td><p>2</p>
</td><td><p>Connection interval minimum value suggested by Peripheral.
If Conn_Interval_Min and Conn_Interval_Max are not 0x0000, Peripheral Connection Interval Range AD structure will be added in advertising data.
Connection interval is defined in the following manner:
connIntervalmin = Conn_Interval_Min x 1.25ms.</p>
</td><td><li>0x0000 (NaN) </li><li>0xFFFF (NaN) : No specific minimum</li><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Conn_Interval_Max</p>
</td><td><p>2</p>
</td><td><p>Connection interval maximum value suggested by Peripheral.
If Conn_Interval_Min and Conn_Interval_Max are not 0x0000, Peripheral Connection Interval Range AD structure will be added in advertising data.
Connection interval is defined in the following manner:
connIntervalmax = Conn_Interval_Max x 1.25ms</p>
</td><td><li>0x0000 (NaN) </li><li>0xFFFF (NaN) : No specific maximum</li><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_SET_DIRECT_CONNECTABLE_anchor">ACI_GAP_SET_DIRECT_CONNECTABLE</a></h2><h3>Description</h3><p>Sets the device in directed connectable mode (as defined in Bluetooth spec. v.5.4 [Vol 3, Part C, 9.3.3]). In this mode, the device advertises using high duty cycle connectable directed advertising events or low duty cycle connectable directed advertising events.<br>The device's own address used in advertising packets is defined by the Own_Address_Type parameter depending on whether privacy is enabled or not.<br>When using high duty cycle connectable directed advertising events, the device stays in directed connectable mode only for 1.28 seconds. If no connection is established within this duration, the device enters non discoverable mode and advertising has to be again enabled explicitly.<br>The controller generates a <a href="#HCI_LE_CONNECTION_COMPLETE_EVENT_anchor">HCI_LE_CONNECTION_COMPLETE_EVENT</a> event with the status set to HCI_ADVERTISING_TIMEOUT_ERR_CODE if the connection was not established and BLE_STATUS_SUCCESS (0x00) if the connection was successfully established.<br>Note: this command only supports legacy advertising.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Own_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Own address type: if Privacy is disabled, the address can be public or static random; otherwise, it can be a resolvable private address.</p>
</td><td><li>0x00: Public address</li><li>0x01: Static random address</li><li>0x02: Resolvable private address</li></td></tr>
<tr><td><p>Directed_Advertising_Type</p>
</td><td><p>1</p>
</td><td><p>Advertising type</p>
</td><td><li>0x01: High Duty Cycle Directed Advertising</li><li>0x04: Low Duty Cycle Directed Advertising</li></td></tr>
<tr><td><p>Direct_Address_Type</p>
</td><td><p>1</p>
</td><td><p>The address type of the peer device.</p>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li></td></tr>
<tr><td><p>Direct_Address</p>
</td><td><p>6</p>
</td><td><p>Initiator address</p>
</td><td></tr>
<tr><td><p>Advertising_Interval_Min</p>
</td><td><p>2</p>
</td><td><p>Minimum advertising interval.
Time = N * 0.625 ms.</p>
</td><td><li>0x0006 (3.750 ms) : for High Duty Cycle Directed Advertising</li><li>0x0020 (20.000 ms)  ... 0x4000 (10240.000 ms) : for Low Duty Cycle Directed Advertising</li></td></tr>
<tr><td><p>Advertising_Interval_Max</p>
</td><td><p>2</p>
</td><td><p>Maximum advertising interval.
Time = N * 0.625 ms.</p>
</td><td><li>0x0006 (3.750 ms) : for High Duty Cycle Directed Advertising</li><li>0x0020 (20.000 ms)  ... 0x4000 (10240.000 ms) : for Low Duty Cycle Directed Advertising</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><li><a href="#HCI_LE_CONNECTION_COMPLETE_EVENT_anchor">HCI_LE_CONNECTION_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_SET_IO_CAPABILITY_anchor">ACI_GAP_SET_IO_CAPABILITY</a></h2><h3>Description</h3><p>Sets the IO capabilities of the device. This command has to be given only when the device is not in a connected state.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>IO_Capability</p>
</td><td><p>1</p>
</td><td><p>IO capability of the device.</p>
</td><td><li>0x00: IO_CAP_DISPLAY_ONLY</li><li>0x01: IO_CAP_DISPLAY_YES_NO</li><li>0x02: IO_CAP_KEYBOARD_ONLY</li><li>0x03: IO_CAP_NO_INPUT_NO_OUTPUT</li><li>0x04: IO_CAP_KEYBOARD_DISPLAY</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_SET_AUTHENTICATION_REQUIREMENT_anchor">ACI_GAP_SET_AUTHENTICATION_REQUIREMENT</a></h2><h3>Description</h3><p>Sets the authentication requirements for the device. This command has to be given only when the device is not in a connected state.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Bonding_Mode</p>
</td><td><p>1</p>
</td><td><p>Bonding mode.
Only if bonding is enabled (0x01), the bonding information is stored in flash</p>
</td><td><li>0x00: No-bonding mode</li><li>0x01: Bonding mode</li></td></tr>
<tr><td><p>MITM_Mode</p>
</td><td><p>1</p>
</td><td><p>MITM mode.</p>
</td><td><li>0x00: MITM protection not required</li><li>0x01: MITM protection required</li></td></tr>
<tr><td><p>SC_Support</p>
</td><td><p>1</p>
</td><td><p>LE Secure connections support</p>
</td><td><li>0x00: Secure Connections Pairing not supported</li><li>0x01: Secure Connections Pairing supported but optional</li><li>0x02: Secure Connections Pairing supported and mandatory (SC Only Mode)</li></td></tr>
<tr><td><p>KeyPress_Notification_Support</p>
</td><td><p>1</p>
</td><td><p>Keypress notification support</p>
</td><td><li>0x00: Keypress notification not supported</li><li>0x01: Keypress notification supported</li></td></tr>
<tr><td><p>Min_Encryption_Key_Size</p>
</td><td><p>1</p>
</td><td><p>Minimum encryption key size to be used during pairing</p>
</td><td></tr>
<tr><td><p>Max_Encryption_Key_Size</p>
</td><td><p>1</p>
</td><td><p>Maximum encryption key size to be used during pairing</p>
</td><td></tr>
<tr><td><p>Use_Fixed_Pin</p>
</td><td><p>1</p>
</td><td><p>Use or not fixed pin. If set to 0x00, then during the pairing process the application will not be requested for a pin (Fixed_Pin will be used).
If set to 0x01, then during pairing process if a passkey is required the application will be notified</p>
</td><td><li>0x00: use a fixed pin</li><li>0x01: do not use a fixed pin</li></td></tr>
<tr><td><p>Fixed_Pin</p>
</td><td><p>4</p>
</td><td><p>Fixed pin to be used during pairing if MITM protection is enabled.
Any random value between 0 to 999999</p>
</td><td><li>0 ... 999999</li></td></tr>
<tr><td><p>Identity_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Identity address type</p>
</td><td><li>0x00: Public Identity Address</li><li>0x01: Random (static) Identity Address</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_SET_AUTHORIZATION_REQUIREMENT_anchor">ACI_GAP_SET_AUTHORIZATION_REQUIREMENT</a></h2><h3>Description</h3><p>Sets the authorization requirements of the device. This command has to be given when connected to a device if authorization is required to access services which require authorization.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Authorization_Enable</p>
</td><td><p>1</p>
</td><td><p>Enable the authorization in the device and when a remote device tries to read/write a characteristic with authorization requirements, the stack will send back an error response with &quot;Insufficient authorization&quot; error code. After pairing is complete an ACI_GAP_AUTHORIZATION_REQ_EVENT will be sent to the Host.</p>
</td><td><li>0x00: Authorization not required</li><li>0x01: Authorization required</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_PASS_KEY_RESP_anchor">ACI_GAP_PASS_KEY_RESP</a></h2><h3>Description</h3><p>This command should be sent by the host in response to <a href="#ACI_GAP_PASS_KEY_REQ_EVENT_anchor">ACI_GAP_PASS_KEY_REQ_EVENT</a> event. The command parameter contains the pass key which will be used during the pairing process.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Pass_Key</p>
</td><td><p>4</p>
</td><td><p>Pass key that will be used during the pairing process.
Must be a six-digit decimal number.</p>
</td><td><li>0 ... 999999</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><li><a href="#ACI_GAP_PAIRING_COMPLETE_EVENT_anchor">ACI_GAP_PAIRING_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_AUTHORIZATION_RESP_anchor">ACI_GAP_AUTHORIZATION_RESP</a></h2><h3>Description</h3><p>Authorizes a device to access attributes. This command should be sent by the host in response to <a href="#ACI_GAP_AUTHORIZATION_REQ_EVENT_anchor">ACI_GAP_AUTHORIZATION_REQ_EVENT</a> event.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Authorize</p>
</td><td><p>1</p>
</td><td><p>Authorization response.</p>
</td><td><li>0x01: Authorize</li><li>0x02: Reject</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_INIT_anchor">ACI_GAP_INIT</a></h2><h3>Description</h3><p>Initializes the GAP layer. Register the GAP service with the GATT.<br>All the standard GAP characteristics will also be added:<br>- Device Name<br>- Appearance<br>- Peripheral Preferred Connection Parameters (peripheral role only).<br>Note that if the Peripheral Preferred Connection Parameters characteristic is added, its handle is equal to the Appearance characteristic handle plus 2.<br>Note also that if privacy is enabled, this command automatically unmasks the <a href="#HCI_LE_ENHANCED_CONNECTION_COMPLETE_EVENT_anchor">HCI_LE_ENHANCED_CONNECTION_COMPLETE_EVENT</a> event.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Role</p>
</td><td><p>1</p>
</td><td><p>Bitmap of allowed roles.</p>
</td><td><p>Bitmask of:</p><li>0x01: Peripheral</li><li>0x02: Broadcaster</li><li>0x04: Central</li><li>0x08: Observer</li></td></tr>
<tr><td><p>privacy_enabled</p>
</td><td><p>1</p>
</td><td><p>This parameter specifies if Privacy is enabled or not. N.B.: only Controller Privacy is supported.</p>
</td><td><li>0x00: Privacy disabled</li><li>0x02: Privacy enabled</li></td></tr>
<tr><td><p>device_name_char_len</p>
</td><td><p>1</p>
</td><td><p>Length of the device name characteristic</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Service_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the GAP service</p>
</td><td></tr>
<tr><td><p>Dev_Name_Char_Handle</p>
</td><td><p>2</p>
</td><td><p>Device Name Characteristic handle</p>
</td><td></tr>
<tr><td><p>Appearance_Char_Handle</p>
</td><td><p>2</p>
</td><td><p>Appearance Characteristic handle</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_SET_NON_CONNECTABLE_anchor">ACI_GAP_SET_NON_CONNECTABLE</a></h2><h3>Description</h3><p>Puts the device into non connectable mode. This mode does not support connection. The privacy setting done in the <a href="#ACI_GAP_INIT_anchor">ACI_GAP_INIT</a> command plays a role in deciding the valid parameters for this command.<br>Advertiser filter policy is internally set to 0.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Advertising_Event_Type</p>
</td><td><p>1</p>
</td><td><p>Advertising type</p>
</td><td><li>0x02: ADV_SCAN_IND (Scannable undirected advertising)</li><li>0x03: ADV_NONCONN_IND (Non connectable undirected advertising)</li></td></tr>
<tr><td><p>Own_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Own address type: if Privacy is disabled, the address can be public or static random; otherwise, it can be a resolvable private address or a non-resolvable private address.</p>
</td><td><li>0x00: Public address</li><li>0x01: Static random address</li><li>0x02: Resolvable private address</li><li>0x03: Non-resolvable private address</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_SET_UNDIRECTED_CONNECTABLE_anchor">ACI_GAP_SET_UNDIRECTED_CONNECTABLE</a></h2><h3>Description</h3><p>Puts the device into undirected connectable mode.<br>If privacy is enabled in the device, a resolvable private address is generated and used as the advertiser's address. If not, the address of the type specified in Own_Address_Type is used for advertising.<br>Note: this command only supports legacy advertising.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Advertising_Interval_Min</p>
</td><td><p>2</p>
</td><td><p>Minimum advertising interval.
Time = N * 0.625 ms.</p>
</td><td><li>0x0020 (20.000 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>Advertising_Interval_Max</p>
</td><td><p>2</p>
</td><td><p>Maximum advertising interval.
Time = N * 0.625 ms.</p>
</td><td><li>0x0020 (20.000 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>Own_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Own address type: if Privacy is disabled, the address can be public or static random; otherwise, it can be a resolvable private address.</p>
</td><td><li>0x00: Public address</li><li>0x01: Static random address</li><li>0x02: Resolvable private address</li></td></tr>
<tr><td><p>Adv_Filter_Policy</p>
</td><td><p>1</p>
</td><td><p>Advertising filter policy.</p>
</td><td><li>0x00: Allow Scan Request from Any, Allow Connect Request from Any</li><li>0x03: Allow Scan Request from Filter Accept List Only, Allow Connect Request from Filter Accept List Only</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_PERIPHERAL_SECURITY_REQ_anchor">ACI_GAP_PERIPHERAL_SECURITY_REQ</a></h2><h3>Description</h3><p>Sends a Peripheral Security Request to the Central.<br>This command has to be issued to notify the Central of the security requirements of the Peripheral. The Central may encrypt the link, initiate the pairing procedure, or reject the request.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_GAP_PERIPHERAL_SECURITY_INITIATED_EVENT_anchor">ACI_GAP_PERIPHERAL_SECURITY_INITIATED_EVENT</a></li><h2><a name="ACI_GAP_UPDATE_ADV_DATA_anchor">ACI_GAP_UPDATE_ADV_DATA</a></h2><h3>Description</h3><p>This command can be used to update the advertising data for a particular AD type. If the AD type specified does not exist, then it is added to the advertising data. If the overall advertising data length is more than 31 octets after the update, then the command is rejected and the old data is retained.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>AdvDataLen</p>
</td><td><p>1</p>
</td><td><p>Length of AdvData in octets</p>
</td><td></tr>
<tr><td><p>AdvData</p>
</td><td><p>AdvDataLen</p>
</td><td><p>Advertising data used by the device while advertising.</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_DELETE_AD_TYPE_anchor">ACI_GAP_DELETE_AD_TYPE</a></h2><h3>Description</h3><p>This command can be used to delete the specified AD type from the advertisement data if present.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>ADType</p>
</td><td><p>1</p>
</td><td><p>One of the AD types as in Bluetooth spec. [Vol 3, Part C, 11].</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_GET_SECURITY_LEVEL_anchor">ACI_GAP_GET_SECURITY_LEVEL</a></h2><h3>Description</h3><p>This command can be used to get the current security settings of the device.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Security_Mode</p>
</td><td><p>1</p>
</td><td><p>Security mode.</p>
</td><td><li>0x01: Security Mode 1</li></td></tr>
<tr><td><p>Security_Level</p>
</td><td><p>1</p>
</td><td><p>Security Level.</p>
</td><td><li>0x01: Security Level 1</li><li>0x02: Security Level 2</li><li>0x03: Security Level 3</li><li>0x04: Security Level 4</li></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_SET_EVENT_MASK_anchor">ACI_GAP_SET_EVENT_MASK</a></h2><h3>Description</h3><p>It allows masking events from the GAP. If the bit in the GAP_Evt_Mask is set to a one, then the event associated with that bit will be enabled.<br>The default configuration is all the events masked.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>GAP_Evt_Mask</p>
</td><td><p>2</p>
</td><td><p>GAP event mask. Default: 0xFFFF.</p>
</td><td><p>Bitmask of:</p><li>0x0000: No events</li><li>0x0001: ACI_GAP_LIMITED_DISCOVERABLE_EVENT</li><li>0x0002: ACI_GAP_PAIRING_COMPLETE_EVENT</li><li>0x0004: ACI_GAP_PASS_KEY_REQ_EVENT</li><li>0x0008: ACI_GAP_AUTHORIZATION_REQ_EVENT</li><li>0x0010: ACI_GAP_PERIPHERAL_SECURITY_INITIATED_EVENT</li><li>0x0020: ACI_GAP_BOND_LOST_EVENT</li><li>0x0080: ACI_GAP_PROC_COMPLETE_EVENT</li><li>0x0100: ACI_L2CAP_CONNECTION_UPDATE_REQ_EVENT</li><li>0x0200: ACI_L2CAP_CONNECTION_UPDATE_RESP_EVENT</li><li>0x0400: ACI_L2CAP_PROC_TIMEOUT_EVENT</li><li>0x0800: ACI_GAP_ADDR_NOT_RESOLVED_EVENT</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_CONFIGURE_FILTER_ACCEPT_LIST_anchor">ACI_GAP_CONFIGURE_FILTER_ACCEPT_LIST</a></h2><h3>Description</h3><p>This command adds addresses of bonded devices into the controller's Filter Accept List, which is cleared first. It returns an error if it was unable to add all bonded devices into the Filter Accept List.<br>This command shall not be used when the device is advertising, scanning or initiating with a filter policy using the Filter Accept List.</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_TERMINATE_anchor">ACI_GAP_TERMINATE</a></h2><h3>Description</h3><p>Commands the controller to terminate the connection. A <a href="#HCI_DISCONNECTION_COMPLETE_EVENT_anchor">HCI_DISCONNECTION_COMPLETE_EVENT</a> event is generated when the link is disconnected.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Reason</p>
</td><td><p>1</p>
</td><td><p>The reason for ending the connection.</p>
</td><td><li>0x05: Authentication Failure</li><li>0x13: Remote User Terminated Connection</li><li>0x14: Remote Device Terminated Connection due to Low Resources</li><li>0x15: Remote Device Terminated Connection due to Power Off</li><li>0x1A: Unsupported Remote Feature</li><li>0x3B: Unacceptable Connection Parameters</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#HCI_DISCONNECTION_COMPLETE_EVENT_anchor">HCI_DISCONNECTION_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_CLEAR_SECURITY_DB_anchor">ACI_GAP_CLEAR_SECURITY_DB</a></h2><h3>Description</h3><p>Clears the bonding table. All the devices in the bonding table are removed.<br>See also <a href="#ACI_GAP_REMOVE_BONDED_DEVICE_anchor">ACI_GAP_REMOVE_BONDED_DEVICE</a> to remove only one device.<br>Note: as a fallback mode, in case the bonding table is full, the BLE stack automatically clears the bonding table just before putting into it information about a new bonded device.</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_ALLOW_REBOND_anchor">ACI_GAP_ALLOW_REBOND</a></h2><h3>Description</h3><p>Allows the security manager to complete the pairing procedure and re-bond with the Central. This command should be given by the application when it receives the ACI_GAP_BOND_LOST_EVENT if it wants the re-bonding to happen successfully. If this command is not given on receiving the event, the bonding procedure will timeout.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_START_LIMITED_DISCOVERY_PROC_anchor">ACI_GAP_START_LIMITED_DISCOVERY_PROC</a></h2><h3>Description</h3><p>Starts the limited discovery procedure. The controller is commanded to start active scanning.<br>When this procedure is started, only the devices in limited discoverable mode are returned to the upper layers.<br>The procedure is terminated when either the upper layers issue a command to terminate the procedure by issuing the command <a href="#ACI_GAP_TERMINATE_GAP_PROC_anchor">ACI_GAP_TERMINATE_GAP_PROC</a> with the procedure code set to 0x01 or a timeout happens (the timeout value is fixed at 10.24 s.). When the procedure is terminated due to any of the above  reasons, <a href="#ACI_GAP_PROC_COMPLETE_EVENT_anchor">ACI_GAP_PROC_COMPLETE_EVENT</a> event is returned with the procedure code set to 0x01.<br>The device found when the procedure is ongoing is returned to the upper layers through the event <a href="#HCI_LE_ADVERTISING_REPORT_EVENT_anchor">HCI_LE_ADVERTISING_REPORT_EVENT</a>.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>LE_Scan_Interval</p>
</td><td><p>2</p>
</td><td><p>This is defined as the time interval from when the Controller started its last LE scan until it begins the subsequent LE scan.
Time = N * 0.625 ms.</p>
</td><td><li>0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>LE_Scan_Window</p>
</td><td><p>2</p>
</td><td><p>Amount of time for the duration of the LE scan. LE_Scan_Window shall be less than or equal to LE_Scan_Interval.
Time = N * 0.625 ms.</p>
</td><td><li>0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>Own_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Own address type: if Privacy is disabled, the address can be public or static random; otherwise, it can be a resolvable private address or a non-resolvable private address.</p>
</td><td><li>0x00: Public address</li><li>0x01: Static random address</li><li>0x02: Resolvable private address</li><li>0x03: Non-resolvable private address</li></td></tr>
<tr><td><p>Filter_Duplicates</p>
</td><td><p>1</p>
</td><td><p>Enable/disable duplicate filtering.</p>
</td><td><li>0x00: Duplicate filtering disabled</li><li>0x01: Duplicate filtering enabled</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#HCI_LE_ADVERTISING_REPORT_EVENT_anchor">HCI_LE_ADVERTISING_REPORT_EVENT</a></li><li><a href="#ACI_GAP_PROC_COMPLETE_EVENT_anchor">ACI_GAP_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_START_GENERAL_DISCOVERY_PROC_anchor">ACI_GAP_START_GENERAL_DISCOVERY_PROC</a></h2><h3>Description</h3><p>Starts the general discovery procedure. The controller is commanded to start active scanning. The procedure is terminated when  either the upper layers issue a command to terminate the procedure by issuing the command <a href="#ACI_GAP_TERMINATE_GAP_PROC_anchor">ACI_GAP_TERMINATE_GAP_PROC</a> with the procedure code set to 0x02 or a timeout happens (the timeout value is fixed at 10.24 s.). When the procedure is terminated due to any of the above reasons, <a href="#ACI_GAP_PROC_COMPLETE_EVENT_anchor">ACI_GAP_PROC_COMPLETE_EVENT</a> event is returned with the procedure code set to 0x02.<br>The devices found when the procedure is ongoing are returned via <a href="#HCI_LE_ADVERTISING_REPORT_EVENT_anchor">HCI_LE_ADVERTISING_REPORT_EVENT</a> (or via <a href="#HCI_LE_EXTENDED_ADVERTISING_REPORT_EVENT_anchor">HCI_LE_EXTENDED_ADVERTISING_REPORT_EVENT</a> when the extended advertising feature is supported).</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>LE_Scan_Interval</p>
</td><td><p>2</p>
</td><td><p>This is defined as the time interval from when the Controller started its last LE scan until it begins the subsequent LE scan.
Time = N * 0.625 ms.</p>
</td><td><li>0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) : legacy advertising</li><li>0x0004 (2.500 ms)  ... 0x5DC0 (15000.000 ms) : extended advertising with STM32WB</li><li>0x0004 (2.500 ms)  ... 0xFFFF (40959.375 ms) : extended advertising with STM32WBA</li></td></tr>
<tr><td><p>LE_Scan_Window</p>
</td><td><p>2</p>
</td><td><p>Amount of time for the duration of the LE scan. LE_Scan_Window shall be less than or equal to LE_Scan_Interval.
Time = N * 0.625 ms.</p>
</td><td><li>0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) : legacy advertising</li><li>0x0004 (2.500 ms)  ... 0x5DC0 (15000.000 ms) : extended advertising with STM32WB</li><li>0x0004 (2.500 ms)  ... 0xFFFF (40959.375 ms) : extended advertising with STM32WBA</li></td></tr>
<tr><td><p>Own_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Own address type: if Privacy is disabled, the address can be public or static random; otherwise, it can be a resolvable private address or a non-resolvable private address.</p>
</td><td><li>0x00: Public address</li><li>0x01: Static random address</li><li>0x02: Resolvable private address</li><li>0x03: Non-resolvable private address</li></td></tr>
<tr><td><p>Filter_Duplicates</p>
</td><td><p>1</p>
</td><td><p>Enable/disable duplicate filtering.</p>
</td><td><li>0x00: Duplicate filtering disabled</li><li>0x01: Duplicate filtering enabled</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#HCI_LE_ADVERTISING_REPORT_EVENT_anchor">HCI_LE_ADVERTISING_REPORT_EVENT</a></li><li><a href="#HCI_LE_EXTENDED_ADVERTISING_REPORT_EVENT_anchor">HCI_LE_EXTENDED_ADVERTISING_REPORT_EVENT</a></li><li><a href="#ACI_GAP_PROC_COMPLETE_EVENT_anchor">ACI_GAP_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_START_AUTO_CONNECTION_ESTABLISH_PROC_anchor">ACI_GAP_START_AUTO_CONNECTION_ESTABLISH_PROC</a></h2><h3>Description</h3><p>Starts the auto connection establishment procedure. The devices specified are added to the Filter Accept List of the controller and a LE_Create_Connection call will be made to the controller by GAP with the initiator filter policy set to "Filter Accept List is used to determine which advertiser to connect to". When a command is issued to terminate the procedure by upper layer, a LE_Create_Connection_Cancel call will be made to the controller by GAP.<br>The procedure is terminated when either a connection is successfully established with one of the specified devices in the Filter Accept List or the procedure is explicitly terminated by issuing the command <a href="#ACI_GAP_TERMINATE_GAP_PROC_anchor">ACI_GAP_TERMINATE_GAP_PROC</a> with the procedure code set to 0x08. A <a href="#ACI_GAP_PROC_COMPLETE_EVENT_anchor">ACI_GAP_PROC_COMPLETE_EVENT</a> event is returned with the procedure code set to 0x08.<br>If privacy is enabled and the peer device (advertiser) is in the resolving list then the link layer generates a RPA, if it is not then the RPA generated by the Host is used.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>LE_Scan_Interval</p>
</td><td><p>2</p>
</td><td><p>This is defined as the time interval from when the Controller started its last LE scan until it begins the subsequent LE scan.
Time = N * 0.625 ms.</p>
</td><td><li>0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) : legacy advertising</li><li>0x0004 (2.500 ms)  ... 0x5DC0 (15000.000 ms) : extended advertising with STM32WB</li><li>0x0004 (2.500 ms)  ... 0xFFFF (40959.375 ms) : extended advertising with STM32WBA</li></td></tr>
<tr><td><p>LE_Scan_Window</p>
</td><td><p>2</p>
</td><td><p>Amount of time for the duration of the LE scan. LE_Scan_Window shall be less than or equal to LE_Scan_Interval.
Time = N * 0.625 ms.</p>
</td><td><li>0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) : legacy advertising</li><li>0x0004 (2.500 ms)  ... 0x5DC0 (15000.000 ms) : extended advertising with STM32WB</li><li>0x0004 (2.500 ms)  ... 0xFFFF (40959.375 ms) : extended advertising with STM32WBA</li></td></tr>
<tr><td><p>Own_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Own address type: if Privacy is disabled, the address can be public or static random; otherwise, it can be a resolvable private address.</p>
</td><td><li>0x00: Public address</li><li>0x01: Static random address</li><li>0x02: Resolvable private address</li></td></tr>
<tr><td><p>Conn_Interval_Min</p>
</td><td><p>2</p>
</td><td><p>Minimum value for the connection event interval.
Time = N * 1.25 ms.</p>
</td><td><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Conn_Interval_Max</p>
</td><td><p>2</p>
</td><td><p>Maximum value for the connection event interval.
Time = N * 1.25 ms.</p>
</td><td><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Conn_Latency</p>
</td><td><p>2</p>
</td><td><p>Maximum Peripheral latency for the connection in number of connection events.</p>
</td><td><li>0x0000 ... 0x01F3</li></td></tr>
<tr><td><p>Supervision_Timeout</p>
</td><td><p>2</p>
</td><td><p>Supervision timeout for the LE Link.
It shall be a multiple of 10 ms and larger than (1 + connPeripheralLatency) * connInterval * 2.
Time = N * 10 ms.</p>
</td><td><li>0x000A (100 ms)  ... 0x0C80 (32000 ms) </li></td></tr>
<tr><td><p>Minimum_CE_Length</p>
</td><td><p>2</p>
</td><td><p>Information parameter about the minimum length of connection needed for this LE connection.
Time = N * 0.625 ms.</p>
</td><td><li>0x0000 (0.000 ms)  ... 0xFFFF (40959.375 ms) </li></td></tr>
<tr><td><p>Maximum_CE_Length</p>
</td><td><p>2</p>
</td><td><p>Information parameter about the maximum length of connection needed for this LE connection.
Time = N * 0.625 ms.</p>
</td><td><li>0x0000 (0.000 ms)  ... 0xFFFF (40959.375 ms) </li></td></tr>
<tr><td><p>Num_of_Peer_Entries</p>
</td><td><p>1</p>
</td><td><p>Number of devices that have to be added to the Filter Accept List. Each device is defined by Peer_Address_Type and Peer_Address.</p>
</td><td></tr>
<tr><td><p>Peer_Address_Type[i]</p>
</td><td><p>1</p>
</td><td><p>Address type.</p>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li></td></tr>
<tr><td><p>Peer_Address[i]</p>
</td><td><p>6</p>
</td><td><p>Public Device Address or Random Device Address.</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_GAP_PROC_COMPLETE_EVENT_anchor">ACI_GAP_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_START_GENERAL_CONNECTION_ESTABLISH_PROC_anchor">ACI_GAP_START_GENERAL_CONNECTION_ESTABLISH_PROC</a></h2><h3>Description</h3><p>Starts a general connection establishment procedure. The host enables scanning in the controller with the scanner filter policy set to "accept all advertising packets" and from the scanning results, all the devices are sent to the upper layer using the event LE_Advertising_Report. The upper layer then has to select one of the devices to which it wants to connect by issuing the command <a href="#ACI_GAP_CREATE_CONNECTION_anchor">ACI_GAP_CREATE_CONNECTION</a>. If privacy is enabled, then either a private resolvable address or a non-resolvable address, based on the address type specified in the command is set as the scanner address but the gap create connection always uses a private resolvable address if the general connection establishment procedure is active.<br>The procedure is terminated when a connection is established or the upper layer terminates the procedure by issuing the command <a href="#ACI_GAP_TERMINATE_GAP_PROC_anchor">ACI_GAP_TERMINATE_GAP_PROC</a> with the procedure code set to 0x10. On completion of the procedure a <a href="#ACI_GAP_PROC_COMPLETE_EVENT_anchor">ACI_GAP_PROC_COMPLETE_EVENT</a> event is generated with the procedure code set to 0x10.<br>If privacy is enabled and the peer device (advertiser) is in the resolving list then the link layer will generate a RPA, if it is not then the RPA/NRPA generated by the Host will be used.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>LE_Scan_Type</p>
</td><td><p>1</p>
</td><td><p>Passive or active scanning. With passive scanning, no scan request PDUs are sent.</p>
</td><td><li>0x00: Passive scanning</li><li>0x01: Active scanning</li></td></tr>
<tr><td><p>LE_Scan_Interval</p>
</td><td><p>2</p>
</td><td><p>This is defined as the time interval from when the Controller started its last LE scan until it begins the subsequent LE scan.
Time = N * 0.625 ms.</p>
</td><td><li>0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) : legacy advertising</li><li>0x0004 (2.500 ms)  ... 0x5DC0 (15000.000 ms) : extended advertising with STM32WB</li><li>0x0004 (2.500 ms)  ... 0xFFFF (40959.375 ms) : extended advertising with STM32WBA</li></td></tr>
<tr><td><p>LE_Scan_Window</p>
</td><td><p>2</p>
</td><td><p>Amount of time for the duration of the LE scan. LE_Scan_Window shall be less than or equal to LE_Scan_Interval.
Time = N * 0.625 ms.</p>
</td><td><li>0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) : legacy advertising</li><li>0x0004 (2.500 ms)  ... 0x5DC0 (15000.000 ms) : extended advertising with STM32WB</li><li>0x0004 (2.500 ms)  ... 0xFFFF (40959.375 ms) : extended advertising with STM32WBA</li></td></tr>
<tr><td><p>Own_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Own address type: if Privacy is disabled, the address can be public or static random; otherwise, it can be a resolvable private address or a non-resolvable private address.</p>
</td><td><li>0x00: Public address</li><li>0x01: Static random address</li><li>0x02: Resolvable private address</li><li>0x03: Non-resolvable private address</li></td></tr>
<tr><td><p>Scanning_Filter_Policy</p>
</td><td><p>1</p>
</td><td><p>The scanning filter policy determines how the scanner's Link Layer processes advertising and scan response PDUs.
There is a choice of two primary filter policies: unfiltered and filtered.
Unfiltered: the Link Layer processes all advertising and scan response PDUs (i.e., the Filter Accept List is not used).
Filtered: the Link Layer processes advertising and scan response PDUs only from devices in the Filter Accept List.
With extended scanning filter policies, a directed advertising PDU accepted by the primary filter policy shall nevertheless be ignored unless either the TargetA field is identical to the scanner's device address, or TargetA field is a resolvable private address.</p>
</td><td><li>0x00: Basic unfiltered scanning filter policy</li><li>0x01: Basic filtered scanning filter policy</li><li>0x02: Extended unfiltered scanning filter policy</li><li>0x03: Extended filtered scanning filter policy</li></td></tr>
<tr><td><p>Filter_Duplicates</p>
</td><td><p>1</p>
</td><td><p>Enable/disable duplicate filtering.</p>
</td><td><li>0x00: Duplicate filtering disabled</li><li>0x01: Duplicate filtering enabled</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_GAP_PROC_COMPLETE_EVENT_anchor">ACI_GAP_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_START_SELECTIVE_CONNECTION_ESTABLISH_PROC_anchor">ACI_GAP_START_SELECTIVE_CONNECTION_ESTABLISH_PROC</a></h2><h3>Description</h3><p>Starts a selective connection establishment procedure. The GAP adds the specified device addresses into Filter Accept List and enables scanning in the controller with a scanning filter policy that should be set to "filtered". All the devices found are sent to the upper layer by the event <a href="#HCI_LE_ADVERTISING_REPORT_EVENT_anchor">HCI_LE_ADVERTISING_REPORT_EVENT</a> (or by the event <a href="#HCI_LE_EXTENDED_ADVERTISING_REPORT_EVENT_anchor">HCI_LE_EXTENDED_ADVERTISING_REPORT_EVENT</a> when the extended advertising feature is supported). The upper layer then has to select one of the devices to which it wants to connect by issuing the command <a href="#ACI_GAP_CREATE_CONNECTION_anchor">ACI_GAP_CREATE_CONNECTION</a>.<br>On completion of the procedure a <a href="#ACI_GAP_PROC_COMPLETE_EVENT_anchor">ACI_GAP_PROC_COMPLETE_EVENT</a> event is generated with the procedure code set to 0x20. The procedure is terminated when a connection is established or the upper layer terminates the procedure by issuing the command <a href="#ACI_GAP_TERMINATE_GAP_PROC_anchor">ACI_GAP_TERMINATE_GAP_PROC</a> with the procedure code set to 0x20.<br>If privacy is enabled and the peer device (advertiser) is in the resolving list then the link layer will generate a RPA, if it is not then the RPA/NRPA generated by the Host will be used.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>LE_Scan_Type</p>
</td><td><p>1</p>
</td><td><p>Passive or active scanning. With passive scanning, no scan request PDUs are sent.</p>
</td><td><li>0x00: Passive scanning</li><li>0x01: Active scanning</li></td></tr>
<tr><td><p>LE_Scan_Interval</p>
</td><td><p>2</p>
</td><td><p>This is defined as the time interval from when the Controller started its last LE scan until it begins the subsequent LE scan.
Time = N * 0.625 ms.</p>
</td><td><li>0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) : legacy advertising</li><li>0x0004 (2.500 ms)  ... 0x5DC0 (15000.000 ms) : extended advertising with STM32WB</li><li>0x0004 (2.500 ms)  ... 0xFFFF (40959.375 ms) : extended advertising with STM32WBA</li></td></tr>
<tr><td><p>LE_Scan_Window</p>
</td><td><p>2</p>
</td><td><p>Amount of time for the duration of the LE scan. LE_Scan_Window shall be less than or equal to LE_Scan_Interval.
Time = N * 0.625 ms.</p>
</td><td><li>0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) : legacy advertising</li><li>0x0004 (2.500 ms)  ... 0x5DC0 (15000.000 ms) : extended advertising with STM32WB</li><li>0x0004 (2.500 ms)  ... 0xFFFF (40959.375 ms) : extended advertising with STM32WBA</li></td></tr>
<tr><td><p>Own_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Own address type: if Privacy is disabled, the address can be public or static random; otherwise, it can be a resolvable private address or a non-resolvable private address.</p>
</td><td><li>0x00: Public address</li><li>0x01: Static random address</li><li>0x02: Resolvable private address</li><li>0x03: Non-resolvable private address</li></td></tr>
<tr><td><p>Scanning_Filter_Policy</p>
</td><td><p>1</p>
</td><td><p>The scanning filter policy determines how the scanner's Link Layer processes advertising and scan response PDUs.
There is a choice of two primary filter policies: unfiltered and filtered.
Unfiltered: the Link Layer processes all advertising and scan response PDUs (i.e., the Filter Accept List is not used).
Filtered: the Link Layer processes advertising and scan response PDUs only from devices in the Filter Accept List.
With extended scanning filter policies, a directed advertising PDU accepted by the primary filter policy shall nevertheless be ignored unless either the TargetA field is identical to the scanner's device address, or TargetA field is a resolvable private address.</p>
</td><td><li>0x00: Basic unfiltered scanning filter policy</li><li>0x01: Basic filtered scanning filter policy</li><li>0x02: Extended unfiltered scanning filter policy</li><li>0x03: Extended filtered scanning filter policy</li></td></tr>
<tr><td><p>Filter_Duplicates</p>
</td><td><p>1</p>
</td><td><p>Enable/disable duplicate filtering.</p>
</td><td><li>0x00: Duplicate filtering disabled</li><li>0x01: Duplicate filtering enabled</li></td></tr>
<tr><td><p>Num_of_Peer_Entries</p>
</td><td><p>1</p>
</td><td><p>Number of devices that have to be added to the Filter Accept List. Each device is defined by Peer_Address_Type and Peer_Address.</p>
</td><td></tr>
<tr><td><p>Peer_Address_Type[i]</p>
</td><td><p>1</p>
</td><td><p>Address type.</p>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li></td></tr>
<tr><td><p>Peer_Address[i]</p>
</td><td><p>6</p>
</td><td><p>Public Device Address or Random Device Address.</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#HCI_LE_ADVERTISING_REPORT_EVENT_anchor">HCI_LE_ADVERTISING_REPORT_EVENT</a></li><li><a href="#HCI_LE_EXTENDED_ADVERTISING_REPORT_EVENT_anchor">HCI_LE_EXTENDED_ADVERTISING_REPORT_EVENT</a></li><li><a href="#ACI_GAP_PROC_COMPLETE_EVENT_anchor">ACI_GAP_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_CREATE_CONNECTION_anchor">ACI_GAP_CREATE_CONNECTION</a></h2><h3>Description</h3><p>Starts the direct connection establishment procedure. A LE_Create_Connection call will be made to the controller by GAP with the initiator filter policy set to "Filter Accept List is not used to determine which advertiser to connect to". The procedure can be terminated explicitly by the upper layer by issuing the command <a href="#ACI_GAP_TERMINATE_GAP_PROC_anchor">ACI_GAP_TERMINATE_GAP_PROC</a>. When a command is issued to terminate the procedure by upper layer, a <a href="#HCI_LE_CREATE_CONNECTION_CANCEL_anchor">HCI_LE_CREATE_CONNECTION_CANCEL</a> call will be made to the controller by GAP.<br>On termination of the procedure, a <a href="#HCI_LE_CONNECTION_COMPLETE_EVENT_anchor">HCI_LE_CONNECTION_COMPLETE_EVENT</a> (or <a href="#HCI_LE_ENHANCED_CONNECTION_COMPLETE_EVENT_anchor">HCI_LE_ENHANCED_CONNECTION_COMPLETE_EVENT</a> if privacy or extended advertising is used) is returned. The procedure can be explicitly terminated by the upper layer by issuing the command <a href="#ACI_GAP_TERMINATE_GAP_PROC_anchor">ACI_GAP_TERMINATE_GAP_PROC</a> with the Procedure_Code set to 0x40.<br>If privacy is enabled and the peer device (advertiser) is in the resolving list then the link layer will generate a RPA, if it is not then the RPA generated by the Host will be used.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>LE_Scan_Interval</p>
</td><td><p>2</p>
</td><td><p>This is defined as the time interval from when the Controller started its last LE scan until it begins the subsequent LE scan.
Time = N * 0.625 ms.</p>
</td><td><li>0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) : legacy advertising</li><li>0x0004 (2.500 ms)  ... 0x5DC0 (15000.000 ms) : extended advertising with STM32WB</li><li>0x0004 (2.500 ms)  ... 0xFFFF (40959.375 ms) : extended advertising with STM32WBA</li></td></tr>
<tr><td><p>LE_Scan_Window</p>
</td><td><p>2</p>
</td><td><p>Amount of time for the duration of the LE scan. LE_Scan_Window shall be less than or equal to LE_Scan_Interval.
Time = N * 0.625 ms.</p>
</td><td><li>0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) : legacy advertising</li><li>0x0004 (2.500 ms)  ... 0x5DC0 (15000.000 ms) : extended advertising with STM32WB</li><li>0x0004 (2.500 ms)  ... 0xFFFF (40959.375 ms) : extended advertising with STM32WBA</li></td></tr>
<tr><td><p>Peer_Address_Type</p>
</td><td><p>1</p>
</td><td><p>The address type of the peer device.</p>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li></td></tr>
<tr><td><p>Peer_Address</p>
</td><td><p>6</p>
</td><td><p>Public Device Address or Random Device Address of the device to be connected.</p>
</td><td></tr>
<tr><td><p>Own_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Own address type: if Privacy is disabled, the address can be public or static random; otherwise, it can be a resolvable private address.</p>
</td><td><li>0x00: Public address</li><li>0x01: Static random address</li><li>0x02: Resolvable private address</li></td></tr>
<tr><td><p>Conn_Interval_Min</p>
</td><td><p>2</p>
</td><td><p>Minimum value for the connection event interval.
Time = N * 1.25 ms.</p>
</td><td><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Conn_Interval_Max</p>
</td><td><p>2</p>
</td><td><p>Maximum value for the connection event interval.
Time = N * 1.25 ms.</p>
</td><td><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Conn_Latency</p>
</td><td><p>2</p>
</td><td><p>Maximum Peripheral latency for the connection in number of connection events.</p>
</td><td><li>0x0000 ... 0x01F3</li></td></tr>
<tr><td><p>Supervision_Timeout</p>
</td><td><p>2</p>
</td><td><p>Supervision timeout for the LE Link.
It shall be a multiple of 10 ms and larger than (1 + connPeripheralLatency) * connInterval * 2.
Time = N * 10 ms.</p>
</td><td><li>0x000A (100 ms)  ... 0x0C80 (32000 ms) </li></td></tr>
<tr><td><p>Minimum_CE_Length</p>
</td><td><p>2</p>
</td><td><p>Information parameter about the minimum length of connection needed for this LE connection.
Time = N * 0.625 ms.</p>
</td><td><li>0x0000 (0.000 ms)  ... 0xFFFF (40959.375 ms) </li></td></tr>
<tr><td><p>Maximum_CE_Length</p>
</td><td><p>2</p>
</td><td><p>Information parameter about the maximum length of connection needed for this LE connection.
Time = N * 0.625 ms.</p>
</td><td><li>0x0000 (0.000 ms)  ... 0xFFFF (40959.375 ms) </li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#HCI_LE_CONNECTION_COMPLETE_EVENT_anchor">HCI_LE_CONNECTION_COMPLETE_EVENT</a></li><li><a href="#HCI_LE_ENHANCED_CONNECTION_COMPLETE_EVENT_anchor">HCI_LE_ENHANCED_CONNECTION_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_TERMINATE_GAP_PROC_anchor">ACI_GAP_TERMINATE_GAP_PROC</a></h2><h3>Description</h3><p>Terminates the specified GAP procedure. An <a href="#ACI_GAP_PROC_COMPLETE_EVENT_anchor">ACI_GAP_PROC_COMPLETE_EVENT</a> event is returned with the procedure code set to the corresponding procedure.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Procedure_Code</p>
</td><td><p>1</p>
</td><td><p>GAP procedure bitmap.</p>
</td><td><li>0x00: No events</li><li>0x01: GAP_LIMITED_DISCOVERY_PROC</li><li>0x02: GAP_GENERAL_DISCOVERY_PROC</li><li>0x08: GAP_AUTO_CONNECTION_ESTABLISHMENT_PROC</li><li>0x10: GAP_GENERAL_CONNECTION_ESTABLISHMENT_PROC</li><li>0x20: GAP_SELECTIVE_CONNECTION_ESTABLISHMENT_PROC</li><li>0x40: GAP_DIRECT_CONNECTION_ESTABLISHMENT_PROC</li><li>0x80: GAP_OBSERVATION_PROC</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><li><a href="#ACI_GAP_PROC_COMPLETE_EVENT_anchor">ACI_GAP_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_START_CONNECTION_UPDATE_anchor">ACI_GAP_START_CONNECTION_UPDATE</a></h2><h3>Description</h3><p>Starts the connection update procedure (only when role is Central). A <a href="#HCI_LE_CONNECTION_UPDATE_anchor">HCI_LE_CONNECTION_UPDATE</a> is called.<br>On completion of the procedure, an <a href="#HCI_LE_CONNECTION_UPDATE_COMPLETE_EVENT_anchor">HCI_LE_CONNECTION_UPDATE_COMPLETE_EVENT</a> event is returned to the upper layer.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Conn_Interval_Min</p>
</td><td><p>2</p>
</td><td><p>Minimum value for the connection event interval.
Time = N * 1.25 ms.</p>
</td><td><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Conn_Interval_Max</p>
</td><td><p>2</p>
</td><td><p>Maximum value for the connection event interval.
Time = N * 1.25 ms.</p>
</td><td><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Conn_Latency</p>
</td><td><p>2</p>
</td><td><p>Maximum Peripheral latency for the connection in number of connection events.</p>
</td><td><li>0x0000 ... 0x01F3</li></td></tr>
<tr><td><p>Supervision_Timeout</p>
</td><td><p>2</p>
</td><td><p>Supervision timeout for the LE Link.
It shall be a multiple of 10 ms and larger than (1 + connPeripheralLatency) * connInterval * 2.
Time = N * 10 ms.</p>
</td><td><li>0x000A (100 ms)  ... 0x0C80 (32000 ms) </li></td></tr>
<tr><td><p>Minimum_CE_Length</p>
</td><td><p>2</p>
</td><td><p>Information parameter about the minimum length of connection needed for this LE connection.
Time = N * 0.625 ms.</p>
</td><td><li>0x0000 (0.000 ms)  ... 0xFFFF (40959.375 ms) </li></td></tr>
<tr><td><p>Maximum_CE_Length</p>
</td><td><p>2</p>
</td><td><p>Information parameter about the maximum length of connection needed for this LE connection.
Time = N * 0.625 ms.</p>
</td><td><li>0x0000 (0.000 ms)  ... 0xFFFF (40959.375 ms) </li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#HCI_LE_CONNECTION_UPDATE_COMPLETE_EVENT_anchor">HCI_LE_CONNECTION_UPDATE_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_SEND_PAIRING_REQ_anchor">ACI_GAP_SEND_PAIRING_REQ</a></h2><h3>Description</h3><p>Sends the SM pairing request to start a pairing process. The authentication requirements and IO capabilities should be set before issuing this command using the <a href="#ACI_GAP_SET_IO_CAPABILITY_anchor">ACI_GAP_SET_IO_CAPABILITY</a> and <a href="#ACI_GAP_SET_AUTHENTICATION_REQUIREMENT_anchor">ACI_GAP_SET_AUTHENTICATION_REQUIREMENT</a> commands.<br>A <a href="#ACI_GAP_PAIRING_COMPLETE_EVENT_anchor">ACI_GAP_PAIRING_COMPLETE_EVENT</a> event is returned after the pairing process is completed.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Force_Rebond</p>
</td><td><p>1</p>
</td><td><dl class="docutils">
<dt>If 1, Pairing request will be sent even if the device was previously bonded,</dt>
<dd>otherwise pairing request is not sent.</dd>
</dl>
</td><td><li>0x00: NO</li><li>0x01: YES</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_GAP_PAIRING_COMPLETE_EVENT_anchor">ACI_GAP_PAIRING_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_RESOLVE_PRIVATE_ADDR_anchor">ACI_GAP_RESOLVE_PRIVATE_ADDR</a></h2><h3>Description</h3><p>This command tries to resolve the address provided with the IRKs present in its database. If the address is resolved successfully with any one of the IRKs present in the database, it returns success and also the corresponding public/static random address stored with the IRK in the database.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Address</p>
</td><td><p>6</p>
</td><td><p>Address to be resolved</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Actual_Address</p>
</td><td><p>6</p>
</td><td><p>The public or static random address of the peer device, distributed during pairing phase.</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_SET_BROADCAST_MODE_anchor">ACI_GAP_SET_BROADCAST_MODE</a></h2><h3>Description</h3><p>This command puts the device into broadcast mode. A privacy enabled device uses either a resolvable private address or a non-resolvable private address as specified in the Own_Address_Type parameter of the command.<br>Note: this command only supports legacy advertising.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Advertising_Interval_Min</p>
</td><td><p>2</p>
</td><td><p>Minimum advertising interval.
Time = N * 0.625 ms.</p>
</td><td><li>0x0020 (20.000 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>Advertising_Interval_Max</p>
</td><td><p>2</p>
</td><td><p>Maximum advertising interval.
Time = N * 0.625 ms.</p>
</td><td><li>0x0020 (20.000 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>Advertising_Type</p>
</td><td><p>1</p>
</td><td><p>Advertising type</p>
</td><td><li>0x02: ADV_SCAN_IND (Scannable undirected advertising)</li><li>0x03: ADV_NONCONN_IND (Non connectable undirected advertising)</li></td></tr>
<tr><td><p>Own_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Own address type: if Privacy is disabled, the address can be public or static random; otherwise, it can be a resolvable private address or a non-resolvable private address.</p>
</td><td><li>0x00: Public address</li><li>0x01: Static random address</li><li>0x02: Resolvable private address</li><li>0x03: Non-resolvable private address</li></td></tr>
<tr><td><p>Adv_Data_Length</p>
</td><td><p>1</p>
</td><td><p>Length of the advertising data in the advertising packet.</p>
</td><td></tr>
<tr><td><p>Adv_Data</p>
</td><td><p>Adv_Data_Length</p>
</td><td><p>Advertising data used by the device while advertising.</p>
</td><td></tr>
<tr><td><p>Num_of_Peer_Entries</p>
</td><td><p>1</p>
</td><td><p>Number of devices that have to be added to the Filter Accept List. Each device is defined by Peer_Address_Type and Peer_Address.</p>
</td><td></tr>
<tr><td><p>Peer_Address_Type[i]</p>
</td><td><p>1</p>
</td><td><p>Address type.</p>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li></td></tr>
<tr><td><p>Peer_Address[i]</p>
</td><td><p>6</p>
</td><td><p>Public Device Address or Random Device Address.</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_START_OBSERVATION_PROC_anchor">ACI_GAP_START_OBSERVATION_PROC</a></h2><h3>Description</h3><p>Starts an Observation procedure when the device is in Observer Role. The host enables scanning in the controller. The advertising reports are sent to the upper layer using standard LE Advertising Report Event.<br>If privacy is enabled and the peer device (advertiser) is in the resolving list then the link layer will generate a RPA, if it is not then the RPA/NRPA generated by the Host will be used.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>LE_Scan_Interval</p>
</td><td><p>2</p>
</td><td><p>This is defined as the time interval from when the Controller started its last LE scan until it begins the subsequent LE scan.
Time = N * 0.625 ms.</p>
</td><td><li>0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) : legacy advertising</li><li>0x0004 (2.500 ms)  ... 0x5DC0 (15000.000 ms) : extended advertising with STM32WB</li><li>0x0004 (2.500 ms)  ... 0xFFFF (40959.375 ms) : extended advertising with STM32WBA</li></td></tr>
<tr><td><p>LE_Scan_Window</p>
</td><td><p>2</p>
</td><td><p>Amount of time for the duration of the LE scan. LE_Scan_Window shall be less than or equal to LE_Scan_Interval.
Time = N * 0.625 ms.</p>
</td><td><li>0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) : legacy advertising</li><li>0x0004 (2.500 ms)  ... 0x5DC0 (15000.000 ms) : extended advertising with STM32WB</li><li>0x0004 (2.500 ms)  ... 0xFFFF (40959.375 ms) : extended advertising with STM32WBA</li></td></tr>
<tr><td><p>LE_Scan_Type</p>
</td><td><p>1</p>
</td><td><p>Passive or active scanning. With passive scanning, no scan request PDUs are sent.</p>
</td><td><li>0x00: Passive scanning</li><li>0x01: Active scanning</li></td></tr>
<tr><td><p>Own_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Own address type: if Privacy is disabled, the address can be public or static random; otherwise, it can be a resolvable private address or a non-resolvable private address.</p>
</td><td><li>0x00: Public address</li><li>0x01: Static random address</li><li>0x02: Resolvable private address</li><li>0x03: Non-resolvable private address</li></td></tr>
<tr><td><p>Filter_Duplicates</p>
</td><td><p>1</p>
</td><td><p>Enable/disable duplicate filtering.</p>
</td><td><li>0x00: Duplicate filtering disabled</li><li>0x01: Duplicate filtering enabled</li></td></tr>
<tr><td><p>Scanning_Filter_Policy</p>
</td><td><p>1</p>
</td><td><p>The scanning filter policy determines how the scanner's Link Layer processes advertising and scan response PDUs.
There is a choice of two primary filter policies: unfiltered and filtered.
Unfiltered: the Link Layer processes all advertising and scan response PDUs (i.e., the Filter Accept List is not used).
Filtered: the Link Layer processes advertising and scan response PDUs only from devices in the Filter Accept List.
With extended scanning filter policies, a directed advertising PDU accepted by the primary filter policy shall nevertheless be ignored unless either the TargetA field is identical to the scanner's device address, or TargetA field is a resolvable private address.</p>
</td><td><li>0x00: Basic unfiltered scanning filter policy</li><li>0x01: Basic filtered scanning filter policy</li><li>0x02: Extended unfiltered scanning filter policy</li><li>0x03: Extended filtered scanning filter policy</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#HCI_LE_ADVERTISING_REPORT_EVENT_anchor">HCI_LE_ADVERTISING_REPORT_EVENT</a></li><li><a href="#HCI_LE_EXTENDED_ADVERTISING_REPORT_EVENT_anchor">HCI_LE_EXTENDED_ADVERTISING_REPORT_EVENT</a></li><h2><a name="ACI_GAP_GET_BONDED_DEVICES_anchor">ACI_GAP_GET_BONDED_DEVICES</a></h2><h3>Description</h3><p>This command gets the list of the devices which are present in the bonding table. It returns the number of addresses and the corresponding address types and values.</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Num_of_Addresses</p>
</td><td><p>1</p>
</td><td><p>The number of bonded devices</p>
</td><td></tr>
<tr><td><p>Address_Type[i]</p>
</td><td><p>1</p>
</td><td><p>Address type.</p>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li></td></tr>
<tr><td><p>Address[i]</p>
</td><td><p>6</p>
</td><td><p>Public Device Address or Random Device Address.</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_IS_DEVICE_BONDED_anchor">ACI_GAP_IS_DEVICE_BONDED</a></h2><h3>Description</h3><p>The command finds whether the device, whose address is specified in the command, is present in the bonding table. If the device is found, the command returns "Success".</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Peer_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Identity address type</p>
</td><td><li>0x00: Public Identity Address</li><li>0x01: Random (static) Identity Address</li></td></tr>
<tr><td><p>Peer_Address</p>
</td><td><p>6</p>
</td><td><p>Public or Random (static) Identity Address of the peer device</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_NUMERIC_COMPARISON_VALUE_CONFIRM_YESNO_anchor">ACI_GAP_NUMERIC_COMPARISON_VALUE_CONFIRM_YESNO</a></h2><h3>Description</h3><p>This command allows the User to validate/confirm or not the Numeric Comparison value showed through the <a href="#ACI_GAP_NUMERIC_COMPARISON_VALUE_EVENT_anchor">ACI_GAP_NUMERIC_COMPARISON_VALUE_EVENT</a>.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Confirm_Yes_No</p>
</td><td><p>1</p>
</td><td><p>Indicates if the numeric values showed on both local and peer device are different or equal</p>
</td><td><li>0x00: No (numeric values are different)</li><li>0x01: Yes (numeric values are equal)</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_PASSKEY_INPUT_anchor">ACI_GAP_PASSKEY_INPUT</a></h2><h3>Description</h3><p>This command permits to signal to the Stack the input type detected during Passkey input.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Input_Type</p>
</td><td><p>1</p>
</td><td><p>Passkey input type detected</p>
</td><td><li>0x00: Passkey entry started</li><li>0x01: Passkey digit entered</li><li>0x02: Passkey digit erased</li><li>0x03: Passkey cleared</li><li>0x04: Passkey entry completed</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_GET_OOB_DATA_anchor">ACI_GAP_GET_OOB_DATA</a></h2><h3>Description</h3><p>This command is sent by the User to get (i.e. to extract from the Stack) the OOB data generated by the Stack itself.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>OOB_Data_Type</p>
</td><td><p>1</p>
</td><td><p>Type of OOB data</p>
</td><td><li>0x00: TK (Legacy pairing)</li><li>0x01: Random (SC)</li><li>0x02: Confirm (SC)</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Address_Type</p>
</td><td><p>1</p>
</td><td><p>Identity address type</p>
</td><td><li>0x00: Public Identity Address</li><li>0x01: Random (static) Identity Address</li></td></tr>
<tr><td><p>Address</p>
</td><td><p>6</p>
</td><td><p>Public or Random (static) address of this device</p>
</td><td></tr>
<tr><td><p>OOB_Data_Type</p>
</td><td><p>1</p>
</td><td><p>Type of OOB data</p>
</td><td><li>0x00: TK (Legacy pairing)</li><li>0x01: Random (SC)</li><li>0x02: Confirm (SC)</li></td></tr>
<tr><td><p>OOB_Data_Len</p>
</td><td><p>1</p>
</td><td><p>Length of OOB data</p>
</td><td><li>16</li></td></tr>
<tr><td><p>OOB_Data</p>
</td><td><p>16</p>
</td><td><p>Local OOB data</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_SET_OOB_DATA_anchor">ACI_GAP_SET_OOB_DATA</a></h2><h3>Description</h3><p>This command is sent (by the User) to input the OOB data arrived via OOB communication.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Device_Type</p>
</td><td><p>1</p>
</td><td><p>OOB Device type</p>
</td><td><li>0x00: Local device (Address_Type and Address are not used)</li><li>0x01: Remote device</li></td></tr>
<tr><td><p>Address_Type</p>
</td><td><p>1</p>
</td><td><p>Identity address type</p>
</td><td><li>0x00: Public Identity Address</li><li>0x01: Random (static) Identity Address</li></td></tr>
<tr><td><p>Address</p>
</td><td><p>6</p>
</td><td><p>Public or Random (static) Identity Address of the peer device</p>
</td><td></tr>
<tr><td><p>OOB_Data_Type</p>
</td><td><p>1</p>
</td><td><p>Type of OOB data</p>
</td><td><li>0x00: TK (Legacy pairing)</li><li>0x01: Random (SC)</li><li>0x02: Confirm (SC)</li></td></tr>
<tr><td><p>OOB_Data_Len</p>
</td><td><p>1</p>
</td><td><p>Length of OOB data</p>
</td><td><li>0: SC Random/Confirm generation (OOB_Data and OOB_Data_Type are not used)</li><li>16</li></td></tr>
<tr><td><p>OOB_Data</p>
</td><td><p>16</p>
</td><td><p>Either local OOB data or remote OOB data received through OOB from peer device (see Device_Type)</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_ADD_DEVICES_TO_RESOLVING_LIST_anchor">ACI_GAP_ADD_DEVICES_TO_RESOLVING_LIST</a></h2><h3>Description</h3><p>This  command is used to add devices to the list of address translations used to resolve Resolvable Private Addresses in the Controller.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Num_of_Resolving_list_Entries</p>
</td><td><p>1</p>
</td><td><p>Number of devices that have to be added to the list.</p>
</td><td></tr>
<tr><td><p>Peer_Identity_Address_Type[i]</p>
</td><td><p>1</p>
</td><td><p>Identity address type</p>
</td><td><li>0x00: Public Identity Address</li><li>0x01: Random (static) Identity Address</li></td></tr>
<tr><td><p>Peer_Identity_Address[i]</p>
</td><td><p>6</p>
</td><td><p>Public or Random (static) Identity Address of the peer device</p>
</td><td></tr>
<tr><td><p>Clear_Resolving_List</p>
</td><td><p>1</p>
</td><td><p>Clear the resolving list</p>
</td><td><li>0x00: Do not clear</li><li>0x01: Clear before adding</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_REMOVE_BONDED_DEVICE_anchor">ACI_GAP_REMOVE_BONDED_DEVICE</a></h2><h3>Description</h3><p>This command removes a specified device from bonding table; i.e. it removes from bonding table all security and GATT information related to the specified device.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Peer_Identity_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Identity address type</p>
</td><td><li>0x00: Public Identity Address</li><li>0x01: Random (static) Identity Address</li></td></tr>
<tr><td><p>Peer_Identity_Address</p>
</td><td><p>6</p>
</td><td><p>Public or Random (static) Identity Address of the peer device</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_ADD_DEVICES_TO_LIST_anchor">ACI_GAP_ADD_DEVICES_TO_LIST</a></h2><h3>Description</h3><p>This command is used to add specific device addresses to the Filter Accept List and/or resolving list.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Num_of_List_Entries</p>
</td><td><p>1</p>
</td><td><p>Number of devices that have to be added to the list.</p>
</td><td></tr>
<tr><td><p>Address_Type[i]</p>
</td><td><p>1</p>
</td><td><p>Address type.</p>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li></td></tr>
<tr><td><p>Address[i]</p>
</td><td><p>6</p>
</td><td><p>Public Device Address or Random Device Address.</p>
</td><td></tr>
<tr><td><p>Mode</p>
</td><td><p>1</p>
</td><td><p>Mode used for adding devices in the lists.</p>
</td><td><li>0x00: Append to the resolving list only</li><li>0x01: Clear and set the resolving list only</li><li>0x02: Append to the Filter Accept List only</li><li>0x03: Clear and set the Filter Accept List only</li><li>0x04: Append to both resolving list and Filter Accept List</li><li>0x05: Clear and set both resolving list and Filter Accept List</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_ADDITIONAL_BEACON_START_anchor">ACI_GAP_ADDITIONAL_BEACON_START</a></h2><h3>Description</h3><p>This command starts an advertising beacon. It allows additional advertising packets to be transmitted independently of the packets transmitted with GAP advertising commands such as <a href="#ACI_GAP_SET_DISCOVERABLE_anchor">ACI_GAP_SET_DISCOVERABLE</a> or <a href="#ACI_GAP_SET_LIMITED_DISCOVERABLE_anchor">ACI_GAP_SET_LIMITED_DISCOVERABLE</a>.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Adv_Interval_Min</p>
</td><td><p>2</p>
</td><td><p>Minimum advertising interval.
Time = N * 0.625 ms.</p>
</td><td><li>0x0020 (20.000 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>Adv_Interval_Max</p>
</td><td><p>2</p>
</td><td><p>Maximum advertising interval.
Time = N * 0.625 ms.</p>
</td><td><li>0x0020 (20.000 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>Adv_Channel_Map</p>
</td><td><p>1</p>
</td><td><p>Advertising channel map.</p>
</td><td><p>Bitmask of:</p><li>0x01: Channel 37 shall be used</li><li>0x02: Channel 38 shall be used</li><li>0x04: Channel 39 shall be used</li></td></tr>
<tr><td><p>Own_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Own address type: public or static random.</p>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li></td></tr>
<tr><td><p>Own_Address</p>
</td><td><p>6</p>
</td><td><p>Public Device Address or Random Device Address.</p>
</td><td></tr>
<tr><td><p>PA_Level</p>
</td><td><p>1</p>
</td><td><p>Power amplifier output level.</p>
</td><td><li>0x00 ... 0x23</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_ADDITIONAL_BEACON_STOP_anchor">ACI_GAP_ADDITIONAL_BEACON_STOP</a></h2><h3>Description</h3><p>This command stops the advertising beacon started with <a href="#ACI_GAP_ADDITIONAL_BEACON_START_anchor">ACI_GAP_ADDITIONAL_BEACON_START</a>.</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_ADDITIONAL_BEACON_SET_DATA_anchor">ACI_GAP_ADDITIONAL_BEACON_SET_DATA</a></h2><h3>Description</h3><p>This command sets the data transmitted by the advertising beacon started with <a href="#ACI_GAP_ADDITIONAL_BEACON_START_anchor">ACI_GAP_ADDITIONAL_BEACON_START</a>. If the advertising beacon is already started, the new data is used in subsequent beacon advertising events.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Adv_Data_Length</p>
</td><td><p>1</p>
</td><td><p>Length of Adv_Data in octets</p>
</td><td></tr>
<tr><td><p>Adv_Data</p>
</td><td><p>Adv_Data_Length</p>
</td><td><p>Advertising data used by the device while advertising.</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_ADV_SET_CONFIGURATION_anchor">ACI_GAP_ADV_SET_CONFIGURATION</a></h2><h3>Description</h3><p>This command is used to set the extended advertising configuration for one advertising set.<br>This command, in association with <a href="#ACI_GAP_ADV_SET_SCAN_RESP_DATA_anchor">ACI_GAP_ADV_SET_SCAN_RESP_DATA</a>, <a href="#ACI_GAP_ADV_SET_ADV_DATA_anchor">ACI_GAP_ADV_SET_ADV_DATA</a> and <a href="#ACI_GAP_ADV_SET_ENABLE_anchor">ACI_GAP_ADV_SET_ENABLE</a>, enables to start extended advertising. These commands must be used in replacement of <a href="#ACI_GAP_SET_DISCOVERABLE_anchor">ACI_GAP_SET_DISCOVERABLE</a>, <a href="#ACI_GAP_SET_LIMITED_DISCOVERABLE_anchor">ACI_GAP_SET_LIMITED_DISCOVERABLE</a>, <a href="#ACI_GAP_SET_DIRECT_CONNECTABLE_anchor">ACI_GAP_SET_DIRECT_CONNECTABLE</a>, <a href="#ACI_GAP_SET_NON_CONNECTABLE_anchor">ACI_GAP_SET_NON_CONNECTABLE</a>, <a href="#ACI_GAP_SET_UNDIRECTED_CONNECTABLE_anchor">ACI_GAP_SET_UNDIRECTED_CONNECTABLE</a> and <a href="#ACI_GAP_SET_BROADCAST_MODE_anchor">ACI_GAP_SET_BROADCAST_MODE</a> that only support legacy advertising.<br>If bit 0 of Adv_Mode is set, the Own_Address_Type parameter is ignored and the own address shall be set with the <a href="#ACI_GAP_ADV_SET_RANDOM_ADDRESS_anchor">ACI_GAP_ADV_SET_RANDOM_ADDRESS</a> command. This mode is only valid for non-connectable advertising.<br>If bit 1 of Adv_Mode is set, the primary advertisement PHY is set to LE Coded (not supported on STM32WB); otherwise, the default primary advertisement PHY is LE 1M.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Adv_Mode</p>
</td><td><p>1</p>
</td><td><p>Bitmap of extended advertising modes</p>
</td><td><p>Bitmask of:</p><li>0x01: Use specific random address</li><li>0x02: Use LE Coded as primary advertising PHY (not supported on STM32WB)</li></td></tr>
<tr><td><p>Advertising_Handle</p>
</td><td><p>1</p>
</td><td><p>Used to identify an advertising set.</p>
</td><td><li>0x00 ... 0xEF</li></td></tr>
<tr><td><p>Adv_Event_Properties</p>
</td><td><p>2</p>
</td><td><p>Type of advertising event.</p>
</td><td><p>Bitmask of:</p><li>0x0001: Connectable advertising</li><li>0x0002: Scannable advertising</li><li>0x0004: Directed advertising</li><li>0x0008: High Duty Cycle Directed Connectable advertising</li><li>0x0010: Use legacy advertising PDUs</li><li>0x0020: Anonymous advertising</li><li>0x0040: Include TxPower in at least one advertising PDU</li></td></tr>
<tr><td><p>Primary_Adv_Interval_Min</p>
</td><td><p>4</p>
</td><td><p>Minimum advertising interval.
Time = N * 0.625 ms.</p>
</td><td><li>0x00000020 (20.000 ms)  ... 0x00FFFFFF (10485759.375 ms) </li></td></tr>
<tr><td><p>Primary_Adv_Interval_Max</p>
</td><td><p>4</p>
</td><td><p>Maximum advertising interval.
Time = N * 0.625 ms.</p>
</td><td><li>0x00000020 (20.000 ms)  ... 0x00FFFFFF (10485759.375 ms) </li></td></tr>
<tr><td><p>Primary_Adv_Channel_Map</p>
</td><td><p>1</p>
</td><td><p>Advertising channel map.</p>
</td><td><p>Bitmask of:</p><li>0x01: Channel 37 shall be used</li><li>0x02: Channel 38 shall be used</li><li>0x04: Channel 39 shall be used</li></td></tr>
<tr><td><p>Own_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Own address type: if Privacy is disabled, the address can be public or static random; otherwise, it can be a resolvable private address or a non-resolvable private address.</p>
</td><td><li>0x00: Public address</li><li>0x01: Static random address</li><li>0x02: Resolvable private address</li><li>0x03: Non-resolvable private address</li></td></tr>
<tr><td><p>Peer_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Address type of the peer device.</p>
</td><td><li>0x00: Public Device Address or Public Identity Address</li><li>0x01: Random Device Address or Random (static) Identity Address</li></td></tr>
<tr><td><p>Peer_Address</p>
</td><td><p>6</p>
</td><td><p>Public Device Address, Random Device Address, Public Identity Address, or Random (static) Identity Address of the device to be connected.</p>
</td><td></tr>
<tr><td><p>Adv_Filter_Policy</p>
</td><td><p>1</p>
</td><td><p>Advertising filter policy</p>
</td><td><li>0x00: Process scan and connection requests from all devices (i.e., the Filter Accept List is not in use)</li><li>0x01: Process connection requests from all devices and scan requests only from devices that are in the Filter Accept List.</li><li>0x02: Process scan requests from all devices and connection requests only from devices that are in the Filter Accept List.</li><li>0x03: Process scan and connection requests only from devices in the Filter Accept List.</li></td></tr>
<tr><td><p>Adv_TX_Power</p>
</td><td><p>1</p>
</td><td><p>Advertising TX power. Units: dBm.</p>
</td><td><li>-127 ... 20</li></td></tr>
<tr><td><p>Secondary_Adv_Max_Skip</p>
</td><td><p>1</p>
</td><td><p>Secondary advertising maximum skip.</p>
</td><td><li>0x00: AUX_ADV_IND shall be sent prior to the next advertising event</li><li>0x01 ... 0xFF: Maximum advertising events the Controller can skip before sending the AUX_ADV_IND packets on the secondary advertising physical channel</li></td></tr>
<tr><td><p>Secondary_Adv_PHY</p>
</td><td><p>1</p>
</td><td><p>Secondary advertising PHY.</p>
</td><td><li>0x01: Secondary advertisement PHY is LE 1M</li><li>0x02: Secondary advertisement PHY is LE 2M</li><li>0x03: Secondary advertisement PHY is LE Coded (not supported on STM32WB)</li></td></tr>
<tr><td><p>Adv_SID</p>
</td><td><p>1</p>
</td><td><p>Value of the Advertising SID subfield in the ADI field of the PDU.</p>
</td><td><li>0x00 ... 0x0F</li></td></tr>
<tr><td><p>Scan_Req_Notification_Enable</p>
</td><td><p>1</p>
</td><td><p>Scan request notifications.</p>
</td><td><li>0x00: Scan request notifications disabled</li><li>0x01: Scan request notifications enabled</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_ADV_SET_ENABLE_anchor">ACI_GAP_ADV_SET_ENABLE</a></h2><h3>Description</h3><p>This command is used to request the Controller to enable or disable one or more extended advertising sets.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Enable</p>
</td><td><p>1</p>
</td><td><p>Enable/disable advertising.</p>
</td><td><li>0x00: Advertising is disabled</li><li>0x01: Advertising is enabled</li></td></tr>
<tr><td><p>Num_Sets</p>
</td><td><p>1</p>
</td><td><p>Number of advertising sets.</p>
</td><td><li>0x00: Disable all advertising sets</li><li>0x01 ... 0x3F: Number of advertising sets to enable or disable</li></td></tr>
<tr><td><p>Advertising_Handle[i]</p>
</td><td><p>1</p>
</td><td><p>Used to identify an advertising set.</p>
</td><td><li>0x00 ... 0xEF</li></td></tr>
<tr><td><p>Duration[i]</p>
</td><td><p>2</p>
</td><td><p>Duration of advertising set.
Time = N * 10 ms.</p>
</td><td><li>0x0000 (0 ms) : No advertising duration.</li><li>0x0001 (10 ms)  ... 0xFFFF (655350 ms) : Advertising duration</li></td></tr>
<tr><td><p>Max_Extended_Advertising_Events[i]</p>
</td><td><p>1</p>
</td><td><p>Maximum number of advertising events.</p>
</td><td><li>0x00: No maximum number of advertising events</li><li>0x01 ... 0xFF: Maximum number of extended advertising events the Controller shall attempt to send prior to terminating the extended advertising</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_ADV_SET_ADV_DATA_anchor">ACI_GAP_ADV_SET_ADV_DATA</a></h2><h3>Description</h3><p>This command is used to set the data used in extended advertising PDUs that have a data field.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Advertising_Handle</p>
</td><td><p>1</p>
</td><td><p>Used to identify an advertising set.</p>
</td><td><li>0x00 ... 0xEF</li></td></tr>
<tr><td><p>Operation</p>
</td><td><p>1</p>
</td><td><p>Advertising operation.</p>
</td><td><li>0x00: Intermediate fragment of fragmented extended advertising data</li><li>0x01: First fragment of fragmented extended advertising data</li><li>0x02: Last fragment of fragmented extended advertising data</li><li>0x03: Complete extended advertising data</li><li>0x04: Unchanged data (just update the Advertising DID)</li></td></tr>
<tr><td><p>Fragment_Preference</p>
</td><td><p>1</p>
</td><td><p>Fragment preference.</p>
</td><td><li>0x00: The Controller may fragment all data</li><li>0x01: The Controller should not fragment or should minimize fragmentation of data</li></td></tr>
<tr><td><p>Advertising_Data_Length</p>
</td><td><p>1</p>
</td><td><p>Length of Advertising_Data in octets</p>
</td><td></tr>
<tr><td><p>Advertising_Data</p>
</td><td><p>Advertising_Data_Length</p>
</td><td><p>Data formatted as defined in Bluetooth spec. v.5.4 [Vol 3, Part C, 11].</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_ADV_SET_SCAN_RESP_DATA_anchor">ACI_GAP_ADV_SET_SCAN_RESP_DATA</a></h2><h3>Description</h3><p>This command is used to provide scan response data used during extended advertising.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Advertising_Handle</p>
</td><td><p>1</p>
</td><td><p>Used to identify an advertising set.</p>
</td><td><li>0x00 ... 0xEF</li></td></tr>
<tr><td><p>Operation</p>
</td><td><p>1</p>
</td><td><p>Scan response operation.</p>
</td><td><li>0x00: Intermediate fragment of fragmented scan response data</li><li>0x01: First fragment of fragmented scan response data</li><li>0x02: Last fragment of fragmented scan response data</li><li>0x03: Complete scan response data</li></td></tr>
<tr><td><p>Fragment_Preference</p>
</td><td><p>1</p>
</td><td><p>Fragment preference.</p>
</td><td><li>0x00: The Controller may fragment all data</li><li>0x01: The Controller should not fragment or should minimize fragmentation of data</li></td></tr>
<tr><td><p>Scan_Response_Data_Length</p>
</td><td><p>1</p>
</td><td><p>Length of Scan_Response_Data in octets</p>
</td><td></tr>
<tr><td><p>Scan_Response_Data</p>
</td><td><p>Scan_Response_Data_Length</p>
</td><td><p>Data formatted as defined in Bluetooth spec. v.5.4 [Vol 3, Part C, 11].</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_ADV_REMOVE_SET_anchor">ACI_GAP_ADV_REMOVE_SET</a></h2><h3>Description</h3><p>This command is used to remove an advertising set from the Controller.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Advertising_Handle</p>
</td><td><p>1</p>
</td><td><p>Used to identify an advertising set.</p>
</td><td><li>0x00 ... 0xEF</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_ADV_CLEAR_SETS_anchor">ACI_GAP_ADV_CLEAR_SETS</a></h2><h3>Description</h3><p>This command is used to remove all existing advertising sets from the Controller.</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_ADV_SET_RANDOM_ADDRESS_anchor">ACI_GAP_ADV_SET_RANDOM_ADDRESS</a></h2><h3>Description</h3><p>This command is used to set the random device address of an advertising set configured to use specific random address.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Advertising_Handle</p>
</td><td><p>1</p>
</td><td><p>Used to identify an advertising set.</p>
</td><td><li>0x00 ... 0xEF</li></td></tr>
<tr><td><p>Random_Address</p>
</td><td><p>6</p>
</td><td><p>Random Device Address.</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI GATT/ATT commands_anchor">ACI GATT/ATT commands</a></h2><h2></h2><table width="800" border="1" class="reference">
<tr><th>Command</th><th>Opcode</th><th>BF</th><th>PO</th><th>LO</th><th>LB</th><th>BO</th></tr>
<tr><td><a href="#ACI_GATT_INIT_anchor">ACI_GATT_INIT</a></td><td><p>0xFD01</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_ADD_SERVICE_anchor">ACI_GATT_ADD_SERVICE</a></td><td><p>0xFD02</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_INCLUDE_SERVICE_anchor">ACI_GATT_INCLUDE_SERVICE</a></td><td><p>0xFD03</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_ADD_CHAR_anchor">ACI_GATT_ADD_CHAR</a></td><td><p>0xFD04</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_ADD_CHAR_DESC_anchor">ACI_GATT_ADD_CHAR_DESC</a></td><td><p>0xFD05</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_UPDATE_CHAR_VALUE_anchor">ACI_GATT_UPDATE_CHAR_VALUE</a></td><td><p>0xFD06</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_DEL_CHAR_anchor">ACI_GATT_DEL_CHAR</a></td><td><p>0xFD07</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_DEL_SERVICE_anchor">ACI_GATT_DEL_SERVICE</a></td><td><p>0xFD08</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_DEL_INCLUDE_SERVICE_anchor">ACI_GATT_DEL_INCLUDE_SERVICE</a></td><td><p>0xFD09</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_SET_EVENT_MASK_anchor">ACI_GATT_SET_EVENT_MASK</a></td><td><p>0xFD0A</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_EXCHANGE_CONFIG_anchor">ACI_GATT_EXCHANGE_CONFIG</a></td><td><p>0xFD0B</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_ATT_FIND_INFO_REQ_anchor">ACI_ATT_FIND_INFO_REQ</a></td><td><p>0xFD0C</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_ATT_FIND_BY_TYPE_VALUE_REQ_anchor">ACI_ATT_FIND_BY_TYPE_VALUE_REQ</a></td><td><p>0xFD0D</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_ATT_READ_BY_TYPE_REQ_anchor">ACI_ATT_READ_BY_TYPE_REQ</a></td><td><p>0xFD0E</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_ATT_READ_BY_GROUP_TYPE_REQ_anchor">ACI_ATT_READ_BY_GROUP_TYPE_REQ</a></td><td><p>0xFD0F</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_ATT_PREPARE_WRITE_REQ_anchor">ACI_ATT_PREPARE_WRITE_REQ</a></td><td><p>0xFD10</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_ATT_EXECUTE_WRITE_REQ_anchor">ACI_ATT_EXECUTE_WRITE_REQ</a></td><td><p>0xFD11</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_DISC_ALL_PRIMARY_SERVICES_anchor">ACI_GATT_DISC_ALL_PRIMARY_SERVICES</a></td><td><p>0xFD12</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_DISC_PRIMARY_SERVICE_BY_UUID_anchor">ACI_GATT_DISC_PRIMARY_SERVICE_BY_UUID</a></td><td><p>0xFD13</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_FIND_INCLUDED_SERVICES_anchor">ACI_GATT_FIND_INCLUDED_SERVICES</a></td><td><p>0xFD14</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_DISC_ALL_CHAR_OF_SERVICE_anchor">ACI_GATT_DISC_ALL_CHAR_OF_SERVICE</a></td><td><p>0xFD15</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_DISC_CHAR_BY_UUID_anchor">ACI_GATT_DISC_CHAR_BY_UUID</a></td><td><p>0xFD16</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_DISC_ALL_CHAR_DESC_anchor">ACI_GATT_DISC_ALL_CHAR_DESC</a></td><td><p>0xFD17</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_READ_CHAR_VALUE_anchor">ACI_GATT_READ_CHAR_VALUE</a></td><td><p>0xFD18</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_READ_USING_CHAR_UUID_anchor">ACI_GATT_READ_USING_CHAR_UUID</a></td><td><p>0xFD19</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_READ_LONG_CHAR_VALUE_anchor">ACI_GATT_READ_LONG_CHAR_VALUE</a></td><td><p>0xFD1A</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_READ_MULTIPLE_CHAR_VALUE_anchor">ACI_GATT_READ_MULTIPLE_CHAR_VALUE</a></td><td><p>0xFD1B</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_WRITE_CHAR_VALUE_anchor">ACI_GATT_WRITE_CHAR_VALUE</a></td><td><p>0xFD1C</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_WRITE_LONG_CHAR_VALUE_anchor">ACI_GATT_WRITE_LONG_CHAR_VALUE</a></td><td><p>0xFD1D</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_WRITE_CHAR_RELIABLE_anchor">ACI_GATT_WRITE_CHAR_RELIABLE</a></td><td><p>0xFD1E</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_WRITE_LONG_CHAR_DESC_anchor">ACI_GATT_WRITE_LONG_CHAR_DESC</a></td><td><p>0xFD1F</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_READ_LONG_CHAR_DESC_anchor">ACI_GATT_READ_LONG_CHAR_DESC</a></td><td><p>0xFD20</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_WRITE_CHAR_DESC_anchor">ACI_GATT_WRITE_CHAR_DESC</a></td><td><p>0xFD21</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_READ_CHAR_DESC_anchor">ACI_GATT_READ_CHAR_DESC</a></td><td><p>0xFD22</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_WRITE_WITHOUT_RESP_anchor">ACI_GATT_WRITE_WITHOUT_RESP</a></td><td><p>0xFD23</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_SIGNED_WRITE_WITHOUT_RESP_anchor">ACI_GATT_SIGNED_WRITE_WITHOUT_RESP</a></td><td><p>0xFD24</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_CONFIRM_INDICATION_anchor">ACI_GATT_CONFIRM_INDICATION</a></td><td><p>0xFD25</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_WRITE_RESP_anchor">ACI_GATT_WRITE_RESP</a></td><td><p>0xFD26</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_ALLOW_READ_anchor">ACI_GATT_ALLOW_READ</a></td><td><p>0xFD27</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_SET_SECURITY_PERMISSION_anchor">ACI_GATT_SET_SECURITY_PERMISSION</a></td><td><p>0xFD28</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_SET_DESC_VALUE_anchor">ACI_GATT_SET_DESC_VALUE</a></td><td><p>0xFD29</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_READ_HANDLE_VALUE_anchor">ACI_GATT_READ_HANDLE_VALUE</a></td><td><p>0xFD2A</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_UPDATE_CHAR_VALUE_EXT_anchor">ACI_GATT_UPDATE_CHAR_VALUE_EXT</a></td><td><p>0xFD2C</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_DENY_READ_anchor">ACI_GATT_DENY_READ</a></td><td><p>0xFD2D</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_SET_ACCESS_PERMISSION_anchor">ACI_GATT_SET_ACCESS_PERMISSION</a></td><td><p>0xFD2E</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_STORE_DB_anchor">ACI_GATT_STORE_DB</a></td><td><p>0xFD30</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_SEND_MULT_NOTIFICATION_anchor">ACI_GATT_SEND_MULT_NOTIFICATION</a></td><td><p>0xFD31</p>
</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_READ_MULTIPLE_VAR_CHAR_VALUE_anchor">ACI_GATT_READ_MULTIPLE_VAR_CHAR_VALUE</a></td><td><p>0xFD32</p>
</td><td></td><td></td><td></td><td></td><td></td></tr>
</table><h2><a name="ACI_GATT_INIT_anchor">ACI_GATT_INIT</a></h2><h3>Description</h3><p>Initializes the GATT layer for server and client roles. It also adds the GATT service with Service Changed Characteristic. <br>Until this command is issued the GATT channel does not process any commands even if the connection is opened. This command has to be given before using any of the GAP features.</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_ADD_SERVICE_anchor">ACI_GATT_ADD_SERVICE</a></h2><h3>Description</h3><p>Add a service to GATT Server. When a service is created in the server, the host needs to reserve the handle ranges for this service using Max_Attribute_Records parameter. This parameter specifies the maximum number of attribute records that can be added to this service (including the service attribute, include attribute, characteristic attribute, characteristic value attribute and characteristic descriptor attribute). Handle of the created service is returned in command complete event. Service declaration is taken from the service pool. <br>The attributes for characteristics and descriptors are allocated from the attribute pool.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Service_UUID_Type</p>
</td><td><p>1</p>
</td><td><p>UUID type: 0x01 = 16 bits UUID while 0x02 = 128 bits UUID</p>
</td><td></tr>
<tr><td><p>Service_UUID</p>
</td><td><p>2 or 16</p>
</td><td><p>16-bit UUID or 128-bit UUID</p>
</td><td></td></tr>
<tr><td><p>Service_Type</p>
</td><td><p>1</p>
</td><td><p>Service type.</p>
</td><td><li>0x01: Primary Service</li><li>0x02: Secondary Service</li></td></tr>
<tr><td><p>Max_Attribute_Records</p>
</td><td><p>1</p>
</td><td><p>Maximum number of attribute records that can be added to this service</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Service_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the Service.
When this service is added, a handle is allocated by the server for this service.
Server also allocates a range of handles for this service from serviceHandle to &lt;serviceHandle + max_attr_records - 1&gt;</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_INCLUDE_SERVICE_anchor">ACI_GATT_INCLUDE_SERVICE</a></h2><h3>Description</h3><p>Include a service given by Include_Start_Handle and Include_End_Handle to another service given by Service_Handle. Attribute server creates an INCLUDE definition attribute and return the handle of this attribute in Included_handle.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Service_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the Service to which another service has to be included.</p>
</td><td></tr>
<tr><td><p>Include_Start_Handle</p>
</td><td><p>2</p>
</td><td><p>Start Handle of the Service which has to be included in service</p>
</td><td></tr>
<tr><td><p>Include_End_Handle</p>
</td><td><p>2</p>
</td><td><p>End Handle of the Service which has to be included in service</p>
</td><td></tr>
<tr><td><p>Include_UUID_Type</p>
</td><td><p>1</p>
</td><td><p>UUID type: 0x01 = 16 bits UUID while 0x02 = 128 bits UUID</p>
</td><td></tr>
<tr><td><p>Include_UUID</p>
</td><td><p>2 or 16</p>
</td><td><p>16-bit UUID or 128-bit UUID</p>
</td><td></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Include_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the include declaration</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_ADD_CHAR_anchor">ACI_GATT_ADD_CHAR</a></h2><h3>Description</h3><p>Adds a characteristic to a service.<br>The command returns the handle of the declaration attribute. The attribute that holds the Characteristic Value is always allocated at the next handle (Char_Handle + 1). The Characteristic Value is immediately followed, in order, by:<br>- the Server Characteristic Configuration descriptor if CHAR_PROP_BROADCAST is selected;<br>- the Client Characteristic Configuration descriptor if CHAR_PROP_NOTIFY or CHAR_PROP_INDICATE properties is selected;<br>- the Characteristic Extended Properties descriptor if CHAR_PROP_EXT is selected.<br>For instance, if CHAR_PROP_NOTIFY is selected but not CHAR_PROP_BROADCAST nor CHAR_PROP_EXT, then the Client Characteristic Configuration attribute handle is Char_Handle + 2.<br>Additional descriptors can be added to the characteristic by calling the <a href="#ACI_GATT_ADD_CHAR_DESC_anchor">ACI_GATT_ADD_CHAR_DESC</a> command immediately after calling this command.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Service_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the Service to which the characteristic will be added</p>
</td><td></tr>
<tr><td><p>Char_UUID_Type</p>
</td><td><p>1</p>
</td><td><p>UUID type: 0x01 = 16 bits UUID while 0x02 = 128 bits UUID</p>
</td><td></tr>
<tr><td><p>Char_UUID</p>
</td><td><p>2 or 16</p>
</td><td><p>16-bit UUID or 128-bit UUID</p>
</td><td></td></tr>
<tr><td><p>Char_Value_Length</p>
</td><td><p>2</p>
</td><td><p>Maximum length of the characteristic value.</p>
</td><td></tr>
<tr><td><p>Char_Properties</p>
</td><td><p>1</p>
</td><td><p>Characteristic Properties (Volume 3, Part G, section 3.3.1.1 of Bluetooth Core Specification)</p>
</td><td><p>Bitmask of:</p><li>0x00: CHAR_PROP_NONE</li><li>0x01: CHAR_PROP_BROADCAST (Broadcast)</li><li>0x02: CHAR_PROP_READ (Read)</li><li>0x04: CHAR_PROP_WRITE_WITHOUT_RESP (Write w/o resp)</li><li>0x08: CHAR_PROP_WRITE (Write)</li><li>0x10: CHAR_PROP_NOTIFY (Notify)</li><li>0x20: CHAR_PROP_INDICATE (Indicate)</li><li>0x40: CHAR_PROP_SIGNED_WRITE (Authenticated Signed Writes)</li><li>0x80: CHAR_PROP_EXT (Extended Properties)</li></td></tr>
<tr><td><p>Security_Permissions</p>
</td><td><p>1</p>
</td><td><p>Security permission flags.</p>
</td><td><p>Bitmask of:</p><li>0x00: None</li><li>0x01: AUTHEN_READ (Need authentication to read)</li><li>0x02: AUTHOR_READ (Need authorization to read)</li><li>0x04: ENCRY_READ (Need encryption to read)</li><li>0x08: AUTHEN_WRITE (need authentication to write)</li><li>0x10: AUTHOR_WRITE (need authorization to write)</li><li>0x20: ENCRY_WRITE (need encryption to write)</li></td></tr>
<tr><td><p>GATT_Evt_Mask</p>
</td><td><p>1</p>
</td><td><p>GATT event mask.</p>
</td><td><p>Bitmask of:</p><li>0x00: GATT_DONT_NOTIFY_EVENTS</li><li>0x01: GATT_NOTIFY_ATTRIBUTE_WRITE</li><li>0x02: GATT_NOTIFY_WRITE_REQ_AND_WAIT_FOR_APPL_RESP</li><li>0x04: GATT_NOTIFY_READ_REQ_AND_WAIT_FOR_APPL_RESP</li><li>0x08: GATT_NOTIFY_NOTIFICATION_COMPLETION</li></td></tr>
<tr><td><p>Enc_Key_Size</p>
</td><td><p>1</p>
</td><td><p>Minimum encryption key size required to read the characteristic.</p>
</td><td><li>0x07 ... 0x10</li></td></tr>
<tr><td><p>Is_Variable</p>
</td><td><p>1</p>
</td><td><p>Specify if the characteristic value has a fixed length or
a variable length.</p>
</td><td><li>0x00: Fixed length</li><li>0x01: Variable length</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Char_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the characteristic that has been added (it is the handle of the characteristic declaration).</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_ADD_CHAR_DESC_anchor">ACI_GATT_ADD_CHAR_DESC</a></h2><h3>Description</h3><p>Adds a characteristic descriptor to a service.<br>Note that this command allocates the new handle for the descriptor after the currently allocated handles. It is therefore advisable to call this command following the call of the command <a href="#ACI_GATT_ADD_CHAR_anchor">ACI_GATT_ADD_CHAR</a> which created the characteristic containing this descriptor.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Service_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of service to which the characteristic belongs</p>
</td><td></tr>
<tr><td><p>Char_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the characteristic to which description has to be added</p>
</td><td></tr>
<tr><td><p>Char_Desc_Uuid_Type</p>
</td><td><p>1</p>
</td><td><p>UUID type: 0x01 = 16 bits UUID while 0x02 = 128 bits UUID</p>
</td><td></tr>
<tr><td><p>Char_Desc_Uuid</p>
</td><td><p>2 or 16</p>
</td><td><p>16-bit UUID or 128-bit UUID</p>
</td><td></td></tr>
<tr><td><p>Char_Desc_Value_Max_Len</p>
</td><td><p>1</p>
</td><td><p>The maximum length of the descriptor value</p>
</td><td></tr>
<tr><td><p>Char_Desc_Value_Length</p>
</td><td><p>1</p>
</td><td><p>Current Length of the characteristic descriptor value</p>
</td><td></tr>
<tr><td><p>Char_Desc_Value</p>
</td><td><p>Char_Desc_Value_Length</p>
</td><td><p>Value of the characteristic description</p>
</td><td></tr>
<tr><td><p>Security_Permissions</p>
</td><td><p>1</p>
</td><td><p>Security permission flags.</p>
</td><td><p>Bitmask of:</p><li>0x00: None</li><li>0x01: AUTHEN_READ (Need authentication to read)</li><li>0x02: AUTHOR_READ (Need authorization to read)</li><li>0x04: ENCRY_READ (Need encryption to read)</li><li>0x08: AUTHEN_WRITE (need authentication to write)</li><li>0x10: AUTHOR_WRITE (need authorization to write)</li><li>0x20: ENCRY_WRITE (need encryption to write)</li></td></tr>
<tr><td><p>Access_Permissions</p>
</td><td><p>1</p>
</td><td><p>Access permission</p>
</td><td><p>Bitmask of:</p><li>0x00: None</li><li>0x01: READ</li><li>0x02: WRITE</li><li>0x04: WRITE_WO_RESP</li><li>0x08: SIGNED_WRITE</li></td></tr>
<tr><td><p>GATT_Evt_Mask</p>
</td><td><p>1</p>
</td><td><p>GATT event mask.</p>
</td><td><p>Bitmask of:</p><li>0x00: GATT_DONT_NOTIFY_EVENTS</li><li>0x01: GATT_NOTIFY_ATTRIBUTE_WRITE</li><li>0x02: GATT_NOTIFY_WRITE_REQ_AND_WAIT_FOR_APPL_RESP</li><li>0x04: GATT_NOTIFY_READ_REQ_AND_WAIT_FOR_APPL_RESP</li></td></tr>
<tr><td><p>Enc_Key_Size</p>
</td><td><p>1</p>
</td><td><p>Minimum encryption key size required to read the characteristic.</p>
</td><td><li>0x07 ... 0x10</li></td></tr>
<tr><td><p>Is_Variable</p>
</td><td><p>1</p>
</td><td><p>Specify if the characteristic value has a fixed length or
a variable length.</p>
</td><td><li>0x00: Fixed length</li><li>0x01: Variable length</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Char_Desc_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the characteristic descriptor</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_UPDATE_CHAR_VALUE_anchor">ACI_GATT_UPDATE_CHAR_VALUE</a></h2><h3>Description</h3><p>Updates a characteristic value in a service. If notifications (or indications) are enabled on that characteristic, a notification (or indication) is sent to the client after sending this command. The command is queued into the STM32WB command queue. <br>If the buffer is full, because previous commands could not be still processed, the function will return BLE_STATUS_INSUFFICIENT_RESOURCES. This will happen if notifications (or indications) are enabled and the application calls <a href="#ACI_GATT_UPDATE_CHAR_VALUE_anchor">ACI_GATT_UPDATE_CHAR_VALUE</a> at an higher rate than what is allowed by the link. <br>Throughput on BLE link depends on connection interval and connection length parameters (decided by the Central, see <a href="#ACI_L2CAP_CONNECTION_PARAMETER_UPDATE_REQ_anchor">ACI_L2CAP_CONNECTION_PARAMETER_UPDATE_REQ</a> for more information on how to suggest new connection parameters from a Peripheral). If the application does not want to lose notifications because STM32WB buffer becomes full, it must retry again till the function returns BLE_STATUS_SUCCESS or any other error code.<br>Note that the characteristic is updated only if the command returns BLE_STATUS_SUCCESS or BLE_STATUS_SEC_PERMISSION_ERROR (0x65). The security permission error means that at least one client has not been notified due to security requirements not met.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Service_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of service to which the characteristic belongs</p>
</td><td></tr>
<tr><td><p>Char_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the characteristic declaration</p>
</td><td></tr>
<tr><td><p>Val_Offset</p>
</td><td><p>1</p>
</td><td><p>The offset from which the attribute value has to be updated.
If this is set to 0 and the attribute value is of variable length, then the length of the attribute will be set to the Char_Value_Length.
If the Val_Offset is set to a value greater than 0, then the length of the attribute will be set to the maximum length as specified for the attribute while adding the characteristic.</p>
</td><td></tr>
<tr><td><p>Char_Value_Length</p>
</td><td><p>1</p>
</td><td><p>Length of the characteristic value in octets</p>
</td><td></tr>
<tr><td><p>Char_Value</p>
</td><td><p>Char_Value_Length</p>
</td><td><p>Characteristic value</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><li><a href="#ACI_GATT_NOTIFICATION_COMPLETE_EVENT_anchor">ACI_GATT_NOTIFICATION_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_DEL_CHAR_anchor">ACI_GATT_DEL_CHAR</a></h2><h3>Description</h3><p>Deletes the specified characteristic from the service.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Serv_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of service to which the characteristic belongs</p>
</td><td></tr>
<tr><td><p>Char_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the characteristic which has to be deleted</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_DEL_SERVICE_anchor">ACI_GATT_DEL_SERVICE</a></h2><h3>Description</h3><p>Deletes the specified service from the GATT server database.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Serv_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the service to be deleted</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_DEL_INCLUDE_SERVICE_anchor">ACI_GATT_DEL_INCLUDE_SERVICE</a></h2><h3>Description</h3><p>Deletes the Include definition from the service.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Serv_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the service to which the include service belongs</p>
</td><td></tr>
<tr><td><p>Include_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the included service which has to be deleted</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_SET_EVENT_MASK_anchor">ACI_GATT_SET_EVENT_MASK</a></h2><h3>Description</h3><p>Masks events from the GATT. If the bit in the GATT_Evt_Mask is set to a one, then the event associated with that bit will be enabled.<br>The default configuration is all the events masked.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>GATT_Evt_Mask</p>
</td><td><p>4</p>
</td><td><p>GATT/ATT event mask.</p>
</td><td><li>0x00000001: ACI_GATT_ATTRIBUTE_MODIFIED_EVENT</li><li>0x00000002: ACI_GATT_PROC_TIMEOUT_EVENT</li><li>0x00000004: ACI_ATT_EXCHANGE_MTU_RESP_EVENT</li><li>0x00000008: ACI_ATT_FIND_INFO_RESP_EVENT</li><li>0x00000010: ACI_ATT_FIND_BY_TYPE_VALUE_RESP_EVENT</li><li>0x00000020: ACI_ATT_READ_BY_TYPE_RESP_EVENT</li><li>0x00000040: ACI_ATT_READ_RESP_EVENT</li><li>0x00000080: ACI_ATT_READ_BLOB_RESP_EVENT</li><li>0x00000100: ACI_ATT_READ_MULTIPLE_RESP_EVENT</li><li>0x00000200: ACI_ATT_READ_BY_GROUP_TYPE_RESP_EVENT</li><li>0x00000800: ACI_ATT_PREPARE_WRITE_RESP_EVENT</li><li>0x00001000: ACI_ATT_EXEC_WRITE_RESP_EVENT</li><li>0x00002000: ACI_GATT_INDICATION_EVENT</li><li>0x00004000: ACI_GATT_NOTIFICATION_EVENT</li><li>0x00008000: ACI_GATT_ERROR_RESP_EVENT</li><li>0x00010000: ACI_GATT_PROC_COMPLETE_EVENT</li><li>0x00020000: ACI_GATT_DISC_READ_CHAR_BY_UUID_RESP_EVENT</li><li>0x00040000: ACI_GATT_TX_POOL_AVAILABLE_EVENT</li><li>0x00100000: ACI_GATT_READ_EXT_EVENT</li><li>0x00200000: ACI_GATT_INDICATION_EXT_EVENT</li><li>0x00400000: ACI_GATT_NOTIFICATION_EXT_EVENT</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_EXCHANGE_CONFIG_anchor">ACI_GATT_EXCHANGE_CONFIG</a></h2><h3>Description</h3><p>Performs an ATT MTU exchange procedure.<br>When the ATT MTU exchange procedure is completed, a <a href="#ACI_ATT_EXCHANGE_MTU_RESP_EVENT_anchor">ACI_ATT_EXCHANGE_MTU_RESP_EVENT</a> event is generated. A <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a> event is also generated to indicate the end of the procedure.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_ATT_EXCHANGE_MTU_RESP_EVENT_anchor">ACI_ATT_EXCHANGE_MTU_RESP_EVENT</a></li><h2><a name="ACI_ATT_FIND_INFO_REQ_anchor">ACI_ATT_FIND_INFO_REQ</a></h2><h3>Description</h3><p>Sends a Find Information Request.<br>This command is used to obtain the mapping of attribute handles with their associated types. The responses of the procedure are given through the <a href="#ACI_ATT_FIND_INFO_RESP_EVENT_anchor">ACI_ATT_FIND_INFO_RESP_EVENT</a> event. The end of the procedure is indicated by a <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a> event.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Start_Handle</p>
</td><td><p>2</p>
</td><td><p>First requested handle number</p>
</td><td></tr>
<tr><td><p>End_Handle</p>
</td><td><p>2</p>
</td><td><p>Last requested handle number</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_ATT_FIND_INFO_RESP_EVENT_anchor">ACI_ATT_FIND_INFO_RESP_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_ATT_FIND_BY_TYPE_VALUE_REQ_anchor">ACI_ATT_FIND_BY_TYPE_VALUE_REQ</a></h2><h3>Description</h3><p>Sends a Find By Type Value Request<br>The Find By Type Value Request is used to obtain the handles of attributes that have a given 16-bit UUID attribute type and a given attribute value.<br>The responses of the procedure are given through the <a href="#ACI_ATT_FIND_BY_TYPE_VALUE_RESP_EVENT_anchor">ACI_ATT_FIND_BY_TYPE_VALUE_RESP_EVENT</a> event.<br>The end of the procedure is indicated by a <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a> event.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Start_Handle</p>
</td><td><p>2</p>
</td><td><p>First requested handle number</p>
</td><td></tr>
<tr><td><p>End_Handle</p>
</td><td><p>2</p>
</td><td><p>Last requested handle number</p>
</td><td></tr>
<tr><td><p>UUID</p>
</td><td><p>2</p>
</td><td><p>2 octet UUID to find (little-endian)</p>
</td><td></tr>
<tr><td><p>Attribute_Val_Length</p>
</td><td><p>1</p>
</td><td><p>Length of attribute value (maximum value is ATT_MTU - 7).</p>
</td><td></tr>
<tr><td><p>Attribute_Val</p>
</td><td><p>Attribute_Val_Length</p>
</td><td><p>Attribute value to find</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_ATT_FIND_BY_TYPE_VALUE_RESP_EVENT_anchor">ACI_ATT_FIND_BY_TYPE_VALUE_RESP_EVENT</a></li><li><a href="#ACI_GATT_ERROR_RESP_EVENT_anchor">ACI_GATT_ERROR_RESP_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_ATT_READ_BY_TYPE_REQ_anchor">ACI_ATT_READ_BY_TYPE_REQ</a></h2><h3>Description</h3><p>Sends a Read By Type Request.<br>The Read By Type Request is used to obtain the values of attributes where the attribute type is known but the handle is not known.<br>The responses are given through the <a href="#ACI_ATT_READ_BY_TYPE_RESP_EVENT_anchor">ACI_ATT_READ_BY_TYPE_RESP_EVENT</a> event.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Start_Handle</p>
</td><td><p>2</p>
</td><td><p>First requested handle number</p>
</td><td></tr>
<tr><td><p>End_Handle</p>
</td><td><p>2</p>
</td><td><p>Last requested handle number</p>
</td><td></tr>
<tr><td><p>UUID_Type</p>
</td><td><p>1</p>
</td><td><p>UUID type: 0x01 = 16 bits UUID while 0x02 = 128 bits UUID</p>
</td><td></tr>
<tr><td><p>UUID</p>
</td><td><p>2 or 16</p>
</td><td><p>16-bit UUID or 128-bit UUID</p>
</td><td></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_ATT_READ_BY_TYPE_RESP_EVENT_anchor">ACI_ATT_READ_BY_TYPE_RESP_EVENT</a></li><li><a href="#ACI_GATT_ERROR_RESP_EVENT_anchor">ACI_GATT_ERROR_RESP_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_ATT_READ_BY_GROUP_TYPE_REQ_anchor">ACI_ATT_READ_BY_GROUP_TYPE_REQ</a></h2><h3>Description</h3><p>Sends a Read By Group Type Request. <br>The Read By Group Type Request is used to obtain the values of grouping attributes where the attribute type is known but the handle is not known. Grouping attributes are defined at GATT layer. The grouping attribute types are: "Primary Service", "Secondary Service" and "Characteristic". <br>The responses of the procedure are given through the <a href="#ACI_ATT_READ_BY_GROUP_TYPE_RESP_EVENT_anchor">ACI_ATT_READ_BY_GROUP_TYPE_RESP_EVENT</a> event. <br>The end of the procedure is indicated by a <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a>.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Start_Handle</p>
</td><td><p>2</p>
</td><td><p>First requested handle number</p>
</td><td></tr>
<tr><td><p>End_Handle</p>
</td><td><p>2</p>
</td><td><p>Last requested handle number</p>
</td><td></tr>
<tr><td><p>UUID_Type</p>
</td><td><p>1</p>
</td><td><p>UUID type: 0x01 = 16 bits UUID while 0x02 = 128 bits UUID</p>
</td><td></tr>
<tr><td><p>UUID</p>
</td><td><p>2 or 16</p>
</td><td><p>16-bit UUID or 128-bit UUID</p>
</td><td></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_ATT_READ_BY_GROUP_TYPE_RESP_EVENT_anchor">ACI_ATT_READ_BY_GROUP_TYPE_RESP_EVENT</a></li><li><a href="#ACI_GATT_ERROR_RESP_EVENT_anchor">ACI_GATT_ERROR_RESP_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_ATT_PREPARE_WRITE_REQ_anchor">ACI_ATT_PREPARE_WRITE_REQ</a></h2><h3>Description</h3><p>Sends a Prepare Write Request.<br>The Prepare Write Request is used to request the server to prepare to write the value of an attribute. <br>The responses of the procedure are given through the <a href="#ACI_ATT_PREPARE_WRITE_RESP_EVENT_anchor">ACI_ATT_PREPARE_WRITE_RESP_EVENT</a> event. <br>The end of the procedure is indicated by a <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a>. </p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Attr_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the attribute to be written</p>
</td><td></tr>
<tr><td><p>Val_Offset</p>
</td><td><p>2</p>
</td><td><p>The offset of the first octet to be written</p>
</td><td></tr>
<tr><td><p>Attribute_Val_Length</p>
</td><td><p>1</p>
</td><td><p>Length of attribute value (maximum value is ATT_MTU - 5).</p>
</td><td></tr>
<tr><td><p>Attribute_Val</p>
</td><td><p>Attribute_Val_Length</p>
</td><td><p>The value of the attribute to be written</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_ATT_PREPARE_WRITE_RESP_EVENT_anchor">ACI_ATT_PREPARE_WRITE_RESP_EVENT</a></li><li><a href="#ACI_GATT_ERROR_RESP_EVENT_anchor">ACI_GATT_ERROR_RESP_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_ATT_EXECUTE_WRITE_REQ_anchor">ACI_ATT_EXECUTE_WRITE_REQ</a></h2><h3>Description</h3><p>Sends an Execute Write Request.<br>The Execute Write Request is used to request the server to write or cancel the write of all the prepared values currently held in the prepare queue from this client. <br>The result of the procedure is given through the <a href="#ACI_ATT_EXEC_WRITE_RESP_EVENT_anchor">ACI_ATT_EXEC_WRITE_RESP_EVENT</a> event. <br>The end of the procedure is indicated by a <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a> event. </p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Execute</p>
</td><td><p>1</p>
</td><td><p>Execute or cancel writes.</p>
</td><td><li>0x00: Cancel all prepared writes</li><li>0x01: Immediately write all pending prepared values</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_ATT_EXEC_WRITE_RESP_EVENT_anchor">ACI_ATT_EXEC_WRITE_RESP_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_DISC_ALL_PRIMARY_SERVICES_anchor">ACI_GATT_DISC_ALL_PRIMARY_SERVICES</a></h2><h3>Description</h3><p>Starts the GATT client procedure to discover all primary services on the server.<br>The responses of the procedure are given through the <a href="#ACI_ATT_READ_BY_GROUP_TYPE_RESP_EVENT_anchor">ACI_ATT_READ_BY_GROUP_TYPE_RESP_EVENT</a> event.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_ATT_READ_BY_GROUP_TYPE_RESP_EVENT_anchor">ACI_ATT_READ_BY_GROUP_TYPE_RESP_EVENT</a></li><li><a href="#ACI_GATT_ERROR_RESP_EVENT_anchor">ACI_GATT_ERROR_RESP_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_DISC_PRIMARY_SERVICE_BY_UUID_anchor">ACI_GATT_DISC_PRIMARY_SERVICE_BY_UUID</a></h2><h3>Description</h3><p>Starts the procedure to discover the primary services of the specified UUID on the server.<br>The responses of the procedure are given through the <a href="#ACI_ATT_FIND_BY_TYPE_VALUE_RESP_EVENT_anchor">ACI_ATT_FIND_BY_TYPE_VALUE_RESP_EVENT</a> event.<br>The end of the procedure is indicated by a <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a> event.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>UUID_Type</p>
</td><td><p>1</p>
</td><td><p>UUID type: 0x01 = 16 bits UUID while 0x02 = 128 bits UUID</p>
</td><td></tr>
<tr><td><p>UUID</p>
</td><td><p>2 or 16</p>
</td><td><p>16-bit UUID or 128-bit UUID</p>
</td><td></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_ATT_FIND_BY_TYPE_VALUE_RESP_EVENT_anchor">ACI_ATT_FIND_BY_TYPE_VALUE_RESP_EVENT</a></li><li><a href="#ACI_GATT_ERROR_RESP_EVENT_anchor">ACI_GATT_ERROR_RESP_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_FIND_INCLUDED_SERVICES_anchor">ACI_GATT_FIND_INCLUDED_SERVICES</a></h2><h3>Description</h3><p>Starts the procedure to find all included services.<br>The responses of the procedure are given through the <a href="#ACI_ATT_READ_BY_TYPE_RESP_EVENT_anchor">ACI_ATT_READ_BY_TYPE_RESP_EVENT</a> event.<br>The end of the procedure is indicated by a <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a> event.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Start_Handle</p>
</td><td><p>2</p>
</td><td><p>Start attribute handle of the service</p>
</td><td></tr>
<tr><td><p>End_Handle</p>
</td><td><p>2</p>
</td><td><p>End attribute handle of the service</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_ATT_READ_BY_TYPE_RESP_EVENT_anchor">ACI_ATT_READ_BY_TYPE_RESP_EVENT</a></li><li><a href="#ACI_GATT_ERROR_RESP_EVENT_anchor">ACI_GATT_ERROR_RESP_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_DISC_ALL_CHAR_OF_SERVICE_anchor">ACI_GATT_DISC_ALL_CHAR_OF_SERVICE</a></h2><h3>Description</h3><p>Starts the procedure to discover all the characteristics of a given service.<br>When the procedure is completed, a <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a> event is generated. Before procedure completion the response packets are given through <a href="#ACI_ATT_READ_BY_TYPE_RESP_EVENT_anchor">ACI_ATT_READ_BY_TYPE_RESP_EVENT</a> event.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Start_Handle</p>
</td><td><p>2</p>
</td><td><p>Start attribute handle of the service</p>
</td><td></tr>
<tr><td><p>End_Handle</p>
</td><td><p>2</p>
</td><td><p>End attribute handle of the service</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_ATT_READ_BY_TYPE_RESP_EVENT_anchor">ACI_ATT_READ_BY_TYPE_RESP_EVENT</a></li><li><a href="#ACI_GATT_ERROR_RESP_EVENT_anchor">ACI_GATT_ERROR_RESP_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_DISC_CHAR_BY_UUID_anchor">ACI_GATT_DISC_CHAR_BY_UUID</a></h2><h3>Description</h3><p>Starts the procedure to discover all the characteristics specified by a UUID.<br>When the procedure is completed, a <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a> event is generated. Before procedure completion the response packets are given through <a href="#ACI_GATT_DISC_READ_CHAR_BY_UUID_RESP_EVENT_anchor">ACI_GATT_DISC_READ_CHAR_BY_UUID_RESP_EVENT</a> event.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Start_Handle</p>
</td><td><p>2</p>
</td><td><p>Start attribute handle of the service</p>
</td><td></tr>
<tr><td><p>End_Handle</p>
</td><td><p>2</p>
</td><td><p>End attribute handle of the service</p>
</td><td></tr>
<tr><td><p>UUID_Type</p>
</td><td><p>1</p>
</td><td><p>UUID type: 0x01 = 16 bits UUID while 0x02 = 128 bits UUID</p>
</td><td></tr>
<tr><td><p>UUID</p>
</td><td><p>2 or 16</p>
</td><td><p>16-bit UUID or 128-bit UUID</p>
</td><td></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_GATT_DISC_READ_CHAR_BY_UUID_RESP_EVENT_anchor">ACI_GATT_DISC_READ_CHAR_BY_UUID_RESP_EVENT</a></li><li><a href="#ACI_GATT_ERROR_RESP_EVENT_anchor">ACI_GATT_ERROR_RESP_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_DISC_ALL_CHAR_DESC_anchor">ACI_GATT_DISC_ALL_CHAR_DESC</a></h2><h3>Description</h3><p>Starts the procedure to discover all characteristic descriptors on the server.<br>When the procedure is completed, a <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a> event is generated. Before procedure completion the response packets are given through <a href="#ACI_ATT_FIND_INFO_RESP_EVENT_anchor">ACI_ATT_FIND_INFO_RESP_EVENT</a> event.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Char_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the characteristic value</p>
</td><td></tr>
<tr><td><p>End_Handle</p>
</td><td><p>2</p>
</td><td><p>End handle of the characteristic</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_ATT_FIND_INFO_RESP_EVENT_anchor">ACI_ATT_FIND_INFO_RESP_EVENT</a></li><li><a href="#ACI_GATT_ERROR_RESP_EVENT_anchor">ACI_GATT_ERROR_RESP_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_READ_CHAR_VALUE_anchor">ACI_GATT_READ_CHAR_VALUE</a></h2><h3>Description</h3><p>Starts the procedure to read the attribute value.<br>When the procedure is completed, a <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a> event is generated. Before procedure completion the response packet is given through <a href="#ACI_ATT_READ_RESP_EVENT_anchor">ACI_ATT_READ_RESP_EVENT</a> event.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Attr_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the characteristic value to be read</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_ATT_READ_RESP_EVENT_anchor">ACI_ATT_READ_RESP_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_READ_USING_CHAR_UUID_anchor">ACI_GATT_READ_USING_CHAR_UUID</a></h2><h3>Description</h3><p>This command sends a Read By Type Request packet to the server in order to read the value attribute of the characteristics specified by the UUID.<br>When the procedure is completed, an <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a> event is generated. Before procedure completion, the response packet is given through one <a href="#ACI_GATT_DISC_READ_CHAR_BY_UUID_RESP_EVENT_anchor">ACI_GATT_DISC_READ_CHAR_BY_UUID_RESP_EVENT</a> event per reported attribute.<br>Note: the number of bytes of a value reported by <a href="#ACI_GATT_DISC_READ_CHAR_BY_UUID_RESP_EVENT_anchor">ACI_GATT_DISC_READ_CHAR_BY_UUID_RESP_EVENT</a> event cannot exceed BLE_EVT_MAX_PARAM_LEN - 7 i.e. 248 bytes for default value of BLE_EVT_MAX_PARAM_LEN.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Start_Handle</p>
</td><td><p>2</p>
</td><td><p>Starting handle of the range to be searched</p>
</td><td></tr>
<tr><td><p>End_Handle</p>
</td><td><p>2</p>
</td><td><p>End handle of the range to be searched</p>
</td><td></tr>
<tr><td><p>UUID_Type</p>
</td><td><p>1</p>
</td><td><p>UUID type: 0x01 = 16 bits UUID while 0x02 = 128 bits UUID</p>
</td><td></tr>
<tr><td><p>UUID</p>
</td><td><p>2 or 16</p>
</td><td><p>16-bit UUID or 128-bit UUID</p>
</td><td></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_GATT_DISC_READ_CHAR_BY_UUID_RESP_EVENT_anchor">ACI_GATT_DISC_READ_CHAR_BY_UUID_RESP_EVENT</a></li><li><a href="#ACI_GATT_ERROR_RESP_EVENT_anchor">ACI_GATT_ERROR_RESP_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_READ_LONG_CHAR_VALUE_anchor">ACI_GATT_READ_LONG_CHAR_VALUE</a></h2><h3>Description</h3><p>Starts the procedure to read a long characteristic value.<br>When the procedure is completed, a <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a> event is generated. Before procedure completion the response packets are given through <a href="#ACI_ATT_READ_BLOB_RESP_EVENT_anchor">ACI_ATT_READ_BLOB_RESP_EVENT</a> event.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Attr_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the characteristic value to be read</p>
</td><td></tr>
<tr><td><p>Val_Offset</p>
</td><td><p>2</p>
</td><td><p>Offset from which the value needs to be read</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_ATT_READ_BLOB_RESP_EVENT_anchor">ACI_ATT_READ_BLOB_RESP_EVENT</a></li><li><a href="#ACI_GATT_ERROR_RESP_EVENT_anchor">ACI_GATT_ERROR_RESP_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_READ_MULTIPLE_CHAR_VALUE_anchor">ACI_GATT_READ_MULTIPLE_CHAR_VALUE</a></h2><h3>Description</h3><p>Starts a procedure to read multiple characteristic values from a server.<br>The command must specify the handles of the characteristic values to be read.<br>When the procedure is completed, a <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a> event is generated. Before procedure completion the response packets are given through <a href="#ACI_ATT_READ_MULTIPLE_RESP_EVENT_anchor">ACI_ATT_READ_MULTIPLE_RESP_EVENT</a> event.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Number_of_Handles</p>
</td><td><p>1</p>
</td><td><p>Number of handles in the following table</p>
</td><td><li>0x02 ... 0x7E</li></td></tr>
<tr><td><p>Handle[i]</p>
</td><td><p>2</p>
</td><td><p>Attribute handle</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_ATT_READ_MULTIPLE_RESP_EVENT_anchor">ACI_ATT_READ_MULTIPLE_RESP_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_WRITE_CHAR_VALUE_anchor">ACI_GATT_WRITE_CHAR_VALUE</a></h2><h3>Description</h3><p>Starts the procedure to write a characteristic value.<br>When the procedure is completed, a <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a> event is generated.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Attr_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the characteristic value to be written</p>
</td><td></tr>
<tr><td><p>Attribute_Val_Length</p>
</td><td><p>1</p>
</td><td><p>Length of the value to be written</p>
</td><td></tr>
<tr><td><p>Attribute_Val</p>
</td><td><p>Attribute_Val_Length</p>
</td><td><p>Value to be written</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_GATT_ERROR_RESP_EVENT_anchor">ACI_GATT_ERROR_RESP_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_WRITE_LONG_CHAR_VALUE_anchor">ACI_GATT_WRITE_LONG_CHAR_VALUE</a></h2><h3>Description</h3><p>Starts the procedure to write a long characteristic value.<br>When the procedure is completed, a <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a> event is generated. During the procedure, <a href="#ACI_ATT_PREPARE_WRITE_RESP_EVENT_anchor">ACI_ATT_PREPARE_WRITE_RESP_EVENT</a> and <a href="#ACI_ATT_EXEC_WRITE_RESP_EVENT_anchor">ACI_ATT_EXEC_WRITE_RESP_EVENT</a> events are raised.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Attr_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the characteristic value to be written</p>
</td><td></tr>
<tr><td><p>Val_Offset</p>
</td><td><p>2</p>
</td><td><p>Offset at which the attribute has to be written</p>
</td><td></tr>
<tr><td><p>Attribute_Val_Length</p>
</td><td><p>1</p>
</td><td><p>Length of the value to be written</p>
</td><td></tr>
<tr><td><p>Attribute_Val</p>
</td><td><p>Attribute_Val_Length</p>
</td><td><p>Value to be written</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><li><a href="#ACI_ATT_PREPARE_WRITE_RESP_EVENT_anchor">ACI_ATT_PREPARE_WRITE_RESP_EVENT</a></li><li><a href="#ACI_ATT_EXEC_WRITE_RESP_EVENT_anchor">ACI_ATT_EXEC_WRITE_RESP_EVENT</a></li><h2><a name="ACI_GATT_WRITE_CHAR_RELIABLE_anchor">ACI_GATT_WRITE_CHAR_RELIABLE</a></h2><h3>Description</h3><p>Starts the procedure to write a characteristic reliably.<br>When the procedure is completed, a  <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a> event is generated. During the procedure, <a href="#ACI_ATT_PREPARE_WRITE_RESP_EVENT_anchor">ACI_ATT_PREPARE_WRITE_RESP_EVENT</a> and <a href="#ACI_ATT_EXEC_WRITE_RESP_EVENT_anchor">ACI_ATT_EXEC_WRITE_RESP_EVENT</a> events are raised.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Attr_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the attribute to be written</p>
</td><td></tr>
<tr><td><p>Val_Offset</p>
</td><td><p>2</p>
</td><td><p>Offset at which the attribute has to be written</p>
</td><td></tr>
<tr><td><p>Attribute_Val_Length</p>
</td><td><p>1</p>
</td><td><p>Length of the value to be written</p>
</td><td></tr>
<tr><td><p>Attribute_Val</p>
</td><td><p>Attribute_Val_Length</p>
</td><td><p>Value to be written</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><li><a href="#ACI_ATT_PREPARE_WRITE_RESP_EVENT_anchor">ACI_ATT_PREPARE_WRITE_RESP_EVENT</a></li><li><a href="#ACI_ATT_EXEC_WRITE_RESP_EVENT_anchor">ACI_ATT_EXEC_WRITE_RESP_EVENT</a></li><h2><a name="ACI_GATT_WRITE_LONG_CHAR_DESC_anchor">ACI_GATT_WRITE_LONG_CHAR_DESC</a></h2><h3>Description</h3><p>Starts the procedure to write a long characteristic descriptor.<br>When the procedure is completed, a <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a> event is generated. During the procedure, <a href="#ACI_ATT_PREPARE_WRITE_RESP_EVENT_anchor">ACI_ATT_PREPARE_WRITE_RESP_EVENT</a> and <a href="#ACI_ATT_EXEC_WRITE_RESP_EVENT_anchor">ACI_ATT_EXEC_WRITE_RESP_EVENT</a> events are raised.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Attr_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the attribute to be written</p>
</td><td></tr>
<tr><td><p>Val_Offset</p>
</td><td><p>2</p>
</td><td><p>Offset at which the attribute has to be written</p>
</td><td></tr>
<tr><td><p>Attribute_Val_Length</p>
</td><td><p>1</p>
</td><td><p>Length of the value to be written</p>
</td><td></tr>
<tr><td><p>Attribute_Val</p>
</td><td><p>Attribute_Val_Length</p>
</td><td><p>Value to be written</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><li><a href="#ACI_ATT_PREPARE_WRITE_RESP_EVENT_anchor">ACI_ATT_PREPARE_WRITE_RESP_EVENT</a></li><li><a href="#ACI_ATT_EXEC_WRITE_RESP_EVENT_anchor">ACI_ATT_EXEC_WRITE_RESP_EVENT</a></li><h2><a name="ACI_GATT_READ_LONG_CHAR_DESC_anchor">ACI_GATT_READ_LONG_CHAR_DESC</a></h2><h3>Description</h3><p>Starts the procedure to read a long characteristic value.<br>When the procedure is completed, a <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a> event is generated. Before procedure completion the response packets are given through <a href="#ACI_ATT_READ_BLOB_RESP_EVENT_anchor">ACI_ATT_READ_BLOB_RESP_EVENT</a> event.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Attr_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the characteristic descriptor</p>
</td><td></tr>
<tr><td><p>Val_Offset</p>
</td><td><p>2</p>
</td><td><p>Offset from which the value needs to be read</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_ATT_READ_BLOB_RESP_EVENT_anchor">ACI_ATT_READ_BLOB_RESP_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_WRITE_CHAR_DESC_anchor">ACI_GATT_WRITE_CHAR_DESC</a></h2><h3>Description</h3><p>Starts the procedure to write a characteristic descriptor.<br>When the procedure is completed, a <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a> event is generated.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Attr_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the attribute to be written</p>
</td><td></tr>
<tr><td><p>Attribute_Val_Length</p>
</td><td><p>1</p>
</td><td><p>Length of the value to be written</p>
</td><td></tr>
<tr><td><p>Attribute_Val</p>
</td><td><p>Attribute_Val_Length</p>
</td><td><p>Value to be written</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_READ_CHAR_DESC_anchor">ACI_GATT_READ_CHAR_DESC</a></h2><h3>Description</h3><p>Starts the procedure to read the descriptor specified.<br>When the procedure is completed, a <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a> event is generated.<br>Before procedure completion the response packet is given through <a href="#ACI_ATT_READ_RESP_EVENT_anchor">ACI_ATT_READ_RESP_EVENT</a> event.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Attr_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the descriptor to be read</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_ATT_READ_RESP_EVENT_anchor">ACI_ATT_READ_RESP_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_WRITE_WITHOUT_RESP_anchor">ACI_GATT_WRITE_WITHOUT_RESP</a></h2><h3>Description</h3><p>Starts the procedure to write a characteristic value without waiting for any response from the server. No events are generated after this command is executed. The length of the value to be written must not exceed (ATT_MTU - 3); it must also not exceed (BLE_EVT_MAX_PARAM_LEN - 5) i.e. 250 for BLE_EVT_MAX_PARAM_LEN default value.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Attr_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the characteristic value to be written</p>
</td><td></tr>
<tr><td><p>Attribute_Val_Length</p>
</td><td><p>1</p>
</td><td><p>Length of the value to be written</p>
</td><td></tr>
<tr><td><p>Attribute_Val</p>
</td><td><p>Attribute_Val_Length</p>
</td><td><p>Value to be written</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_SIGNED_WRITE_WITHOUT_RESP_anchor">ACI_GATT_SIGNED_WRITE_WITHOUT_RESP</a></h2><h3>Description</h3><p>Starts a signed write without response from the server.<br>The procedure is used to write a characteristic value with an authentication signature without waiting for any response from the server. It cannot be used when the link is encrypted. The length of the value to be written must not exceed (ATT_MTU - 15); it must also not exceed (BLE_EVT_MAX_PARAM_LEN - 5) i.e. 250 for BLE_EVT_MAX_PARAM_LEN default value.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Attr_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the characteristic value to be written</p>
</td><td></tr>
<tr><td><p>Attribute_Val_Length</p>
</td><td><p>1</p>
</td><td><p>Length of the value to be written</p>
</td><td></tr>
<tr><td><p>Attribute_Val</p>
</td><td><p>Attribute_Val_Length</p>
</td><td><p>Value to be written</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_CONFIRM_INDICATION_anchor">ACI_GATT_CONFIRM_INDICATION</a></h2><h3>Description</h3><p>Allow application to confirm indication. This command has to be sent when the application receives the event <a href="#ACI_GATT_INDICATION_EVENT_anchor">ACI_GATT_INDICATION_EVENT</a>.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_WRITE_RESP_anchor">ACI_GATT_WRITE_RESP</a></h2><h3>Description</h3><p>Allow or reject a write request from a client.<br>This command has to be sent by the application when it receives the<br><a href="#ACI_GATT_WRITE_PERMIT_REQ_EVENT_anchor">ACI_GATT_WRITE_PERMIT_REQ_EVENT</a>. If the write can be allowed, then the status and error code have to be set to 0. If the write cannot be allowed, then the status has to be set to 1 and the error code has to be set to the error code that has to be passed to the client.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Attr_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the attribute that was passed in the event ACI_GATT_WRITE_PERMIT_REQ_EVENT</p>
</td><td></tr>
<tr><td><p>Write_status</p>
</td><td><p>1</p>
</td><td><p>If the value can be written or not.</p>
</td><td><li>0x00: The value can be written to the attribute specified by attr_handle</li><li>0x01: The value cannot be written to the attribute specified by the attr_handle</li></td></tr>
<tr><td><p>Error_Code</p>
</td><td><p>1</p>
</td><td><p>The error code that has to be passed to the client in case the write has to be rejected</p>
</td><td></tr>
<tr><td><p>Attribute_Val_Length</p>
</td><td><p>1</p>
</td><td><p>Length of the value to be written as passed in the event ACI_GATT_WRITE_PERMIT_REQ_EVENT</p>
</td><td></tr>
<tr><td><p>Attribute_Val</p>
</td><td><p>Attribute_Val_Length</p>
</td><td><p>Value as passed in the event ACI_GATT_WRITE_PERMIT_REQ_EVENT</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_ALLOW_READ_anchor">ACI_GATT_ALLOW_READ</a></h2><h3>Description</h3><p>Allow the GATT server to send a response to a read request from a client.<br>The application has to send this command when it receives the<br><a href="#ACI_GATT_READ_PERMIT_REQ_EVENT_anchor">ACI_GATT_READ_PERMIT_REQ_EVENT</a> or <a href="#ACI_GATT_READ_MULTI_PERMIT_REQ_EVENT_anchor">ACI_GATT_READ_MULTI_PERMIT_REQ_EVENT</a>. This command indicates to the stack that the response can be sent to the client. So if the application wishes to update any of the attributes before they are read by the client, it must update the characteristic values using the <a href="#ACI_GATT_UPDATE_CHAR_VALUE_anchor">ACI_GATT_UPDATE_CHAR_VALUE</a> and then give this command. The application should perform the required operations within 30 seconds. Otherwise the GATT procedure will be timeout.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_SET_SECURITY_PERMISSION_anchor">ACI_GATT_SET_SECURITY_PERMISSION</a></h2><h3>Description</h3><p>This command sets the security permission for the attribute handle specified. Currently the setting of security permission is allowed only for client configuration descriptor.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Serv_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the service which contains the attribute whose security permission has to be modified</p>
</td><td></tr>
<tr><td><p>Attr_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the attribute whose security permission has to be modified</p>
</td><td></tr>
<tr><td><p>Security_Permissions</p>
</td><td><p>1</p>
</td><td><p>Security permission flags.</p>
</td><td><p>Bitmask of:</p><li>0x00: None</li><li>0x01: AUTHEN_READ (Need authentication to read)</li><li>0x02: AUTHOR_READ (Need authorization to read)</li><li>0x04: ENCRY_READ (Need encryption to read)</li><li>0x08: AUTHEN_WRITE (need authentication to write)</li><li>0x10: AUTHOR_WRITE (need authorization to write)</li><li>0x20: ENCRY_WRITE (need encryption to write)</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_SET_DESC_VALUE_anchor">ACI_GATT_SET_DESC_VALUE</a></h2><h3>Description</h3><p>This command sets the value of the descriptor specified by Char_Desc_Handle.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Serv_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the service which contains the characteristic descriptor</p>
</td><td></tr>
<tr><td><p>Char_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the characteristic which contains the descriptor</p>
</td><td></tr>
<tr><td><p>Char_Desc_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the descriptor whose value has to be set</p>
</td><td></tr>
<tr><td><p>Val_Offset</p>
</td><td><p>2</p>
</td><td><p>Offset from which the descriptor value has to be updated</p>
</td><td></tr>
<tr><td><p>Char_Desc_Value_Length</p>
</td><td><p>1</p>
</td><td><p>Length of the descriptor value</p>
</td><td></tr>
<tr><td><p>Char_Desc_Value</p>
</td><td><p>Char_Desc_Value_Length</p>
</td><td><p>Descriptor value</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_READ_HANDLE_VALUE_anchor">ACI_GATT_READ_HANDLE_VALUE</a></h2><h3>Description</h3><p>Reads the value of the attribute handle specified from the local GATT database.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Attr_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the attribute to read</p>
</td><td></tr>
<tr><td><p>Offset</p>
</td><td><p>2</p>
</td><td><p>Offset from which the value needs to be read</p>
</td><td></tr>
<tr><td><p>Value_Length_Requested</p>
</td><td><p>2</p>
</td><td><p>Maximum number of octets to be returned as attribute value</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Length</p>
</td><td><p>2</p>
</td><td><p>Length of the attribute value</p>
</td><td></tr>
<tr><td><p>Value_Length</p>
</td><td><p>2</p>
</td><td><p>Length in octets of the Value parameter</p>
</td><td></tr>
<tr><td><p>Value</p>
</td><td><p>Value_Length</p>
</td><td><p>Attribute value</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_UPDATE_CHAR_VALUE_EXT_anchor">ACI_GATT_UPDATE_CHAR_VALUE_EXT</a></h2><h3>Description</h3><p>This command is a more flexible version of <a href="#ACI_GATT_UPDATE_CHAR_VALUE_anchor">ACI_GATT_UPDATE_CHAR_VALUE</a> to support update of long attribute up to 512 bytes and indicate selectively the generation of Indication/Notification.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Conn_Handle_To_Notify</p>
</td><td><p>2</p>
</td><td><p>Specifies the client(s) to be notified.</p>
</td><td><li>0x0000: Notify all subscribed clients on their unenhanced ATT bearer</li><li>0x0001 ... 0x0EFF: Notify one client on the specified unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Notify one client on the specified enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Service_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of service to which the characteristic belongs</p>
</td><td></tr>
<tr><td><p>Char_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the characteristic declaration</p>
</td><td></tr>
<tr><td><p>Update_Type</p>
</td><td><p>1</p>
</td><td><dl class="docutils">
<dt>Allow Notification or Indication generation,</dt>
<dd>if enabled in the client characteristic configuration descriptor</dd>
</dl>
</td><td><p>Bitmask of:</p><li>0x00: Do not notify</li><li>0x01: Notification</li><li>0x02: Indication</li></td></tr>
<tr><td><p>Char_Length</p>
</td><td><p>2</p>
</td><td><p>Total length of the characteristic value.
In case of a variable size characteristic, this field specifies the new length of the characteristic value after the update; in case of fixed length characteristic this field is ignored.</p>
</td><td></tr>
<tr><td><p>Value_Offset</p>
</td><td><p>2</p>
</td><td><p>The offset from which the attribute value has to be updated.</p>
</td><td></tr>
<tr><td><p>Value_Length</p>
</td><td><p>1</p>
</td><td><p>Length of the Value parameter in octets</p>
</td><td></tr>
<tr><td><p>Value</p>
</td><td><p>Value_Length</p>
</td><td><p>Updated characteristic value</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><li><a href="#ACI_GATT_NOTIFICATION_COMPLETE_EVENT_anchor">ACI_GATT_NOTIFICATION_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_DENY_READ_anchor">ACI_GATT_DENY_READ</a></h2><h3>Description</h3><p>This command is used to deny the GATT server to send a response to a read request from a client.<br>The application may send this command when it receives the <a href="#ACI_GATT_READ_PERMIT_REQ_EVENT_anchor">ACI_GATT_READ_PERMIT_REQ_EVENT</a> or  <a href="#ACI_GATT_READ_MULTI_PERMIT_REQ_EVENT_anchor">ACI_GATT_READ_MULTI_PERMIT_REQ_EVENT</a>.<br>This command indicates to the stack that the client is not allowed to read the requested characteristic due to e.g. application restrictions.<br>The Error code shall be either 0x08 (Insufficient Authorization) or a value in the range 0x80-0x9F (Application Error).<br>The application should issue the <a href="#ACI_GATT_DENY_READ_anchor">ACI_GATT_DENY_READ</a>  or <a href="#ACI_GATT_ALLOW_READ_anchor">ACI_GATT_ALLOW_READ</a> command within 30 seconds from the reception of the <a href="#ACI_GATT_READ_PERMIT_REQ_EVENT_anchor">ACI_GATT_READ_PERMIT_REQ_EVENT</a> or  <a href="#ACI_GATT_READ_MULTI_PERMIT_REQ_EVENT_anchor">ACI_GATT_READ_MULTI_PERMIT_REQ_EVENT</a> events; otherwise the GATT procedure issues a timeout.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Error_Code</p>
</td><td><p>1</p>
</td><td><p>Error code for the command</p>
</td><td><li>0x08: Insufficient Authorization</li><li>0x80 ... 0x9F: Application Error</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_SET_ACCESS_PERMISSION_anchor">ACI_GATT_SET_ACCESS_PERMISSION</a></h2><h3>Description</h3><p>This command sets the access permission for the attribute handle specified.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Serv_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the service which contains the attribute whose access permission has to be modified</p>
</td><td></tr>
<tr><td><p>Attr_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the attribute whose security permission has to be modified</p>
</td><td></tr>
<tr><td><p>Access_Permissions</p>
</td><td><p>1</p>
</td><td><p>Access permission</p>
</td><td><p>Bitmask of:</p><li>0x00: None</li><li>0x01: READ</li><li>0x02: WRITE</li><li>0x04: WRITE_WO_RESP</li><li>0x08: SIGNED_WRITE</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_STORE_DB_anchor">ACI_GATT_STORE_DB</a></h2><h3>Description</h3><p>This command forces the saving of the GATT database for all active connections. Note that, by default, the GATT database is saved per active connection at the time of disconnection.</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_SEND_MULT_NOTIFICATION_anchor">ACI_GATT_SEND_MULT_NOTIFICATION</a></h2><h3>Description</h3><p>This command sends a Multiple Handle Value Notification over the ATT bearer specified in parameter. The handles provided as parameters must be the handles of the characteristic declarations.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Number_of_Handles</p>
</td><td><p>1</p>
</td><td><p>Number of handles in the following table</p>
</td><td><li>0x02 ... 0x7E</li></td></tr>
<tr><td><p>Handle[i]</p>
</td><td><p>2</p>
</td><td><p>Attribute handle</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_READ_MULTIPLE_VAR_CHAR_VALUE_anchor">ACI_GATT_READ_MULTIPLE_VAR_CHAR_VALUE</a></h2><h3>Description</h3><p>Starts a procedure to read multiple variable length characteristic values from a server.<br>The command must specify the handles of the characteristic values to be read.<br>When the procedure is completed, a <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a> event is generated. Before procedure completion the response packets are given through <a href="#ACI_ATT_READ_MULTIPLE_RESP_EVENT_anchor">ACI_ATT_READ_MULTIPLE_RESP_EVENT</a> event.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Number_of_Handles</p>
</td><td><p>1</p>
</td><td><p>Number of handles in the following table</p>
</td><td><li>0x02 ... 0x7E</li></td></tr>
<tr><td><p>Handle[i]</p>
</td><td><p>2</p>
</td><td><p>Attribute handle</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_ATT_READ_MULTIPLE_RESP_EVENT_anchor">ACI_ATT_READ_MULTIPLE_RESP_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI L2CAP commands_anchor">ACI L2CAP commands</a></h2><h2></h2><table width="800" border="1" class="reference">
<tr><th>Command</th><th>Opcode</th><th>BF</th><th>PO</th><th>LO</th><th>LB</th><th>BO</th></tr>
<tr><td><a href="#ACI_L2CAP_CONNECTION_PARAMETER_UPDATE_REQ_anchor">ACI_L2CAP_CONNECTION_PARAMETER_UPDATE_REQ</a></td><td><p>0xFD81</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_L2CAP_CONNECTION_PARAMETER_UPDATE_RESP_anchor">ACI_L2CAP_CONNECTION_PARAMETER_UPDATE_RESP</a></td><td><p>0xFD82</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_L2CAP_COC_CONNECT_anchor">ACI_L2CAP_COC_CONNECT</a></td><td><p>0xFD88</p>
</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_L2CAP_COC_CONNECT_CONFIRM_anchor">ACI_L2CAP_COC_CONNECT_CONFIRM</a></td><td><p>0xFD89</p>
</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_L2CAP_COC_RECONF_anchor">ACI_L2CAP_COC_RECONF</a></td><td><p>0xFD8A</p>
</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_L2CAP_COC_RECONF_CONFIRM_anchor">ACI_L2CAP_COC_RECONF_CONFIRM</a></td><td><p>0xFD8B</p>
</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_L2CAP_COC_DISCONNECT_anchor">ACI_L2CAP_COC_DISCONNECT</a></td><td><p>0xFD8C</p>
</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_L2CAP_COC_FLOW_CONTROL_anchor">ACI_L2CAP_COC_FLOW_CONTROL</a></td><td><p>0xFD8D</p>
</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_L2CAP_COC_TX_DATA_anchor">ACI_L2CAP_COC_TX_DATA</a></td><td><p>0xFD8E</p>
</td><td></td><td></td><td></td><td></td><td></td></tr>
</table><h2><a name="ACI_L2CAP_CONNECTION_PARAMETER_UPDATE_REQ_anchor">ACI_L2CAP_CONNECTION_PARAMETER_UPDATE_REQ</a></h2><h3>Description</h3><p>Sends an L2CAP connection parameter update request from the Peripheral to the Central.<br>An <a href="#ACI_L2CAP_CONNECTION_UPDATE_RESP_EVENT_anchor">ACI_L2CAP_CONNECTION_UPDATE_RESP_EVENT</a> event is raised when the Central responds to the request (accepts or rejects).</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Conn_Interval_Min</p>
</td><td><p>2</p>
</td><td><p>Minimum value for the connection event interval.
Time = N * 1.25 ms.</p>
</td><td><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Conn_Interval_Max</p>
</td><td><p>2</p>
</td><td><p>Maximum value for the connection event interval.
Time = N * 1.25 ms.</p>
</td><td><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Latency</p>
</td><td><p>2</p>
</td><td><p>Maximum Peripheral latency for the connection in number of connection events.</p>
</td><td><li>0x0000 ... 0x01F3</li></td></tr>
<tr><td><p>Timeout_Multiplier</p>
</td><td><p>2</p>
</td><td><p>Defines connection timeout parameter in the following manner: Timeout Multiplier * 10ms.</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_L2CAP_CONNECTION_UPDATE_RESP_EVENT_anchor">ACI_L2CAP_CONNECTION_UPDATE_RESP_EVENT</a></li><li><a href="#ACI_L2CAP_PROC_TIMEOUT_EVENT_anchor">ACI_L2CAP_PROC_TIMEOUT_EVENT</a></li><li><a href="#ACI_L2CAP_COMMAND_REJECT_EVENT_anchor">ACI_L2CAP_COMMAND_REJECT_EVENT</a></li><h2><a name="ACI_L2CAP_CONNECTION_PARAMETER_UPDATE_RESP_anchor">ACI_L2CAP_CONNECTION_PARAMETER_UPDATE_RESP</a></h2><h3>Description</h3><p>Accepts or rejects a connection update. This command should be sent in response to an <a href="#ACI_L2CAP_CONNECTION_UPDATE_REQ_EVENT_anchor">ACI_L2CAP_CONNECTION_UPDATE_REQ_EVENT</a> event from the controller. The accept parameter has to be set if the connection parameters given in the event are acceptable.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Conn_Interval_Min</p>
</td><td><p>2</p>
</td><td><p>Minimum value for the connection event interval.
Time = N * 1.25 ms.</p>
</td><td><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Conn_Interval_Max</p>
</td><td><p>2</p>
</td><td><p>Maximum value for the connection event interval.
Time = N * 1.25 ms.</p>
</td><td><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Latency</p>
</td><td><p>2</p>
</td><td><p>Maximum Peripheral latency for the connection in number of connection events.</p>
</td><td><li>0x0000 ... 0x01F3</li></td></tr>
<tr><td><p>Timeout_Multiplier</p>
</td><td><p>2</p>
</td><td><p>Defines connection timeout parameter in the following manner: Timeout Multiplier * 10ms.</p>
</td><td></tr>
<tr><td><p>Minimum_CE_Length</p>
</td><td><p>2</p>
</td><td><p>Information parameter about the minimum length of connection needed for this LE connection.
Time = N * 0.625 ms.</p>
</td><td><li>0x0000 (0.000 ms)  ... 0xFFFF (40959.375 ms) </li></td></tr>
<tr><td><p>Maximum_CE_Length</p>
</td><td><p>2</p>
</td><td><p>Information parameter about the maximum length of connection needed for this LE connection.
Time = N * 0.625 ms.</p>
</td><td><li>0x0000 (0.000 ms)  ... 0xFFFF (40959.375 ms) </li></td></tr>
<tr><td><p>Identifier</p>
</td><td><p>1</p>
</td><td><p>Identifier received in ACI_L2CAP_Connection_Update_Req event.</p>
</td><td></tr>
<tr><td><p>Accept</p>
</td><td><p>1</p>
</td><td><p>Specify if connection update parameters are acceptable or not.</p>
</td><td><li>0x00: Reject</li><li>0x01: Accept</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_L2CAP_COC_CONNECT_anchor">ACI_L2CAP_COC_CONNECT</a></h2><h3>Description</h3><p>This command sends a Credit Based Connection Request packet on the specified connection. See Bluetooth Core specification Vol.3 Part A.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>SPSM</p>
</td><td><p>2</p>
</td><td><p>Simplified Protocol/Service Multiplexer.</p>
</td><td><li>0x0001 ... 0x00FF</li></td></tr>
<tr><td><p>MTU</p>
</td><td><p>2</p>
</td><td><p>Maximum Transmission Unit.</p>
</td><td><li>23 ... 65535</li></td></tr>
<tr><td><p>MPS</p>
</td><td><p>2</p>
</td><td><p>Maximum payload size (in octets).</p>
</td><td><li>23 ... 248</li></td></tr>
<tr><td><p>Initial_Credits</p>
</td><td><p>2</p>
</td><td><p>Number of K-frames that can be received on the created channel(s) by the L2CAP layer entity sending this packet.</p>
</td><td><li>0 ... 65535</li></td></tr>
<tr><td><p>Channel_Number</p>
</td><td><p>1</p>
</td><td><p>Number of channels to be created. If this parameter is set to 0, it requests the creation of one LE credit based connection-oriented channel. Otherwise, it requests the creation of one or more enhanced credit based connection-oriented channels.</p>
</td><td><li>0 ... 5</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><li><a href="#ACI_L2CAP_COC_CONNECT_CONFIRM_EVENT_anchor">ACI_L2CAP_COC_CONNECT_CONFIRM_EVENT</a></li><li><a href="#ACI_L2CAP_PROC_TIMEOUT_EVENT_anchor">ACI_L2CAP_PROC_TIMEOUT_EVENT</a></li><li><a href="#ACI_L2CAP_COMMAND_REJECT_EVENT_anchor">ACI_L2CAP_COMMAND_REJECT_EVENT</a></li><h2><a name="ACI_L2CAP_COC_CONNECT_CONFIRM_anchor">ACI_L2CAP_COC_CONNECT_CONFIRM</a></h2><h3>Description</h3><p>This command sends a Credit Based Connection Response packet. It must be used upon receipt of a connection request through an <a href="#ACI_L2CAP_COC_CONNECT_EVENT_anchor">ACI_L2CAP_COC_CONNECT_EVENT</a> event. See Bluetooth Core specification Vol.3 Part A.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>MTU</p>
</td><td><p>2</p>
</td><td><p>Maximum Transmission Unit.</p>
</td><td><li>23 ... 65535</li></td></tr>
<tr><td><p>MPS</p>
</td><td><p>2</p>
</td><td><p>Maximum payload size (in octets).</p>
</td><td><li>23 ... 248</li></td></tr>
<tr><td><p>Initial_Credits</p>
</td><td><p>2</p>
</td><td><p>Number of K-frames that can be received on the created channel(s) by the L2CAP layer entity sending this packet.</p>
</td><td><li>0 ... 65535</li></td></tr>
<tr><td><p>Result</p>
</td><td><p>2</p>
</td><td><p>This parameter indicates the outcome of the request. A value of 0x0000 indicates success while a non-zero value indicates the request is refused.</p>
</td><td><li>0x0000 ... 0x000C</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Channel_Number</p>
</td><td><p>1</p>
</td><td><p>Number of created channels. It is the length of Channel_Index_List.</p>
</td><td><li>0 ... 5</li></td></tr>
<tr><td><p>Channel_Index_List</p>
</td><td><p>Channel_Number</p>
</td><td><p>List of channel indexes for which the primitive applies.</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_L2CAP_COC_RECONF_anchor">ACI_L2CAP_COC_RECONF</a></h2><h3>Description</h3><p>This command sends a Credit Based Reconfigure Request packet on the specified connection. See Bluetooth Core specification Vol.3 Part A.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>MTU</p>
</td><td><p>2</p>
</td><td><p>Maximum Transmission Unit.</p>
</td><td><li>23 ... 65535</li></td></tr>
<tr><td><p>MPS</p>
</td><td><p>2</p>
</td><td><p>Maximum payload size (in octets).</p>
</td><td><li>23 ... 248</li></td></tr>
<tr><td><p>Channel_Number</p>
</td><td><p>1</p>
</td><td><p>Number of created channels. It is the length of Channel_Index_List.</p>
</td><td><li>1 ... 5</li></td></tr>
<tr><td><p>Channel_Index_List</p>
</td><td><p>Channel_Number</p>
</td><td><p>List of channel indexes for which the primitive applies.</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><li><a href="#ACI_L2CAP_COC_RECONF_CONFIRM_EVENT_anchor">ACI_L2CAP_COC_RECONF_CONFIRM_EVENT</a></li><li><a href="#ACI_L2CAP_PROC_TIMEOUT_EVENT_anchor">ACI_L2CAP_PROC_TIMEOUT_EVENT</a></li><li><a href="#ACI_L2CAP_COMMAND_REJECT_EVENT_anchor">ACI_L2CAP_COMMAND_REJECT_EVENT</a></li><h2><a name="ACI_L2CAP_COC_RECONF_CONFIRM_anchor">ACI_L2CAP_COC_RECONF_CONFIRM</a></h2><h3>Description</h3><p>This command sends a Credit Based Reconfigure Response packet. It must be used upon receipt of a Credit Based Reconfigure Request through an <a href="#ACI_L2CAP_COC_RECONF_EVENT_anchor">ACI_L2CAP_COC_RECONF_EVENT</a> event. See Bluetooth Core specification Vol.3 Part A.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Result</p>
</td><td><p>2</p>
</td><td><p>This parameter indicates the outcome of the request. A value of 0x0000 indicates success while a non-zero value indicates the request is refused.</p>
</td><td><li>0x0000 ... 0x000C</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_L2CAP_COC_DISCONNECT_anchor">ACI_L2CAP_COC_DISCONNECT</a></h2><h3>Description</h3><p>This command sends a Disconnection Request signaling packet on the specified connection-oriented channel. See Bluetooth Core specification Vol.3 Part A.<br>The <a href="#ACI_L2CAP_COC_DISCONNECT_EVENT_anchor">ACI_L2CAP_COC_DISCONNECT_EVENT</a> event is received when the disconnection of the channel is effective.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Channel_Index</p>
</td><td><p>1</p>
</td><td><p>Index of the connection-oriented channel for which the primitive applies.</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><li><a href="#ACI_L2CAP_COC_DISCONNECT_EVENT_anchor">ACI_L2CAP_COC_DISCONNECT_EVENT</a></li><li><a href="#ACI_L2CAP_PROC_TIMEOUT_EVENT_anchor">ACI_L2CAP_PROC_TIMEOUT_EVENT</a></li><li><a href="#ACI_L2CAP_COMMAND_REJECT_EVENT_anchor">ACI_L2CAP_COMMAND_REJECT_EVENT</a></li><h2><a name="ACI_L2CAP_COC_FLOW_CONTROL_anchor">ACI_L2CAP_COC_FLOW_CONTROL</a></h2><h3>Description</h3><p>This command sends a Flow Control Credit signaling packet on the specified connection-oriented channel. See Bluetooth Core specification Vol.3 Part A.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Channel_Index</p>
</td><td><p>1</p>
</td><td><p>Index of the connection-oriented channel for which the primitive applies.</p>
</td><td></tr>
<tr><td><p>Credits</p>
</td><td><p>2</p>
</td><td><p>Number of credits the receiving device can increment, corresponding to the number of K-frames that can be sent to the peer device sending the Flow Control Credit packet.</p>
</td><td><li>1 ... 65535</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_L2CAP_COC_TX_DATA_anchor">ACI_L2CAP_COC_TX_DATA</a></h2><h3>Description</h3><p>This command sends a K-frame packet on the specified connection-oriented channel. See Bluetooth Core specification Vol.3 Part A.<br>Note: for the first K-frame of the SDU, the Information data shall contain the L2CAP SDU Length coded on two octets followed by the K-frame information payload. For the next K-frames of the SDU, the Information data shall only contain the K-frame information payload.<br>The Length value must not exceed (BLE_CMD_MAX_PARAM_LEN - 3) i.e. 252 for BLE_CMD_MAX_PARAM_LEN default value.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Channel_Index</p>
</td><td><p>1</p>
</td><td><p>Index of the connection-oriented channel for which the primitive applies.</p>
</td><td></tr>
<tr><td><p>Length</p>
</td><td><p>2</p>
</td><td><p>Length of Data (in octets)</p>
</td><td></tr>
<tr><td><p>Data</p>
</td><td><p>Length</p>
</td><td><p>Information data</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h1><a name="HCI/ACI events_anchor">HCI/ACI events</a></h1><p><a href="#HCI events_anchor">HCI events</a></p><p><a href="#HCI LE meta events_anchor">HCI LE meta events</a></p><p><a href="#ACI GAP events_anchor">ACI GAP events</a></p><p><a href="#ACI GATT/ATT events_anchor">ACI GATT/ATT events</a></p><p><a href="#ACI L2CAP events_anchor">ACI L2CAP events</a></p><p><a href="#ACI HAL events_anchor">ACI HAL events</a></p><p>Note: in the event tables, a "Y" in the "BF", "PO", "LO", "LB" or "BO" column, means that the corresponding event applies to the "Basic Features", "Peripheral Only", "Link Layer Only", "Link Layer Only Basic" or "Beacon Only" variant of the BLE stack, respectively.</p><h2><a name="HCI events_anchor">HCI events</a></h2><h2></h2><table width="800" border="1" class="reference">
<tr><th>Event name</th><th>Event code</th><th>BF</th><th>PO</th><th>LO</th><th>LB</th><th>BO</th></tr>
<tr><td><a href="#HCI_DISCONNECTION_COMPLETE_EVENT_anchor">HCI_DISCONNECTION_COMPLETE_EVENT</a></td><td><p>0x05</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_ENCRYPTION_CHANGE_EVENT_anchor">HCI_ENCRYPTION_CHANGE_EVENT</a></td><td><p>0x08</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_READ_REMOTE_VERSION_INFORMATION_COMPLETE_EVENT_anchor">HCI_READ_REMOTE_VERSION_INFORMATION_COMPLETE_EVENT</a></td><td><p>0x0C</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></td><td><p>0x0E</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td></tr>
<tr><td><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></td><td><p>0x0F</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td></tr>
<tr><td><a href="#HCI_HARDWARE_ERROR_EVENT_anchor">HCI_HARDWARE_ERROR_EVENT</a></td><td><p>0x10</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td></tr>
<tr><td><a href="#HCI_NUMBER_OF_COMPLETED_PACKETS_EVENT_anchor">HCI_NUMBER_OF_COMPLETED_PACKETS_EVENT</a></td><td><p>0x13</p>
</td><td></td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_ENCRYPTION_KEY_REFRESH_COMPLETE_EVENT_anchor">HCI_ENCRYPTION_KEY_REFRESH_COMPLETE_EVENT</a></td><td><p>0x30</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
</table><h2><a name="HCI_DISCONNECTION_COMPLETE_EVENT_anchor">HCI_DISCONNECTION_COMPLETE_EVENT</a></h2><h3>Description</h3><p>This event occurs when a connection is terminated. The status parameter indicates if the disconnection was successful or not. The reason parameter indicates the reason for the disconnection if the disconnection was successful. If the disconnection was not successful, the value of the reason parameter shall be ignored by the Host.<br>Note: if the connection is terminated by the remote device, the reason parameter of this event is set to the reason specified by the remote device only if it has an allowed value, otherwise the reason is forced to Remote User Terminated Connection error code (0x13). Allowed remote reason values are: Authentication Failure error code (0x05), Other End Terminated Connection error codes (0x13 to 0x15), Unsupported Remote Feature error code (0x1A), and Unacceptable Connection Parameters error code (0x3B).<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.7.5].</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Reason</p>
</td><td><p>1</p>
</td><td><p>Reason for disconnection (see Bluetooth spec. [Vol 1, Part F] Error Codes).</p>
</td><td></tr>
</table><h2><a name="HCI_ENCRYPTION_CHANGE_EVENT_anchor">HCI_ENCRYPTION_CHANGE_EVENT</a></h2><h3>Description</h3><p>The Encryption Change event is used to indicate that the change of the encryption mode has been completed. The Connection_Handle will be a Connection_Handle for an ACL connection. The Encryption_Enabled event parameter specifies the new Encryption_Enabled parameter for the Connection_Handle specified by the Connection_Handle event parameter. This event will occur on both devices to notify the Hosts when Encryption has changed for the specified Connection_Handle between two devices. Note: This event shall not be generated if encryption is paused or resumed; during a role switch, for example.<br>The meaning of the Encryption_Enabled parameter depends on whether the Host has indicated support for Secure Connections in the Secure_Connections_Host_Support parameter. When Secure_Connections_Host_Support is 'disabled' or the Connection_Handle refers to an LE link, the Controller shall only use Encryption_Enabled values 0x00 (OFF) and 0x01 (ON).<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.7.8].</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Encryption_Enabled</p>
</td><td><p>1</p>
</td><td><p>Link Level Encryption.</p>
</td><td><li>0x00: Link Level Encryption OFF</li><li>0x01: Link Level Encryption is ON with AES-CCM</li></td></tr>
</table><h2><a name="HCI_READ_REMOTE_VERSION_INFORMATION_COMPLETE_EVENT_anchor">HCI_READ_REMOTE_VERSION_INFORMATION_COMPLETE_EVENT</a></h2><h3>Description</h3><p>The Read Remote Version Information Complete event is used to indicate the completion of the process obtaining the version information of the remote Controller specified by the Connection_Handle event parameter. The Connection_Handle shall be for an ACL connection.<br>The Version event parameter defines the specification version of the LE Controller.<br>The Manufacturer_Name event parameter indicates the manufacturer of the remote Controller. The Subversion event parameter is controlled by the manufacturer and is implementation dependent. The Subversion event parameter defines the various revisions that each version of the Bluetooth hardware will go through as design processes change and errors are fixed. This allows the software to determine what Bluetooth hardware is being used and, if necessary, to work around various bugs in the hardware.<br>When the Connection_Handle is associated with an LE-U logical link, the Version event parameter shall be Link Layer VersNr parameter, the Manufacturer_Name event parameter shall be the CompId parameter, and the Subversion event parameter shall be the SubVersNr parameter.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.7.12].</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Version</p>
</td><td><p>1</p>
</td><td><p>Version of the Current LMP in the remote Controller</p>
</td><td></tr>
<tr><td><p>Manufacturer_Name</p>
</td><td><p>2</p>
</td><td><p>Manufacturer Name of the remote Controller</p>
</td><td></tr>
<tr><td><p>Subversion</p>
</td><td><p>2</p>
</td><td><p>Subversion of the LMP in the remote Controller</p>
</td><td></tr>
</table><h2><a name="HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></h2><h3>Description</h3><p>The Command Complete event is used by the Controller for most commands to transmit return status of a command and the other event parameters that are specified for the issued HCI command.<br>The Num_HCI_Command_Packets event parameter allows the Controller to indicate the number of HCI command packets the Host can send to the Controller.<br>If the Controller requires the Host to stop sending commands, the Num_HCI_Command_Packets event parameter will be set to zero. To indicate to the Host that the Controller is ready to receive HCI command packets, the Controller generates a Command Complete event with the Command_Opcode 0x0000, and the Num_HCI_Command_Packets event parameter is set to 1 or more. See each command for the parameters that are returned by this event.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Num_HCI_Command_Packets</p>
</td><td><p>1</p>
</td><td><p>The Number of HCI command packets which are allowed to be sent to the Controller from the Host.</p>
</td><td></tr>
<tr><td><p>Command_Opcode</p>
</td><td><p>2</p>
</td><td><p>Opcode of the command which caused this event.</p>
</td><td></tr>
<tr><td><p>Return_Parameters</p>
</td><td><p>variable</p>
</td><td><p>This is the return parameter(s) for the command specified in the Command_Opcode event parameter. See each command's definition for the list of return parameters associated with that command.</p>
</td><td></tr>
</table><h2><a name="HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></h2><h3>Description</h3><p>The Command Status event is used to indicate that the command described by the Command_Opcode parameter has been received, and that the Controller is currently performing the task for this command. This event is needed to provide mechanisms for asynchronous operation, which makes it possible to prevent the Host from waiting for a command to finish. If the command cannot begin to execute (a parameter error may have occurred, or the command may currently not be allowed), the Status event parameter will contain the corresponding error code, and no complete event will follow since the command was not started. The Num_HCI_Command_Packets event parameter allows the Controller to indicate the number of HCI command packets the Host can send to the Controller. If the Controller requires the Host to stop sending commands, the Num_HCI_Command_Packets event parameter will be set to zero. To indicate to the Host that the Controller is ready to receive HCI command packets, the Controller generates a Command Status event with Status 0x00 and Command_Opcode 0x0000, and the Num_HCI_Command_Packets event parameter is set to 1 or more.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Num_HCI_Command_Packets</p>
</td><td><p>1</p>
</td><td><p>The Number of HCI command packets which are allowed to be sent to the Controller from the Host.</p>
</td><td></tr>
<tr><td><p>Command_Opcode</p>
</td><td><p>2</p>
</td><td><p>Opcode of the command which caused this event.</p>
</td><td></tr>
</table><h2><a name="HCI_HARDWARE_ERROR_EVENT_anchor">HCI_HARDWARE_ERROR_EVENT</a></h2><h3>Description</h3><p>The Hardware Error event is used to indicate some implementation specific type of hardware failure for the controller. This event is used to notify the Host that a hardware failure has occurred in the Controller.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Hardware_Code</p>
</td><td><p>1</p>
</td><td><p>Hardware Error Event code.
Error code 0 is not used.
Error code 1 is bluecore act2 error detected (only for STM32WB).
Error code 2 is bluecore time overrun error detected (only for STM32WB).
Error code 3 is internal FIFO full.
Error code 4 is ISR delay error detected (only for STM32WB and only from cut 2.2).</p>
</td><td><li>0x01: event_act2 error</li><li>0x02: event_time_overrun error</li><li>0x03: event_fifo_full error</li><li>0x04: event_isr_delay_error</li></td></tr>
</table><h2><a name="HCI_NUMBER_OF_COMPLETED_PACKETS_EVENT_anchor">HCI_NUMBER_OF_COMPLETED_PACKETS_EVENT</a></h2><h3>Description</h3><p>The Number Of Completed Packets event is used by the Controller to indicate to the Host how many HCI Data Packets have been completed (transmitted or flushed) for each Connection_Handle since the previous Number Of Completed Packets event was sent to the Host. This means that the corresponding buffer space has been freed in the Controller. Based on this information, and the HC_Total_Num_ACL_Data_Packets and HC_Total_Num_Synchronous_Data_Packets return parameter of the Read_Buffer_Size command, the Host can determine for which Connection_Handles the following HCI Data Packets should be sent to the Controller. The Number Of Completed Packets event must not be sent before the corresponding Connection Complete event. While the Controller has HCI data packets in its buffer, it must keep sending the Number Of Completed Packets event to the Host at least periodically, until it finally reports that all the pending ACL Data Packets have been transmitted or flushed.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Number_of_Handles</p>
</td><td><p>1</p>
</td><td><p>The number of Connection_Handles and Num_HCI_Data_Packets parameters pairs contained in this event</p>
</td><td></tr>
<tr><td><p>Connection_Handle[i]</p>
</td><td><p>2</p>
</td><td><p>Connection handle</p>
</td><td></tr>
<tr><td><p>HC_Num_Of_Completed_Packets[i]</p>
</td><td><p>2</p>
</td><td><p>The number of HCI Data Packets that have been completed (transmitted or flushed) for the associated Connection_Handle since the previous time the event was returned.</p>
</td><td></tr>
</table><h2><a name="HCI_ENCRYPTION_KEY_REFRESH_COMPLETE_EVENT_anchor">HCI_ENCRYPTION_KEY_REFRESH_COMPLETE_EVENT</a></h2><h3>Description</h3><p>This event is used to indicate to the Host that the encryption key was refreshed on the given Connection_Handle. The Controller sends this event when the encryption key has been refreshed due to encryption being started or resumed.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
</table><h2><a name="HCI LE meta events_anchor">HCI LE meta events</a></h2><h2></h2><table width="800" border="1" class="reference">
<tr><th>Event name</th><th>LE subevent code</th><th>BF</th><th>PO</th><th>LO</th><th>LB</th><th>BO</th></tr>
<tr><td><a href="#HCI_LE_CONNECTION_COMPLETE_EVENT_anchor">HCI_LE_CONNECTION_COMPLETE_EVENT</a></td><td><p>0x01</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_LE_ADVERTISING_REPORT_EVENT_anchor">HCI_LE_ADVERTISING_REPORT_EVENT</a></td><td><p>0x02</p>
</td><td><p>Y</p>
</td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td></tr>
<tr><td><a href="#HCI_LE_CONNECTION_UPDATE_COMPLETE_EVENT_anchor">HCI_LE_CONNECTION_UPDATE_COMPLETE_EVENT</a></td><td><p>0x03</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_LE_READ_REMOTE_FEATURES_COMPLETE_EVENT_anchor">HCI_LE_READ_REMOTE_FEATURES_COMPLETE_EVENT</a></td><td><p>0x04</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_LE_LONG_TERM_KEY_REQUEST_EVENT_anchor">HCI_LE_LONG_TERM_KEY_REQUEST_EVENT</a></td><td><p>0x05</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_LE_DATA_LENGTH_CHANGE_EVENT_anchor">HCI_LE_DATA_LENGTH_CHANGE_EVENT</a></td><td><p>0x07</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_LE_READ_LOCAL_P256_PUBLIC_KEY_COMPLETE_EVENT_anchor">HCI_LE_READ_LOCAL_P256_PUBLIC_KEY_COMPLETE_EVENT</a></td><td><p>0x08</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_LE_GENERATE_DHKEY_COMPLETE_EVENT_anchor">HCI_LE_GENERATE_DHKEY_COMPLETE_EVENT</a></td><td><p>0x09</p>
</td><td></td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_LE_ENHANCED_CONNECTION_COMPLETE_EVENT_anchor">HCI_LE_ENHANCED_CONNECTION_COMPLETE_EVENT</a></td><td><p>0x0A</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_LE_DIRECTED_ADVERTISING_REPORT_EVENT_anchor">HCI_LE_DIRECTED_ADVERTISING_REPORT_EVENT</a></td><td><p>0x0B</p>
</td><td><p>Y</p>
</td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_LE_PHY_UPDATE_COMPLETE_EVENT_anchor">HCI_LE_PHY_UPDATE_COMPLETE_EVENT</a></td><td><p>0x0C</p>
</td><td><p>Y</p>
</td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td></tr>
<tr><td><a href="#HCI_LE_EXTENDED_ADVERTISING_REPORT_EVENT_anchor">HCI_LE_EXTENDED_ADVERTISING_REPORT_EVENT</a></td><td><p>0x0D</p>
</td><td></td><td></td><td><p>Y</p>
</td><td></td><td></td></tr>
<tr><td><a href="#HCI_LE_SCAN_TIMEOUT_EVENT_anchor">HCI_LE_SCAN_TIMEOUT_EVENT</a></td><td><p>0x11</p>
</td><td></td><td></td><td><p>Y</p>
</td><td></td><td></td></tr>
<tr><td><a href="#HCI_LE_ADVERTISING_SET_TERMINATED_EVENT_anchor">HCI_LE_ADVERTISING_SET_TERMINATED_EVENT</a></td><td><p>0x12</p>
</td><td></td><td></td><td><p>Y</p>
</td><td></td><td></td></tr>
<tr><td><a href="#HCI_LE_SCAN_REQUEST_RECEIVED_EVENT_anchor">HCI_LE_SCAN_REQUEST_RECEIVED_EVENT</a></td><td><p>0x13</p>
</td><td></td><td></td><td><p>Y</p>
</td><td></td><td></td></tr>
<tr><td><a href="#HCI_LE_CHANNEL_SELECTION_ALGORITHM_EVENT_anchor">HCI_LE_CHANNEL_SELECTION_ALGORITHM_EVENT</a></td><td><p>0x14</p>
</td><td></td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td></tr>
</table><h2><a name="HCI_LE_CONNECTION_COMPLETE_EVENT_anchor">HCI_LE_CONNECTION_COMPLETE_EVENT</a></h2><h3>Description</h3><p>The LE Connection Complete event indicates to both of the Hosts forming the connection that a new connection has been created. Upon the creation of the connection a Connection_Handle shall be assigned by the Controller, and passed to the Host in this event. If the connection establishment fails this event shall be provided to the Host that had issued the LE_Create_Connection command.<br>This event indicates to the Host which issued a LE_Create_Connection command and received a Command Status event if the connection establishment failed or was successful.<br>The Central_Clock_Accuracy parameter is only valid for a Peripheral. On a Central, this parameter is set to 0x00.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.7.65.1].</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Role</p>
</td><td><p>1</p>
</td><td><p>Role of the local device in the connection.</p>
</td><td><li>0x00: Central</li><li>0x01: Peripheral</li></td></tr>
<tr><td><p>Peer_Address_Type</p>
</td><td><p>1</p>
</td><td><p>The address type of the peer device.</p>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li></td></tr>
<tr><td><p>Peer_Address</p>
</td><td><p>6</p>
</td><td><p>Public Device Address or Random Device Address of the peer device</p>
</td><td></tr>
<tr><td><p>Conn_Interval</p>
</td><td><p>2</p>
</td><td><p>Connection interval used on this connection.
Time = N * 1.25 ms.</p>
</td><td><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Conn_Latency</p>
</td><td><p>2</p>
</td><td><p>Maximum Peripheral latency for the connection in number of connection events.</p>
</td><td><li>0x0000 ... 0x01F3</li></td></tr>
<tr><td><p>Supervision_Timeout</p>
</td><td><p>2</p>
</td><td><p>Supervision timeout for the LE Link.
It shall be a multiple of 10 ms and larger than (1 + connPeripheralLatency) * connInterval * 2.
Time = N * 10 ms.</p>
</td><td><li>0x000A (100 ms)  ... 0x0C80 (32000 ms) </li></td></tr>
<tr><td><p>Central_Clock_Accuracy</p>
</td><td><p>1</p>
</td><td><p>Central clock accuracy. Only valid for a Peripheral.</p>
</td><td><li>0x00: 500 ppm</li><li>0x01: 250 ppm</li><li>0x02: 150 ppm</li><li>0x03: 100 ppm</li><li>0x04: 75 ppm</li><li>0x05: 50 ppm</li><li>0x06: 30 ppm</li><li>0x07: 20 ppm</li></td></tr>
</table><h2><a name="HCI_LE_ADVERTISING_REPORT_EVENT_anchor">HCI_LE_ADVERTISING_REPORT_EVENT</a></h2><h3>Description</h3><p>The LE Advertising Report event indicates that a device or multiple devices have responded to an active scan or received some information during a passive scan. The Controller may queue these advertising reports and send information from multiple devices in one LE Advertising Report event.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.7.65.2].<br>Note: in the current BLE stack version, only one report is sent per event (Num_Reports = 1).</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Num_Reports</p>
</td><td><p>1</p>
</td><td><p>Number of responses in this event.</p>
</td><td><li>0x01</li></td></tr>
<tr><td><p>Event_Type[i]</p>
</td><td><p>1</p>
</td><td><p>Type of advertising report event:
ADV_IND: Connectable undirected advertising',
ADV_DIRECT_IND: Connectable directed advertising,
ADV_SCAN_IND: Scannable undirected advertising,
ADV_NONCONN_IND: Non connectable undirected advertising,
SCAN_RSP: Scan response.</p>
</td><td><li>0x00: ADV_IND</li><li>0x01: ADV_DIRECT_IND</li><li>0x02: ADV_SCAN_IND</li><li>0x03: ADV_NONCONN_IND</li><li>0x04: SCAN_RSP</li></td></tr>
<tr><td><p>Address_Type[i]</p>
</td><td><p>1</p>
</td><td><p>Address type
0x00 Public Device Address
0x01 Random Device Address
0x02 Public Identity Address (Corresponds to Resolved Private Address)
0x03 Random (Static) Identity Address (Corresponds to Resolved Private Address)</p>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li><li>0x02: Public Identity Address</li><li>0x03: Random (Static) Identity Address</li></td></tr>
<tr><td><p>Address[i]</p>
</td><td><p>6</p>
</td><td><p>Public Device Address or Random Device Address of the device to be connected.</p>
</td><td></tr>
<tr><td><p>Length_Data[i]</p>
</td><td><p>1</p>
</td><td><p>Length of the Data field for each device which responded.</p>
</td><td><li>0 ... 31</li></td></tr>
<tr><td><p>Data[i]</p>
</td><td><p>Length_Data[i]</p>
</td><td><p>Octets of advertising or scan response data formatted as defined in Bluetooth spec. v.5.4 [Vol 3, Part C, 11].</p>
</td><td></tr>
<tr><td><p>RSSI[i]</p>
</td><td><p>1</p>
</td><td><p>RSSI (signed integer).
Units: dBm.</p>
</td><td><li>127: RSSI not available</li><li>-127 ... 20</li></td></tr>
</table><h2><a name="HCI_LE_CONNECTION_UPDATE_COMPLETE_EVENT_anchor">HCI_LE_CONNECTION_UPDATE_COMPLETE_EVENT</a></h2><h3>Description</h3><p>The LE Connection Update Complete event is used to indicate that the Controller process to update the connection has completed.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.7.65.3].</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Conn_Interval</p>
</td><td><p>2</p>
</td><td><p>Connection interval used on this connection.
Time = N * 1.25 ms.</p>
</td><td><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Conn_Latency</p>
</td><td><p>2</p>
</td><td><p>Maximum Peripheral latency for the connection in number of connection events.</p>
</td><td><li>0x0000 ... 0x01F3</li></td></tr>
<tr><td><p>Supervision_Timeout</p>
</td><td><p>2</p>
</td><td><p>Supervision timeout for the LE Link.
It shall be a multiple of 10 ms and larger than (1 + connPeripheralLatency) * connInterval * 2.
Time = N * 10 ms.</p>
</td><td><li>0x000A (100 ms)  ... 0x0C80 (32000 ms) </li></td></tr>
</table><h2><a name="HCI_LE_READ_REMOTE_FEATURES_COMPLETE_EVENT_anchor">HCI_LE_READ_REMOTE_FEATURES_COMPLETE_EVENT</a></h2><h3>Description</h3><p>This event is used to indicate the completion of the process of the Controller obtaining the used features of the remote Bluetooth device specified by the Connection_Handle event parameter.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.7.65.4].</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>LE_Features</p>
</td><td><p>8</p>
</td><td><p>Bit Mask List of used LE features. For details see LE Link Layer specification.</p>
</td><td></tr>
</table><h2><a name="HCI_LE_LONG_TERM_KEY_REQUEST_EVENT_anchor">HCI_LE_LONG_TERM_KEY_REQUEST_EVENT</a></h2><h3>Description</h3><p>This event indicates that the Central is attempting to encrypt or re-encrypt the link and is requesting the Long Term Key from the Host.<br>See Bluetooth spec. v.5.4 [Vol 6, Part B, 5.1.3] and [Vol 4, Part E, 7.7.65.5].</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Random_Number</p>
</td><td><p>8</p>
</td><td><p>64-bit random number</p>
</td><td></tr>
<tr><td><p>Encrypted_Diversifier</p>
</td><td><p>2</p>
</td><td><p>16-bit encrypted diversifier</p>
</td><td></tr>
</table><h2><a name="HCI_LE_DATA_LENGTH_CHANGE_EVENT_anchor">HCI_LE_DATA_LENGTH_CHANGE_EVENT</a></h2><h3>Description</h3><p>This event notifies the Host of a change to either the maximum Payload length or the maximum transmission time of packets in either direction. The values reported are the maximum that will actually be used on the connection following the change, except that on the LE Coded PHY a packet taking up to 2704 us to transmit may be sent even though the corresponding parameter has a lower value.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.7.65.7] and [Vol 6, Part B, 4.5.10].</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>MaxTxOctets</p>
</td><td><p>2</p>
</td><td><p>The maximum number of payload octets in a Link Layer packet that the local Controller will send on this connection (connEffectiveMaxTxOctets).</p>
</td><td><li>0x001B ... 0x00FB</li></td></tr>
<tr><td><p>MaxTxTime</p>
</td><td><p>2</p>
</td><td><p>The maximum time that the local Controller will take to send a Link Layer packet on this connection (connEffectiveMaxTxTime).</p>
</td><td><li>0x0148 ... 0x4290</li></td></tr>
<tr><td><p>MaxRxOctets</p>
</td><td><p>2</p>
</td><td><p>The maximum number of payload octets in a Link Layer packet that the local Controller expects to receive on this connection (connEffectiveMaxRxOctets).</p>
</td><td><li>0x001B ... 0x00FB</li></td></tr>
<tr><td><p>MaxRxTime</p>
</td><td><p>2</p>
</td><td><p>The maximum time that the local Controller expects to take to receive a Link Layer packet on this connection (connEffectiveMaxRxTime).</p>
</td><td><li>0x0148 ... 0x4290</li></td></tr>
</table><h2><a name="HCI_LE_READ_LOCAL_P256_PUBLIC_KEY_COMPLETE_EVENT_anchor">HCI_LE_READ_LOCAL_P256_PUBLIC_KEY_COMPLETE_EVENT</a></h2><h3>Description</h3><p>This event is generated when local P-256 key generation is complete.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.7.65.8].</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Local_P256_Public_Key</p>
</td><td><p>64</p>
</td><td><p>Local P-256 public key.</p>
</td><td></tr>
</table><h2><a name="HCI_LE_GENERATE_DHKEY_COMPLETE_EVENT_anchor">HCI_LE_GENERATE_DHKEY_COMPLETE_EVENT</a></h2><h3>Description</h3><p>This event indicates that LE Diffie Hellman key generation has been completed by the Controller.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.7.65.9].</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>DHKey</p>
</td><td><p>32</p>
</td><td><p>Diffie Hellman Key</p>
</td><td></tr>
</table><h2><a name="HCI_LE_ENHANCED_CONNECTION_COMPLETE_EVENT_anchor">HCI_LE_ENHANCED_CONNECTION_COMPLETE_EVENT</a></h2><h3>Description</h3><p>This event indicates to both of the Hosts forming the connection that a new connection has been created. Upon the creation of the connection a Connection_Handle shall be assigned by the Controller, and passed to the Host in this event. If the connection establishment fails, this event shall be provided to the Host that had issued the LE_Create_Connection command.<br>If this event is unmasked and LE Connection Complete event is unmasked, only the LE Enhanced Connection Complete event is sent when a new connection has been completed.<br>This event indicates to the Host that issued a LE_Create_Connection command and received a Command Status event if the connection establishment failed or was successful.<br>The Central_Clock_Accuracy parameter is only valid for a Peripheral. On a Central, this parameter is set to 0x00.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.7.65.10].</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Role</p>
</td><td><p>1</p>
</td><td><p>Role of the local device in the connection.</p>
</td><td><li>0x00: Central</li><li>0x01: Peripheral</li></td></tr>
<tr><td><p>Peer_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Address type
0x00 Public Device Address
0x01 Random Device Address
0x02 Public Identity Address (Corresponds to Resolved Private Address)
0x03 Random (Static) Identity Address (Corresponds to Resolved Private Address)</p>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li><li>0x02: Public Identity Address</li><li>0x03: Random (Static) Identity Address</li></td></tr>
<tr><td><p>Peer_Address</p>
</td><td><p>6</p>
</td><td><p>Public Device Address, Random Device Address, Public Identity Address or Random (static) Identity Address of the device to be connected.</p>
</td><td></tr>
<tr><td><p>Local_Resolvable_Private_Address</p>
</td><td><p>6</p>
</td><td><p>Resolvable Private Address being used by the local device for this connection.
This is only valid when the Own_Address_Type is set to 0x02 or 0x03. For other Own_Address_Type values, the Controller shall return all zeros.</p>
</td><td></tr>
<tr><td><p>Peer_Resolvable_Private_Address</p>
</td><td><p>6</p>
</td><td><p>Resolvable Private Address being used by the peer device for this connection.
This is only valid for Peer_Address_Type 0x02 and 0x03. For other Peer_Address_Type values, the Controller shall return all zeros.</p>
</td><td></tr>
<tr><td><p>Conn_Interval</p>
</td><td><p>2</p>
</td><td><p>Connection interval used on this connection.
Time = N * 1.25 ms.</p>
</td><td><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Conn_Latency</p>
</td><td><p>2</p>
</td><td><p>Maximum Peripheral latency for the connection in number of connection events.</p>
</td><td><li>0x0000 ... 0x01F3</li></td></tr>
<tr><td><p>Supervision_Timeout</p>
</td><td><p>2</p>
</td><td><p>Supervision timeout for the LE Link.
It shall be a multiple of 10 ms and larger than (1 + connPeripheralLatency) * connInterval * 2.
Time = N * 10 ms.</p>
</td><td><li>0x000A (100 ms)  ... 0x0C80 (32000 ms) </li></td></tr>
<tr><td><p>Central_Clock_Accuracy</p>
</td><td><p>1</p>
</td><td><p>Central clock accuracy. Only valid for a Peripheral.</p>
</td><td><li>0x00: 500 ppm</li><li>0x01: 250 ppm</li><li>0x02: 150 ppm</li><li>0x03: 100 ppm</li><li>0x04: 75 ppm</li><li>0x05: 50 ppm</li><li>0x06: 30 ppm</li><li>0x07: 20 ppm</li></td></tr>
</table><h2><a name="HCI_LE_DIRECTED_ADVERTISING_REPORT_EVENT_anchor">HCI_LE_DIRECTED_ADVERTISING_REPORT_EVENT</a></h2><h3>Description</h3><p>This event indicates that directed advertisements have been received where the advertiser is using a resolvable private address for the InitA field in the ADV_DIRECT_IND PDU and the Scanning_Filter_Policy is equal to 0x02 or 0x03, see HCI_LE_Set_Scan_Parameters.<br>Direct_Address_Type and Direct_Address specify the address the directed advertisements are being directed to. Address_Type and Address specify the address of the advertiser sending the directed advertisements.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.7.65.11].</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Num_Reports</p>
</td><td><p>1</p>
</td><td><p>Number of responses in this event.</p>
</td><td><li>0x01</li></td></tr>
<tr><td><p>Event_Type[i]</p>
</td><td><p>1</p>
</td><td><p>Advertising type</p>
</td><td><li>0x01: Connectable directed advertising (ADV_DIRECT_IND)</li></td></tr>
<tr><td><p>Address_Type[i]</p>
</td><td><p>1</p>
</td><td><p>Address type
0x00 Public Device Address
0x01 Random Device Address
0x02 Public Identity Address (Corresponds to Resolved Private Address)
0x03 Random (Static) Identity Address (Corresponds to Resolved Private Address)</p>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li><li>0x02: Public Identity Address</li><li>0x03: Random (Static) Identity Address</li></td></tr>
<tr><td><p>Address[i]</p>
</td><td><p>6</p>
</td><td><p>Public Device Address, Random Device Address, Public Identity Address or Random (static) Identity Address of the advertising device.</p>
</td><td></tr>
<tr><td><p>Direct_Address_Type[i]</p>
</td><td><p>1</p>
</td><td><p>0x01 Random Device Address</p>
</td><td><li>0x01: Random Device Address</li></td></tr>
<tr><td><p>Direct_Address[i]</p>
</td><td><p>6</p>
</td><td><p>Random Device Address</p>
</td><td></tr>
<tr><td><p>RSSI[i]</p>
</td><td><p>1</p>
</td><td><p>RSSI (signed integer).
Units: dBm.</p>
</td><td><li>127: RSSI not available</li><li>-127 ... 20</li></td></tr>
</table><h2><a name="HCI_LE_PHY_UPDATE_COMPLETE_EVENT_anchor">HCI_LE_PHY_UPDATE_COMPLETE_EVENT</a></h2><h3>Description</h3><p>This event is used to indicate that the Controller has changed the transmitter PHY or receiver PHY in use.<br>If the Controller changes the transmitter PHY, the receiver PHY, or both PHYs, this event shall be issued.<br>If an LE_Set_PHY command was sent and the Controller determines that neither PHY will change as a result, it issues this event immediately.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.7.65.12].</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>TX_PHY</p>
</td><td><p>1</p>
</td><td><p>Transmitter PHY in use.</p>
</td><td><li>0x01: The transmitter PHY for the connection is LE 1M</li><li>0x02: The transmitter PHY for the connection is LE 2M</li><li>0x03: The transmitter PHY for the connection is LE Coded (not supported on STM32WB)</li></td></tr>
<tr><td><p>RX_PHY</p>
</td><td><p>1</p>
</td><td><p>Receiver PHY in use.</p>
</td><td><li>0x01: The receiver PHY for the connection is LE 1M</li><li>0x02: The receiver PHY for the connection is LE 2M</li><li>0x03: The receiver PHY for the connection is LE Coded (not supported on STM32WB)</li></td></tr>
</table><h2><a name="HCI_LE_EXTENDED_ADVERTISING_REPORT_EVENT_anchor">HCI_LE_EXTENDED_ADVERTISING_REPORT_EVENT</a></h2><h3>Description</h3><p>The HCI_LE_Extended_Advertising_Report event indicates that a Bluetooth device has responded to an active scan or has broadcast advertisements that were received during a passive scan.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.7.65.13].</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Num_Reports</p>
</td><td><p>1</p>
</td><td><p>Number of responses in this event.</p>
</td><td><li>0x01</li></td></tr>
<tr><td><p>Event_Type</p>
</td><td><p>2</p>
</td><td><p>Event type.</p>
</td><td><p>Bitmask of:</p><li>0x0001: Connectable advertising</li><li>0x0002: Scannable advertising</li><li>0x0004: Directed advertising</li><li>0x0008: Scan response</li><li>0x0010: Legacy advertising PDUs used</li><li>0x0020: Incomplete, more data to come</li><li>0x0040: Incomplete, data truncated, no more to come</li></td></tr>
<tr><td><p>Address_Type</p>
</td><td><p>1</p>
</td><td><p>Address type of the advertising device.</p>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li><li>0x02: Public Identity Address (corresponds to Resolved Private Address)</li><li>0x03: Random (static) Identity Address (corresponds to Resolved Private Address)</li><li>0xFF: No address provided (anonymous advertisement)</li></td></tr>
<tr><td><p>Address</p>
</td><td><p>6</p>
</td><td><p>Public Device Address, Random Device Address, Public Identity Address, or Random (static) Identity Address of the advertising device.</p>
</td><td></tr>
<tr><td><p>Primary_PHY</p>
</td><td><p>1</p>
</td><td><p>Primary advertising PHY.</p>
</td><td><li>0x01: Advertiser PHY is LE 1M</li></td></tr>
<tr><td><p>Secondary_PHY</p>
</td><td><p>1</p>
</td><td><p>Secondary advertising PHY.</p>
</td><td><li>0x00: No packets on the secondary advertising physical channel</li><li>0x01: Advertiser PHY is LE 1M</li><li>0x02: Advertiser PHY is LE 2M</li><li>0x03: Advertiser PHY is LE Coded</li></td></tr>
<tr><td><p>Advertising_SID</p>
</td><td><p>1</p>
</td><td><p>Value of the Advertising SID subfield in the ADI field of the PDU or, for scan responses, in the ADI field of the original scannable.</p>
</td><td><li>0xFF: No ADI field provided</li><li>0x00 ... 0x0F: Advertising SID subfield</li></td></tr>
<tr><td><p>TX_Power</p>
</td><td><p>1</p>
</td><td><p>Tx Power (signed integer).
Units: dBm.</p>
</td><td><li>127: Tx power information not available</li><li>-127 ... 20: Tx power</li></td></tr>
<tr><td><p>RSSI</p>
</td><td><p>1</p>
</td><td><p>RSSI (signed integer).
Units: dBm.</p>
</td><td><li>127: RSSI not available</li><li>-127 ... 20</li></td></tr>
<tr><td><p>Periodic_Adv_Interval</p>
</td><td><p>2</p>
</td><td><p>Interval of the periodic advertising.</p>
</td><td><li>0x0000: No periodic advertising</li></td></tr>
<tr><td><p>Direct_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Target device address type.</p>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li><li>0x02: Public Identity Address (Corresponds to Resolved Private Address)</li><li>0x03: Random (static) Identity Address (Corresponds to Resolved Private Address)</li><li>0xFE: Random Device Address (Controller unable to resolve)</li></td></tr>
<tr><td><p>Direct_Address</p>
</td><td><p>6</p>
</td><td><p>Public Device Address, Random Device Address, Public Identity Address, or Random (static) Identity Address of the target device.</p>
</td><td></tr>
<tr><td><p>Data_Length</p>
</td><td><p>1</p>
</td><td><p>Length of Data</p>
</td><td></tr>
<tr><td><p>Data</p>
</td><td><p>Data_Length</p>
</td><td><p>Octets of advertising or scan response data formatted as defined in Bluetooth spec. v.5.4 [Vol 3, Part C, 11].</p>
</td><td></tr>
</table><h2><a name="HCI_LE_SCAN_TIMEOUT_EVENT_anchor">HCI_LE_SCAN_TIMEOUT_EVENT</a></h2><h3>Description</h3><p>This event indicates that scanning has ended because the duration has expired.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.7.65.17].</p><h3>Event parameters</h3><p>None</p><h2><a name="HCI_LE_ADVERTISING_SET_TERMINATED_EVENT_anchor">HCI_LE_ADVERTISING_SET_TERMINATED_EVENT</a></h2><h3>Description</h3><p>This event indicates that the Controller has terminated advertising in the advertising sets specified by the Advertising_Handle parameter.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.7.65.18].</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Advertising_Handle</p>
</td><td><p>1</p>
</td><td><p>Used to identify an advertising set.</p>
</td><td><li>0x00 ... 0xEF</li></td></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Num_Completed_Ext_Adv_Events</p>
</td><td><p>1</p>
</td><td><p>Number of completed extended advertising events transmitted by the Controller.</p>
</td><td><li>0x00 ... 0xFF</li></td></tr>
</table><h2><a name="HCI_LE_SCAN_REQUEST_RECEIVED_EVENT_anchor">HCI_LE_SCAN_REQUEST_RECEIVED_EVENT</a></h2><h3>Description</h3><p>This event indicates that a SCAN_REQ PDU or an AUX_SCAN_REQ PDU has been received by the advertiser. The request contains a device address from a scanner that is allowed by the advertising filter policy. The advertising set is identified by Advertising_Handle.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.7.65.19].</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Advertising_Handle</p>
</td><td><p>1</p>
</td><td><p>Used to identify an advertising set.</p>
</td><td><li>0x00 ... 0xEF</li></td></tr>
<tr><td><p>Scanner_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Scanner address type.</p>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li><li>0x02: Public Identity Address (corresponds to Resolved Private Address)</li><li>0x03: Random (static) Identity Address (corresponds to Resolved Private Address)</li></td></tr>
<tr><td><p>Scanner_Address</p>
</td><td><p>6</p>
</td><td><p>Public Device Address, Random Device Address, Public Identity Address, or Random (static) Identity Address of the scanner device.</p>
</td><td></tr>
</table><h2><a name="HCI_LE_CHANNEL_SELECTION_ALGORITHM_EVENT_anchor">HCI_LE_CHANNEL_SELECTION_ALGORITHM_EVENT</a></h2><h3>Description</h3><p>This event indicates which channel selection algorithm is used on a data physical channel connection.<br>See Bluetooth spec. v.5.4 [Vol 4, Part E, 7.7.65.20].</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Channel_Selection_Algorithm</p>
</td><td><p>1</p>
</td><td><p>LE Channel Selection Algorithm.</p>
</td><td><li>0x00: Algorithm #1 is used</li><li>0x01: Algorithm #2 is used</li></td></tr>
</table><h2><a name="ACI GAP events_anchor">ACI GAP events</a></h2><h2></h2><table width="800" border="1" class="reference">
<tr><th>Event name</th><th>Vendor specific subevent code</th><th>BF</th><th>PO</th><th>LO</th><th>LB</th><th>BO</th></tr>
<tr><td><a href="#ACI_GAP_LIMITED_DISCOVERABLE_EVENT_anchor">ACI_GAP_LIMITED_DISCOVERABLE_EVENT</a></td><td><p>0x0400</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_PAIRING_COMPLETE_EVENT_anchor">ACI_GAP_PAIRING_COMPLETE_EVENT</a></td><td><p>0x0401</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_PASS_KEY_REQ_EVENT_anchor">ACI_GAP_PASS_KEY_REQ_EVENT</a></td><td><p>0x0402</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_AUTHORIZATION_REQ_EVENT_anchor">ACI_GAP_AUTHORIZATION_REQ_EVENT</a></td><td><p>0x0403</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_PERIPHERAL_SECURITY_INITIATED_EVENT_anchor">ACI_GAP_PERIPHERAL_SECURITY_INITIATED_EVENT</a></td><td><p>0x0404</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_BOND_LOST_EVENT_anchor">ACI_GAP_BOND_LOST_EVENT</a></td><td><p>0x0405</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_PROC_COMPLETE_EVENT_anchor">ACI_GAP_PROC_COMPLETE_EVENT</a></td><td><p>0x0407</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_ADDR_NOT_RESOLVED_EVENT_anchor">ACI_GAP_ADDR_NOT_RESOLVED_EVENT</a></td><td><p>0x0408</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_NUMERIC_COMPARISON_VALUE_EVENT_anchor">ACI_GAP_NUMERIC_COMPARISON_VALUE_EVENT</a></td><td><p>0x0409</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GAP_KEYPRESS_NOTIFICATION_EVENT_anchor">ACI_GAP_KEYPRESS_NOTIFICATION_EVENT</a></td><td><p>0x040A</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
</table><h2><a name="ACI_GAP_LIMITED_DISCOVERABLE_EVENT_anchor">ACI_GAP_LIMITED_DISCOVERABLE_EVENT</a></h2><h3>Description</h3><p>This event is generated by the controller when the limited discoverable mode ends due to timeout. The timeout is 180 seconds.</p><h3>Event parameters</h3><p>None</p><h2><a name="ACI_GAP_PAIRING_COMPLETE_EVENT_anchor">ACI_GAP_PAIRING_COMPLETE_EVENT</a></h2><h3>Description</h3><p>This event is generated when the pairing process has completed successfully or a pairing procedure timeout has occurred or the pairing has failed. This is to notify the application that we have paired with a remote device so that it can take further actions or to notify that a timeout has occurred so that the upper layer can decide to disconnect the link.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the connection where this event occurred.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Pairing status</p>
</td><td><li>0x00: Success</li><li>0x01: SMP timeout</li><li>0x02: Pairing failed</li><li>0x03: Encryption failed</li></td></tr>
<tr><td><p>Reason</p>
</td><td><p>1</p>
</td><td><p>Pairing failed reason code (valid in case of pairing failed status)</p>
</td><td><li>0x01: Passkey Entry Failed</li><li>0x02: OOB Not Available</li><li>0x03: Authentication Requirements</li><li>0x04: Confirm Value Failed</li><li>0x05: Pairing Not Supported</li><li>0x06: Encryption Key Size</li><li>0x07: Command Not Supported</li><li>0x08: Unspecified Reason</li><li>0x09: Repeated Attempts</li><li>0x0A: Invalid Parameters</li><li>0x0B: DHKey Check Failed</li><li>0x0C: Numeric Comparison Failed</li><li>0x0F: Key Rejected</li></td></tr>
</table><h2><a name="ACI_GAP_PASS_KEY_REQ_EVENT_anchor">ACI_GAP_PASS_KEY_REQ_EVENT</a></h2><h3>Description</h3><p>This event is generated by the Security manager to the application when a passkey is required for pairing. When this event is received, the application has to respond with the <a href="#ACI_GAP_PASS_KEY_RESP_anchor">ACI_GAP_PASS_KEY_RESP</a> command.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the connection where this event occurred.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
</table><h2><a name="ACI_GAP_AUTHORIZATION_REQ_EVENT_anchor">ACI_GAP_AUTHORIZATION_REQ_EVENT</a></h2><h3>Description</h3><p>This event is generated by the Security manager to the application when the application has set that authorization is required for reading/writing of attributes. This event will be generated as soon as the pairing is complete. When this event is received, <a href="#ACI_GAP_AUTHORIZATION_RESP_anchor">ACI_GAP_AUTHORIZATION_RESP</a> command should be used to respond by the application.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the connection where this event occurred.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
</table><h2><a name="ACI_GAP_PERIPHERAL_SECURITY_INITIATED_EVENT_anchor">ACI_GAP_PERIPHERAL_SECURITY_INITIATED_EVENT</a></h2><h3>Description</h3><p>This event is generated when the Peripheral Security Request is successfully sent to the Central.</p><h3>Event parameters</h3><p>None</p><h2><a name="ACI_GAP_BOND_LOST_EVENT_anchor">ACI_GAP_BOND_LOST_EVENT</a></h2><h3>Description</h3><p>This event is generated when a pairing request is issued in response to a Peripheral Security Request from a Central which has previously bonded with the Peripheral. When this event is received, the upper layer has to issue the command <a href="#ACI_GAP_ALLOW_REBOND_anchor">ACI_GAP_ALLOW_REBOND</a> in order to allow the Peripheral to continue the pairing process with the Central.</p><h3>Event parameters</h3><p>None</p><h2><a name="ACI_GAP_PROC_COMPLETE_EVENT_anchor">ACI_GAP_PROC_COMPLETE_EVENT</a></h2><h3>Description</h3><p>This event is sent by the GAP to the upper layers when a procedure previously started has been terminated by the upper layer or has completed for any other reason</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Procedure_Code</p>
</td><td><p>1</p>
</td><td><p>Terminated procedure.</p>
</td><td><li>0x01: GAP_LIMITED_DISCOVERY_PROC</li><li>0x02: GAP_GENERAL_DISCOVERY_PROC</li><li>0x08: GAP_AUTO_CONNECTION_ESTABLISHMENT_PROC</li><li>0x10: GAP_GENERAL_CONNECTION_ESTABLISHMENT_PROC</li><li>0x20: GAP_SELECTIVE_CONNECTION_ESTABLISHMENT_PROC</li><li>0x40: GAP_DIRECT_CONNECTION_ESTABLISHMENT_PROC</li><li>0x80: GAP_OBSERVATION_PROC</li></td></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Data_Length</p>
</td><td><p>1</p>
</td><td><p>Length of Data in octets</p>
</td><td></tr>
<tr><td><p>Data</p>
</td><td><p>Data_Length</p>
</td><td><p>Procedure Specific Data:
- For Name Discovery Procedure: the name of the peer device if the procedure completed successfully.</p>
</td><td></tr>
</table><h2><a name="ACI_GAP_ADDR_NOT_RESOLVED_EVENT_anchor">ACI_GAP_ADDR_NOT_RESOLVED_EVENT</a></h2><h3>Description</h3><p>This event is sent only by a privacy enabled peripheral with a non-empty bonded device list. The event is sent to the application when the peripheral is unsuccessful in resolving the resolvable address of the peer device after connecting to it.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the connection where this event occurred.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
</table><h2><a name="ACI_GAP_NUMERIC_COMPARISON_VALUE_EVENT_anchor">ACI_GAP_NUMERIC_COMPARISON_VALUE_EVENT</a></h2><h3>Description</h3><p>This event is sent only during SC Pairing, when Numeric Comparison Association model is selected, in order to show the Numeric Value generated, and to ask for Confirmation to the User. When this event is received, the application has to respond with the <a href="#ACI_GAP_NUMERIC_COMPARISON_RESP_anchor">ACI_GAP_NUMERIC_COMPARISON_RESP</a> command.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the connection where this event occurred.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Numeric_Value</p>
</td><td><p>4</p>
</td><td><p>Generated numeric value.</p>
</td><td></tr>
</table><h2><a name="ACI_GAP_KEYPRESS_NOTIFICATION_EVENT_anchor">ACI_GAP_KEYPRESS_NOTIFICATION_EVENT</a></h2><h3>Description</h3><p>This event is sent only during SC Pairing, when Keypress Notifications are supported, in order to show the input type signaled by the peer device, having Keyboard only I/O capabilities. When this event is received, no action is required to the User.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the connection where this event occurred.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Notification_Type</p>
</td><td><p>1</p>
</td><td><p>Type of Keypress input notified/signaled by peer device (having Keyboard only I/O capabilities.</p>
</td><td></tr>
</table><h2><a name="ACI GATT/ATT events_anchor">ACI GATT/ATT events</a></h2><h2></h2><table width="800" border="1" class="reference">
<tr><th>Event name</th><th>Vendor specific subevent code</th><th>BF</th><th>PO</th><th>LO</th><th>LB</th><th>BO</th></tr>
<tr><td><a href="#ACI_GATT_ATTRIBUTE_MODIFIED_EVENT_anchor">ACI_GATT_ATTRIBUTE_MODIFIED_EVENT</a></td><td><p>0x0C01</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_PROC_TIMEOUT_EVENT_anchor">ACI_GATT_PROC_TIMEOUT_EVENT</a></td><td><p>0x0C02</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_ATT_EXCHANGE_MTU_RESP_EVENT_anchor">ACI_ATT_EXCHANGE_MTU_RESP_EVENT</a></td><td><p>0x0C03</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_ATT_FIND_INFO_RESP_EVENT_anchor">ACI_ATT_FIND_INFO_RESP_EVENT</a></td><td><p>0x0C04</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_ATT_FIND_BY_TYPE_VALUE_RESP_EVENT_anchor">ACI_ATT_FIND_BY_TYPE_VALUE_RESP_EVENT</a></td><td><p>0x0C05</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_ATT_READ_BY_TYPE_RESP_EVENT_anchor">ACI_ATT_READ_BY_TYPE_RESP_EVENT</a></td><td><p>0x0C06</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_ATT_READ_RESP_EVENT_anchor">ACI_ATT_READ_RESP_EVENT</a></td><td><p>0x0C07</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_ATT_READ_BLOB_RESP_EVENT_anchor">ACI_ATT_READ_BLOB_RESP_EVENT</a></td><td><p>0x0C08</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_ATT_READ_MULTIPLE_RESP_EVENT_anchor">ACI_ATT_READ_MULTIPLE_RESP_EVENT</a></td><td><p>0x0C09</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_ATT_READ_BY_GROUP_TYPE_RESP_EVENT_anchor">ACI_ATT_READ_BY_GROUP_TYPE_RESP_EVENT</a></td><td><p>0x0C0A</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_ATT_PREPARE_WRITE_RESP_EVENT_anchor">ACI_ATT_PREPARE_WRITE_RESP_EVENT</a></td><td><p>0x0C0C</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_ATT_EXEC_WRITE_RESP_EVENT_anchor">ACI_ATT_EXEC_WRITE_RESP_EVENT</a></td><td><p>0x0C0D</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_INDICATION_EVENT_anchor">ACI_GATT_INDICATION_EVENT</a></td><td><p>0x0C0E</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_NOTIFICATION_EVENT_anchor">ACI_GATT_NOTIFICATION_EVENT</a></td><td><p>0x0C0F</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></td><td><p>0x0C10</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_ERROR_RESP_EVENT_anchor">ACI_GATT_ERROR_RESP_EVENT</a></td><td><p>0x0C11</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_DISC_READ_CHAR_BY_UUID_RESP_EVENT_anchor">ACI_GATT_DISC_READ_CHAR_BY_UUID_RESP_EVENT</a></td><td><p>0x0C12</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_WRITE_PERMIT_REQ_EVENT_anchor">ACI_GATT_WRITE_PERMIT_REQ_EVENT</a></td><td><p>0x0C13</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_READ_PERMIT_REQ_EVENT_anchor">ACI_GATT_READ_PERMIT_REQ_EVENT</a></td><td><p>0x0C14</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_READ_MULTI_PERMIT_REQ_EVENT_anchor">ACI_GATT_READ_MULTI_PERMIT_REQ_EVENT</a></td><td><p>0x0C15</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_TX_POOL_AVAILABLE_EVENT_anchor">ACI_GATT_TX_POOL_AVAILABLE_EVENT</a></td><td><p>0x0C16</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_SERVER_CONFIRMATION_EVENT_anchor">ACI_GATT_SERVER_CONFIRMATION_EVENT</a></td><td><p>0x0C17</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_PREPARE_WRITE_PERMIT_REQ_EVENT_anchor">ACI_GATT_PREPARE_WRITE_PERMIT_REQ_EVENT</a></td><td><p>0x0C18</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_EATT_BEARER_EVENT_anchor">ACI_GATT_EATT_BEARER_EVENT</a></td><td><p>0x0C19</p>
</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_MULT_NOTIFICATION_EVENT_anchor">ACI_GATT_MULT_NOTIFICATION_EVENT</a></td><td><p>0x0C1A</p>
</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_NOTIFICATION_COMPLETE_EVENT_anchor">ACI_GATT_NOTIFICATION_COMPLETE_EVENT</a></td><td><p>0x0C1B</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_READ_EXT_EVENT_anchor">ACI_GATT_READ_EXT_EVENT</a></td><td><p>0x0C1D</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_INDICATION_EXT_EVENT_anchor">ACI_GATT_INDICATION_EXT_EVENT</a></td><td><p>0x0C1E</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_GATT_NOTIFICATION_EXT_EVENT_anchor">ACI_GATT_NOTIFICATION_EXT_EVENT</a></td><td><p>0x0C1F</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
</table><h2><a name="ACI_GATT_ATTRIBUTE_MODIFIED_EVENT_anchor">ACI_GATT_ATTRIBUTE_MODIFIED_EVENT</a></h2><h3>Description</h3><p>This event is generated to the application by the GATT server when a client modifies any attribute on the server, as consequence of one of the following GATT procedures:<br>- write without response<br>- signed write without response<br>- write characteristic value<br>- write long characteristic value<br>- reliable write.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Attr_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the attribute that was modified.</p>
</td><td></tr>
<tr><td><p>Offset</p>
</td><td><p>2</p>
</td><td><p>Bits 14-0: offset from which the write has been performed by the peer device. Bit 15 is used as flag: when set to 1 it indicates that more data are to come (fragmented event in case of long attribute data).</p>
</td><td></tr>
<tr><td><p>Attr_Data_Length</p>
</td><td><p>2</p>
</td><td><p>Length of Attr_Data in octets</p>
</td><td></tr>
<tr><td><p>Attr_Data</p>
</td><td><p>Attr_Data_Length</p>
</td><td><p>The modified value</p>
</td><td></tr>
</table><h2><a name="ACI_GATT_PROC_TIMEOUT_EVENT_anchor">ACI_GATT_PROC_TIMEOUT_EVENT</a></h2><h3>Description</h3><p>This event is generated by the client/server to the application on a GATT timeout (30 seconds). This is a critical event that should not happen during normal operating conditions. It is an indication of either a major disruption in the communication link or a mistake in the application which does not provide a reply to GATT procedures. After this event, the GATT channel is closed and no more GATT communication can be performed. The application is expected to issue an <a href="#ACI_GAP_TERMINATE_anchor">ACI_GAP_TERMINATE</a> to disconnect from the peer device. It is important to leave a 100 ms blank window before sending the <a href="#ACI_GAP_TERMINATE_anchor">ACI_GAP_TERMINATE</a>, since immediately after this event, system could save important information in non-volatile memory.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
</table><h2><a name="ACI_ATT_EXCHANGE_MTU_RESP_EVENT_anchor">ACI_ATT_EXCHANGE_MTU_RESP_EVENT</a></h2><h3>Description</h3><p>This event is generated in response to an Exchange MTU request. See <a href="#ACI_GATT_EXCHANGE_CONFIG_anchor">ACI_GATT_EXCHANGE_CONFIG</a>.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Server_RX_MTU</p>
</td><td><p>2</p>
</td><td><p>Attribute server receive MTU size</p>
</td><td></tr>
</table><h2><a name="ACI_ATT_FIND_INFO_RESP_EVENT_anchor">ACI_ATT_FIND_INFO_RESP_EVENT</a></h2><h3>Description</h3><p>This event is generated in response to a Find Information Request. See <a href="#ACI_ATT_FIND_INFO_REQ_anchor">ACI_ATT_FIND_INFO_REQ</a> and Find Information Response in Bluetooth Core spec. This event is also generated in response to <a href="#ACI_GATT_DISC_ALL_CHAR_DESC_anchor">ACI_GATT_DISC_ALL_CHAR_DESC</a></p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Format</p>
</td><td><p>1</p>
</td><td><p>Format of the handle-UUID pairs</p>
</td><td></tr>
<tr><td><p>Event_Data_Length</p>
</td><td><p>1</p>
</td><td><p>Length of Handle_UUID_Pair in octets</p>
</td><td></tr>
<tr><td><p>Handle_UUID_Pair</p>
</td><td><p>Event_Data_Length</p>
</td><td><p>A sequence of handle-uuid pairs. if format=1, each pair is:[2 octets for handle, 2 octets for UUIDs], if format=2, each pair is:[2 octets for handle, 16 octets for UUIDs]</p>
</td><td></tr>
</table><h2><a name="ACI_ATT_FIND_BY_TYPE_VALUE_RESP_EVENT_anchor">ACI_ATT_FIND_BY_TYPE_VALUE_RESP_EVENT</a></h2><h3>Description</h3><p>This event is generated in response to a <a href="#ACI_ATT_FIND_BY_TYPE_VALUE_REQ_anchor">ACI_ATT_FIND_BY_TYPE_VALUE_REQ</a></p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Num_of_Handle_Pair</p>
</td><td><p>1</p>
</td><td><p>Number of attribute, group handle pairs</p>
</td><td></tr>
<tr><td><p>Found_Attribute_Handle[i]</p>
</td><td><p>2</p>
</td><td><p>Found Attribute handle</p>
</td><td></tr>
<tr><td><p>Group_End_Handle[i]</p>
</td><td><p>2</p>
</td><td><p>Group End handle</p>
</td><td></tr>
</table><h2><a name="ACI_ATT_READ_BY_TYPE_RESP_EVENT_anchor">ACI_ATT_READ_BY_TYPE_RESP_EVENT</a></h2><h3>Description</h3><p>This event is generated in response to a <a href="#ACI_ATT_READ_BY_TYPE_REQ_anchor">ACI_ATT_READ_BY_TYPE_REQ</a>. See <a href="#ACI_GATT_FIND_INCLUDED_SERVICES_anchor">ACI_GATT_FIND_INCLUDED_SERVICES</a> and <a href="#ACI_GATT_DISC_ALL_CHAR_DESC_anchor">ACI_GATT_DISC_ALL_CHAR_DESC</a>.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Handle_Value_Pair_Length</p>
</td><td><p>1</p>
</td><td><p>The size of each attribute handle-value pair</p>
</td><td></tr>
<tr><td><p>Data_Length</p>
</td><td><p>1</p>
</td><td><p>Length of Handle_Value_Pair_Data in octets</p>
</td><td></tr>
<tr><td><p>Handle_Value_Pair_Data</p>
</td><td><p>Data_Length</p>
</td><td><p>Attribute Data List as defined in Bluetooth Core spec. A sequence of handle-value pairs: [2 octets for Attribute Handle, (Handle_Value_Pair_Length - 2 octets) for Attribute Value]</p>
</td><td></tr>
</table><h2><a name="ACI_ATT_READ_RESP_EVENT_anchor">ACI_ATT_READ_RESP_EVENT</a></h2><h3>Description</h3><p>This event is generated in response to a Read Request. See <a href="#ACI_GATT_READ_CHAR_VALUE_anchor">ACI_GATT_READ_CHAR_VALUE</a>.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Event_Data_Length</p>
</td><td><p>1</p>
</td><td><p>Length of following data</p>
</td><td></tr>
<tr><td><p>Attribute_Value</p>
</td><td><p>Event_Data_Length</p>
</td><td><p>The value of the attribute.</p>
</td><td></tr>
</table><h2><a name="ACI_ATT_READ_BLOB_RESP_EVENT_anchor">ACI_ATT_READ_BLOB_RESP_EVENT</a></h2><h3>Description</h3><p>This event can be generated during a read long characteristic value procedure. See <a href="#ACI_GATT_READ_LONG_CHAR_VALUE_anchor">ACI_GATT_READ_LONG_CHAR_VALUE</a>.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Event_Data_Length</p>
</td><td><p>1</p>
</td><td><p>Length of following data</p>
</td><td></tr>
<tr><td><p>Attribute_Value</p>
</td><td><p>Event_Data_Length</p>
</td><td><p>Part of the attribute value.</p>
</td><td></tr>
</table><h2><a name="ACI_ATT_READ_MULTIPLE_RESP_EVENT_anchor">ACI_ATT_READ_MULTIPLE_RESP_EVENT</a></h2><h3>Description</h3><p>This event is generated in response to a Read Multiple Characteristic Values Request or a Read Multiple Variable Length Characteristic Values Request.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Event_Data_Length</p>
</td><td><p>1</p>
</td><td><p>Length of following data</p>
</td><td></tr>
<tr><td><p>Set_Of_Values</p>
</td><td><p>Event_Data_Length</p>
</td><td><p>A set of two or more values.
A concatenation of attribute values for each of the attribute handles in the request in the order that they were requested.</p>
</td><td></tr>
</table><h2><a name="ACI_ATT_READ_BY_GROUP_TYPE_RESP_EVENT_anchor">ACI_ATT_READ_BY_GROUP_TYPE_RESP_EVENT</a></h2><h3>Description</h3><p>This event is generated in response to a Read By Group Type Request. See <a href="#ACI_GATT_DISC_ALL_PRIMARY_SERVICES_anchor">ACI_GATT_DISC_ALL_PRIMARY_SERVICES</a>.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Attribute_Data_Length</p>
</td><td><p>1</p>
</td><td><p>The size of each attribute data</p>
</td><td></tr>
<tr><td><p>Data_Length</p>
</td><td><p>1</p>
</td><td><p>Length of Attribute_Data_List in octets</p>
</td><td></tr>
<tr><td><p>Attribute_Data_List</p>
</td><td><p>Data_Length</p>
</td><td><p>Attribute Data List as defined in Bluetooth Core spec. A sequence of attribute handle, end group handle, attribute value tuples: [2 octets for Attribute Handle, 2 octets End Group Handle, (Attribute_Data_Length - 4 octets) for Attribute Value]</p>
</td><td></tr>
</table><h2><a name="ACI_ATT_PREPARE_WRITE_RESP_EVENT_anchor">ACI_ATT_PREPARE_WRITE_RESP_EVENT</a></h2><h3>Description</h3><p>This event is generated in response to a <a href="#ACI_ATT_PREPARE_WRITE_REQ_anchor">ACI_ATT_PREPARE_WRITE_REQ</a>.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Attribute_Handle</p>
</td><td><p>2</p>
</td><td><p>The handle of the attribute to be written</p>
</td><td></tr>
<tr><td><p>Offset</p>
</td><td><p>2</p>
</td><td><p>The offset of the first octet to be written.</p>
</td><td></tr>
<tr><td><p>Part_Attribute_Value_Length</p>
</td><td><p>1</p>
</td><td><p>Length of Part_Attribute_Value in octets</p>
</td><td></tr>
<tr><td><p>Part_Attribute_Value</p>
</td><td><p>Part_Attribute_Value_Length</p>
</td><td><p>The value of the attribute to be written</p>
</td><td></tr>
</table><h2><a name="ACI_ATT_EXEC_WRITE_RESP_EVENT_anchor">ACI_ATT_EXEC_WRITE_RESP_EVENT</a></h2><h3>Description</h3><p>This event is generated in response to an Execute Write Request.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
</table><h2><a name="ACI_GATT_INDICATION_EVENT_anchor">ACI_GATT_INDICATION_EVENT</a></h2><h3>Description</h3><p>This event is generated when an indication is received from the server.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Attribute_Handle</p>
</td><td><p>2</p>
</td><td><p>The handle of the attribute</p>
</td><td></tr>
<tr><td><p>Attribute_Value_Length</p>
</td><td><p>1</p>
</td><td><p>Length of Attribute_Value in octets</p>
</td><td></tr>
<tr><td><p>Attribute_Value</p>
</td><td><p>Attribute_Value_Length</p>
</td><td><p>The current value of the attribute</p>
</td><td></tr>
</table><h2><a name="ACI_GATT_NOTIFICATION_EVENT_anchor">ACI_GATT_NOTIFICATION_EVENT</a></h2><h3>Description</h3><p>This event is generated when a notification is received from the server.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Attribute_Handle</p>
</td><td><p>2</p>
</td><td><p>The handle of the attribute</p>
</td><td></tr>
<tr><td><p>Attribute_Value_Length</p>
</td><td><p>1</p>
</td><td><p>Length of Attribute_Value in octets</p>
</td><td></tr>
<tr><td><p>Attribute_Value</p>
</td><td><p>Attribute_Value_Length</p>
</td><td><p>The current value of the attribute</p>
</td><td></tr>
</table><h2><a name="ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></h2><h3>Description</h3><p>This event is generated when a GATT client procedure completes either with error or successfully.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Error_Code</p>
</td><td><p>1</p>
</td><td><p>Indicates whether the procedure completed with an error or was successful (see &quot;Status error codes&quot; section)</p>
</td><td></tr>
</table><h2><a name="ACI_GATT_ERROR_RESP_EVENT_anchor">ACI_GATT_ERROR_RESP_EVENT</a></h2><h3>Description</h3><p>This event is generated when an Error Response is received from the server. The error response can be given by the server at the end of one of the GATT discovery procedures. This does not mean that the procedure ended with an error, but this error event is part of the procedure itself.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Req_Opcode</p>
</td><td><p>1</p>
</td><td><p>The request that generated this error response</p>
</td><td></tr>
<tr><td><p>Attribute_Handle</p>
</td><td><p>2</p>
</td><td><p>The attribute handle that generated this error response</p>
</td><td></tr>
<tr><td><p>Error_Code</p>
</td><td><p>1</p>
</td><td><p>The reason why the request has generated an error response (ATT error codes)</p>
</td><td><li>0x01: Invalid handle</li><li>0x02: Read not permitted</li><li>0x03: Write not permitted</li><li>0x04: Invalid PDU</li><li>0x05: Insufficient authentication</li><li>0x06: Request not supported</li><li>0x07: Invalid offset</li><li>0x08: Insufficient authorization</li><li>0x09: Prepare queue full</li><li>0x0A: Attribute not found</li><li>0x0B: Attribute not long</li><li>0x0C: Insufficient encryption key size</li><li>0x0D: Invalid attribute value length</li><li>0x0E: Unlikely error</li><li>0x0F: Insufficient encryption</li><li>0x10: Unsupported group type</li><li>0x11: Insufficient resources</li><li>0x12: Database Out Of Sync</li><li>0x13: Value Not Allowed</li></td></tr>
</table><h2><a name="ACI_GATT_DISC_READ_CHAR_BY_UUID_RESP_EVENT_anchor">ACI_GATT_DISC_READ_CHAR_BY_UUID_RESP_EVENT</a></h2><h3>Description</h3><p>This event can be generated during a "Discover Characteristics By UUID" procedure or a "Read using Characteristic UUID" procedure.<br>The attribute value will be a service declaration as defined in Bluetooth spec. v.5.4 [Vol 3, Part G, 3.3.1], when a "Discover Characteristics By UUID" has been started. It will be the value of the Characteristic if a* "Read using Characteristic UUID" has been performed.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Attribute_Handle</p>
</td><td><p>2</p>
</td><td><p>The handle of the attribute</p>
</td><td></tr>
<tr><td><p>Attribute_Value_Length</p>
</td><td><p>1</p>
</td><td><p>Length of Attribute_Value in octets</p>
</td><td></tr>
<tr><td><p>Attribute_Value</p>
</td><td><p>Attribute_Value_Length</p>
</td><td><p>The attribute value will be a service declaration as defined in Bluetooth spec. v.5.4 [Vol 3, Part G, 3.3.1], when a &quot;Discover Characteristics By UUID&quot; has been started.
It will be the value of the Characteristic if a &quot;Read using Characteristic UUID&quot; has been performed.</p>
</td><td></tr>
</table><h2><a name="ACI_GATT_WRITE_PERMIT_REQ_EVENT_anchor">ACI_GATT_WRITE_PERMIT_REQ_EVENT</a></h2><h3>Description</h3><p>This event is given to the application when a write request, write command or signed write command is received by the server from the client. This event will be given to the application only if the event bit for this event generation is set when the characteristic was added.<br>When this event is received, the application has to check whether the value being requested for write can be allowed to be written and respond with the command <a href="#ACI_GATT_WRITE_RESP_anchor">ACI_GATT_WRITE_RESP</a>.<br>The details of the parameters of the command can be found. Based on the response from the application, the attribute value will be modified by the stack. If the write is rejected by the application, then the value of the attribute will not be modified. In case of a write REQ, an error response will be sent to the client, with the error code as specified by the application.<br>In case of write/signed write commands, no response is sent to the client but the attribute is not modified.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Attribute_Handle</p>
</td><td><p>2</p>
</td><td><p>The handle of the attribute</p>
</td><td></tr>
<tr><td><p>Data_Length</p>
</td><td><p>1</p>
</td><td><p>Length of Data field</p>
</td><td></tr>
<tr><td><p>Data</p>
</td><td><p>Data_Length</p>
</td><td><p>The data that the client has requested to write</p>
</td><td></tr>
</table><h2><a name="ACI_GATT_READ_PERMIT_REQ_EVENT_anchor">ACI_GATT_READ_PERMIT_REQ_EVENT</a></h2><h3>Description</h3><p>This event is given to the application when a read request or read blob request is received by the server from the client. This event will be given to the application only if the event bit for this event generation is set when the characteristic was added.<br>On receiving this event, the application can update the value of the handle if it desires and when done, it must send the <a href="#ACI_GATT_ALLOW_READ_anchor">ACI_GATT_ALLOW_READ</a> command to indicate to the stack that it can send the response to the client.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Attribute_Handle</p>
</td><td><p>2</p>
</td><td><p>The handle of the attribute</p>
</td><td></tr>
<tr><td><p>Offset</p>
</td><td><p>2</p>
</td><td><p>Contains the offset from which the read has been requested</p>
</td><td></tr>
</table><h2><a name="ACI_GATT_READ_MULTI_PERMIT_REQ_EVENT_anchor">ACI_GATT_READ_MULTI_PERMIT_REQ_EVENT</a></h2><h3>Description</h3><p>This event is given to the application when a read multiple request or read by type request is received by the server from the client. This event will be given to the application only if the event bit for this event generation is set when the characteristic was added.<br>On receiving this event, the application can update the values of the handles if it desires and when done, it must send the <a href="#ACI_GATT_ALLOW_READ_anchor">ACI_GATT_ALLOW_READ</a> command to indicate to the stack that it can send the response to the client.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Number_of_Handles</p>
</td><td><p>1</p>
</td><td></td><td></tr>
<tr><td><p>Handle[i]</p>
</td><td><p>2</p>
</td><td></td><td></tr>
</table><h2><a name="ACI_GATT_TX_POOL_AVAILABLE_EVENT_anchor">ACI_GATT_TX_POOL_AVAILABLE_EVENT</a></h2><h3>Description</h3><p>Each time BLE stack raises the error code BLE_STATUS_INSUFFICIENT_RESOURCES (0x64), the <a href="#ACI_GATT_TX_POOL_AVAILABLE_EVENT_anchor">ACI_GATT_TX_POOL_AVAILABLE_EVENT</a> event is generated as soon as there are at least two buffers available for notifications or write commands.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Not used.</p>
</td><td></tr>
<tr><td><p>Available_Buffers</p>
</td><td><p>2</p>
</td><td><p>Number of buffers available.</p>
</td><td></tr>
</table><h2><a name="ACI_GATT_SERVER_CONFIRMATION_EVENT_anchor">ACI_GATT_SERVER_CONFIRMATION_EVENT</a></h2><h3>Description</h3><p>This event is generated when the client has sent the confirmation to a previously sent indication</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
</table><h2><a name="ACI_GATT_PREPARE_WRITE_PERMIT_REQ_EVENT_anchor">ACI_GATT_PREPARE_WRITE_PERMIT_REQ_EVENT</a></h2><h3>Description</h3><p>This event is given to the application when a prepare write request is received by the server from the client. This event will be given to the application only if the event bit for this event generation is set when the characteristic was added.<br>When this event is received, the application has to check whether the value being requested for write can be allowed to be written and respond with the command <a href="#ACI_GATT_WRITE_RESP_anchor">ACI_GATT_WRITE_RESP</a>. Based on the response from the application, the attribute value will be modified by the stack.<br>If the write is rejected by the application, then the value of the attribute will not be modified and an error response will be sent to the client, with the error code as specified by the application.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Attribute_Handle</p>
</td><td><p>2</p>
</td><td><p>The handle of the attribute</p>
</td><td></tr>
<tr><td><p>Offset</p>
</td><td><p>2</p>
</td><td><p>The offset from which the prepare write has been requested</p>
</td><td></tr>
<tr><td><p>Data_Length</p>
</td><td><p>1</p>
</td><td><p>Length of Data field</p>
</td><td></tr>
<tr><td><p>Data</p>
</td><td><p>Data_Length</p>
</td><td><p>The data that the client has requested to write</p>
</td><td></tr>
</table><h2><a name="ACI_GATT_EATT_BEARER_EVENT_anchor">ACI_GATT_EATT_BEARER_EVENT</a></h2><h3>Description</h3><p>This event informs the application of a change in status of the Enhanced ATT bearer handled by the specified L2CAP channel.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Channel_Index</p>
</td><td><p>1</p>
</td><td><p>Index of the connection-oriented channel for which the primitive applies.</p>
</td><td></tr>
<tr><td><p>EAB_State</p>
</td><td><p>1</p>
</td><td><p>Enhanced ATT bearer state.</p>
</td><td><li>0x00: Enhanced ATT bearer created</li><li>0x01: Enhanced ATT bearer terminated</li></td></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h2><a name="ACI_GATT_MULT_NOTIFICATION_EVENT_anchor">ACI_GATT_MULT_NOTIFICATION_EVENT</a></h2><h3>Description</h3><p>This event is generated when a Multiple Handle Value notification is received from the server.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Offset</p>
</td><td><p>2</p>
</td><td><p>Bits 14-0: offset in octets from which Attribute_Value data starts. Bit 15 is used as flag: when set to 1 it indicates that more data are to come (fragmented event in case of long attribute data).</p>
</td><td></tr>
<tr><td><p>Data_Length</p>
</td><td><p>2</p>
</td><td><p>Length of Data in bytes</p>
</td><td></tr>
<tr><td><p>Data</p>
</td><td><p>Data_Length</p>
</td><td><p>List of &quot;Handle Length Value&quot; tuples as defined in Bluetooth Core specification</p>
</td><td></tr>
</table><h2><a name="ACI_GATT_NOTIFICATION_COMPLETE_EVENT_anchor">ACI_GATT_NOTIFICATION_COMPLETE_EVENT</a></h2><h3>Description</h3><p>This event is generated on server side after the transmission of all notifications linked with a local update of a characteristic value (if it is enabled at the creation of the characteristic with GATT_NOTIFY_NOTIFICATION_COMPLETION mask and if the characteristic supports notifications).</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Attr_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the updated characteristic value</p>
</td><td></tr>
</table><h2><a name="ACI_GATT_READ_EXT_EVENT_anchor">ACI_GATT_READ_EXT_EVENT</a></h2><h3>Description</h3><p>When it is enabled with ACI_GATT_SET_EVENT_MASK, this event is generated instead of ACI_ATT_READ_RESP_EVENT / ACI_ATT_READ_BLOB_RESP_EVENT / ACI_ATT_READ_MULTIPLE_RESP_EVENT.<br>This event should be used instead of those events when ATT_MTU &gt; (BLE_EVT_MAX_PARAM_LEN - 4) i.e. ATT_MTU &gt; 251 for BLE_EVT_MAX_PARAM_LEN default value.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Offset</p>
</td><td><p>2</p>
</td><td><p>Bits 14-0: offset in octets from which Attribute_Value data starts. Bit 15 is used as flag: when set to 1 it indicates that more data are to come (fragmented event in case of long attribute data).</p>
</td><td></tr>
<tr><td><p>Event_Data_Length</p>
</td><td><p>2</p>
</td><td><p>Length of following data</p>
</td><td></tr>
<tr><td><p>Attribute_Value</p>
</td><td><p>Event_Data_Length</p>
</td><td><p>The value of the attribute(s).</p>
</td><td></tr>
</table><h2><a name="ACI_GATT_INDICATION_EXT_EVENT_anchor">ACI_GATT_INDICATION_EXT_EVENT</a></h2><h3>Description</h3><p>When it is enabled with ACI_GATT_SET_EVENT_MASK and when an indication is received from the server, this event is generated instead of ACI_GATT_INDICATION_EVENT.<br>This event should be used instead of ACI_GATT_INDICATION_EVENT when ATT_MTU &gt; (BLE_EVT_MAX_PARAM_LEN - 4) i.e. ATT_MTU &gt; 251 for BLE_EVT_MAX_PARAM_LEN default value.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Attribute_Handle</p>
</td><td><p>2</p>
</td><td><p>The handle of the attribute</p>
</td><td></tr>
<tr><td><p>Offset</p>
</td><td><p>2</p>
</td><td><p>Bits 14-0: offset in octets from which Attribute_Value data starts. Bit 15 is used as flag: when set to 1 it indicates that more data are to come (fragmented event in case of long attribute data).</p>
</td><td></tr>
<tr><td><p>Attribute_Value_Length</p>
</td><td><p>2</p>
</td><td><p>Length of Attribute_Value in octets</p>
</td><td></tr>
<tr><td><p>Attribute_Value</p>
</td><td><p>Attribute_Value_Length</p>
</td><td><p>The current value of the attribute</p>
</td><td></tr>
</table><h2><a name="ACI_GATT_NOTIFICATION_EXT_EVENT_anchor">ACI_GATT_NOTIFICATION_EXT_EVENT</a></h2><h3>Description</h3><p>When it is enabled with ACI_GATT_SET_EVENT_MASK and when a notification is received from the server, this event is generated instead of ACI_GATT_NOTIFICATION_EVENT.<br>This event should be used instead of ACI_GATT_NOTIFICATION_EVENT when ATT_MTU &gt; (BLE_EVT_MAX_PARAM_LEN - 4) i.e. ATT_MTU &gt; 251 for BLE_EVT_MAX_PARAM_LEN default value.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies the ATT bearer for which the event applies.</p>
</td><td><li>0x0000 ... 0x0EFF: Unenhanced ATT bearer (the parameter is the connection handle)</li><li>0xEA00 ... 0xEA3F: Enhanced ATT bearer (the LSB-byte of the parameter is the connection-oriented channel index)</li></td></tr>
<tr><td><p>Attribute_Handle</p>
</td><td><p>2</p>
</td><td><p>The handle of the attribute</p>
</td><td></tr>
<tr><td><p>Offset</p>
</td><td><p>2</p>
</td><td><p>Bits 14-0: offset in octets from which Attribute_Value data starts. Bit 15 is used as flag: when set to 1 it indicates that more data are to come (fragmented event in case of long attribute data).</p>
</td><td></tr>
<tr><td><p>Attribute_Value_Length</p>
</td><td><p>2</p>
</td><td><p>Length of Attribute_Value in octets</p>
</td><td></tr>
<tr><td><p>Attribute_Value</p>
</td><td><p>Attribute_Value_Length</p>
</td><td><p>The current value of the attribute</p>
</td><td></tr>
</table><h2><a name="ACI L2CAP events_anchor">ACI L2CAP events</a></h2><h2></h2><table width="800" border="1" class="reference">
<tr><th>Event name</th><th>Vendor specific subevent code</th><th>BF</th><th>PO</th><th>LO</th><th>LB</th><th>BO</th></tr>
<tr><td><a href="#ACI_L2CAP_CONNECTION_UPDATE_RESP_EVENT_anchor">ACI_L2CAP_CONNECTION_UPDATE_RESP_EVENT</a></td><td><p>0x0800</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_L2CAP_PROC_TIMEOUT_EVENT_anchor">ACI_L2CAP_PROC_TIMEOUT_EVENT</a></td><td><p>0x0801</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_L2CAP_CONNECTION_UPDATE_REQ_EVENT_anchor">ACI_L2CAP_CONNECTION_UPDATE_REQ_EVENT</a></td><td><p>0x0802</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_L2CAP_COMMAND_REJECT_EVENT_anchor">ACI_L2CAP_COMMAND_REJECT_EVENT</a></td><td><p>0x080A</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_L2CAP_COC_CONNECT_EVENT_anchor">ACI_L2CAP_COC_CONNECT_EVENT</a></td><td><p>0x0810</p>
</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_L2CAP_COC_CONNECT_CONFIRM_EVENT_anchor">ACI_L2CAP_COC_CONNECT_CONFIRM_EVENT</a></td><td><p>0x0811</p>
</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_L2CAP_COC_RECONF_EVENT_anchor">ACI_L2CAP_COC_RECONF_EVENT</a></td><td><p>0x0812</p>
</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_L2CAP_COC_RECONF_CONFIRM_EVENT_anchor">ACI_L2CAP_COC_RECONF_CONFIRM_EVENT</a></td><td><p>0x0813</p>
</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_L2CAP_COC_DISCONNECT_EVENT_anchor">ACI_L2CAP_COC_DISCONNECT_EVENT</a></td><td><p>0x0814</p>
</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_L2CAP_COC_FLOW_CONTROL_EVENT_anchor">ACI_L2CAP_COC_FLOW_CONTROL_EVENT</a></td><td><p>0x0815</p>
</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_L2CAP_COC_RX_DATA_EVENT_anchor">ACI_L2CAP_COC_RX_DATA_EVENT</a></td><td><p>0x0816</p>
</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_L2CAP_COC_TX_POOL_AVAILABLE_EVENT_anchor">ACI_L2CAP_COC_TX_POOL_AVAILABLE_EVENT</a></td><td><p>0x0817</p>
</td><td></td><td></td><td></td><td></td><td></td></tr>
</table><h2><a name="ACI_L2CAP_CONNECTION_UPDATE_RESP_EVENT_anchor">ACI_L2CAP_CONNECTION_UPDATE_RESP_EVENT</a></h2><h3>Description</h3><p>This event is generated when the Central responds to the connection update request packet with a connection update response packet.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the connection where this event occurred.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Result</p>
</td><td><p>2</p>
</td><td><p>Result field from the response packet.</p>
</td><td><li>0x0000: Connection Parameters accepted</li><li>0x0001: Connection Parameters rejected</li></td></tr>
</table><h2><a name="ACI_L2CAP_PROC_TIMEOUT_EVENT_anchor">ACI_L2CAP_PROC_TIMEOUT_EVENT</a></h2><h3>Description</h3><p>This event is generated when the Central does not respond to the connection update request packet with a connection update response packet or a command reject packet within 30 seconds.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the connection where this event occurred.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Data_Length</p>
</td><td><p>1</p>
</td><td><p>Length of following data</p>
</td><td></tr>
<tr><td><p>Data</p>
</td><td><p>Data_Length</p>
</td><td></td><td></tr>
</table><h2><a name="ACI_L2CAP_CONNECTION_UPDATE_REQ_EVENT_anchor">ACI_L2CAP_CONNECTION_UPDATE_REQ_EVENT</a></h2><h3>Description</h3><p>The event is given by the L2CAP layer when a connection update request is received from the Peripheral. The upper layer which receives this event has to respond by sending a <a href="#ACI_L2CAP_CONNECTION_PARAMETER_UPDATE_RESP_anchor">ACI_L2CAP_CONNECTION_PARAMETER_UPDATE_RESP</a> command.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the connection where this event occurred.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Identifier</p>
</td><td><p>1</p>
</td><td><p>This is the identifier which associate the request to the response.</p>
</td><td></tr>
<tr><td><p>L2CAP_Length</p>
</td><td><p>2</p>
</td><td><p>Length of the L2CAP connection update request.</p>
</td><td></tr>
<tr><td><p>Interval_Min</p>
</td><td><p>2</p>
</td><td><p>Minimum value for the connection event interval.
Time = N * 1.25 ms.</p>
</td><td><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Interval_Max</p>
</td><td><p>2</p>
</td><td><p>Maximum value for the connection event interval.
Time = N * 1.25 ms.</p>
</td><td><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Latency</p>
</td><td><p>2</p>
</td><td><p>Maximum Peripheral latency for the connection in number of connection events.</p>
</td><td><li>0x0000 ... 0x01F3</li></td></tr>
<tr><td><p>Timeout_Multiplier</p>
</td><td><p>2</p>
</td><td><p>Defines connection timeout parameter in the following manner: Timeout Multiplier * 10ms.</p>
</td><td></tr>
</table><h2><a name="ACI_L2CAP_COMMAND_REJECT_EVENT_anchor">ACI_L2CAP_COMMAND_REJECT_EVENT</a></h2><h3>Description</h3><p>This event is generated upon receipt of a valid Command Reject packet (e.g. when the Central responds to the Connection Update Request packet with a Command Reject packet).</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the connection where this event occurred.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Identifier</p>
</td><td><p>1</p>
</td><td><p>This is the identifier which associate the request to the response.</p>
</td><td></tr>
<tr><td><p>Reason</p>
</td><td><p>2</p>
</td><td><p>Reason</p>
</td><td></tr>
<tr><td><p>Data_Length</p>
</td><td><p>1</p>
</td><td><p>Length of following data</p>
</td><td></tr>
<tr><td><p>Data</p>
</td><td><p>Data_Length</p>
</td><td><p>Data field associated with Reason</p>
</td><td></tr>
</table><h2><a name="ACI_L2CAP_COC_CONNECT_EVENT_anchor">ACI_L2CAP_COC_CONNECT_EVENT</a></h2><h3>Description</h3><p>This event is generated when receiving a valid Credit Based Connection Request packet.<br>See Bluetooth spec. v.5.4 [Vol 3, Part A].</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the connection where this event occurred.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>SPSM</p>
</td><td><p>2</p>
</td><td><p>Simplified Protocol/Service Multiplexer.</p>
</td><td><li>0x0001 ... 0x00FF</li></td></tr>
<tr><td><p>MTU</p>
</td><td><p>2</p>
</td><td><p>Maximum Transmission Unit.</p>
</td><td><li>23 ... 65535</li></td></tr>
<tr><td><p>MPS</p>
</td><td><p>2</p>
</td><td><p>Maximum payload size (in octets).</p>
</td><td><li>23 ... 248</li></td></tr>
<tr><td><p>Initial_Credits</p>
</td><td><p>2</p>
</td><td><p>Number of K-frames that can be received on the created channel(s) by the L2CAP layer entity sending this packet.</p>
</td><td><li>0 ... 65535</li></td></tr>
<tr><td><p>Channel_Number</p>
</td><td><p>1</p>
</td><td><p>Number of channels to be created. If this parameter is set to 0, it requests the creation of one LE credit based connection-oriented channel. Otherwise, it requests the creation of one or more enhanced credit based connection-oriented channels.</p>
</td><td><li>0 ... 5</li></td></tr>
</table><h2><a name="ACI_L2CAP_COC_CONNECT_CONFIRM_EVENT_anchor">ACI_L2CAP_COC_CONNECT_CONFIRM_EVENT</a></h2><h3>Description</h3><p>This event is generated when receiving a valid Credit Based Connection Response packet.<br>See Bluetooth spec. v.5.4 [Vol 3, Part A].</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the connection where this event occurred.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>MTU</p>
</td><td><p>2</p>
</td><td><p>Maximum Transmission Unit.</p>
</td><td><li>23 ... 65535</li></td></tr>
<tr><td><p>MPS</p>
</td><td><p>2</p>
</td><td><p>Maximum payload size (in octets).</p>
</td><td><li>23 ... 248</li></td></tr>
<tr><td><p>Initial_Credits</p>
</td><td><p>2</p>
</td><td><p>Number of K-frames that can be received on the created channel(s) by the L2CAP layer entity sending this packet.</p>
</td><td><li>0 ... 65535</li></td></tr>
<tr><td><p>Result</p>
</td><td><p>2</p>
</td><td><p>This parameter indicates the outcome of the request. A value of 0x0000 indicates success while a non-zero value indicates the request is refused.</p>
</td><td><li>0x0000 ... 0x000C</li></td></tr>
<tr><td><p>Channel_Number</p>
</td><td><p>1</p>
</td><td><p>Number of created channels. It is the length of Channel_Index_List.</p>
</td><td><li>0 ... 5</li></td></tr>
<tr><td><p>Channel_Index_List</p>
</td><td><p>Channel_Number</p>
</td><td><p>List of channel indexes for which the primitive applies.</p>
</td><td></tr>
</table><h2><a name="ACI_L2CAP_COC_RECONF_EVENT_anchor">ACI_L2CAP_COC_RECONF_EVENT</a></h2><h3>Description</h3><p>This event is generated when receiving a valid Credit Based Reconfigure Request packet.<br>See Bluetooth spec. v.5.4 [Vol 3, Part A].</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the connection where this event occurred.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>MTU</p>
</td><td><p>2</p>
</td><td><p>Maximum Transmission Unit.</p>
</td><td><li>23 ... 65535</li></td></tr>
<tr><td><p>MPS</p>
</td><td><p>2</p>
</td><td><p>Maximum payload size (in octets).</p>
</td><td><li>23 ... 248</li></td></tr>
<tr><td><p>Channel_Number</p>
</td><td><p>1</p>
</td><td><p>Number of created channels. It is the length of Channel_Index_List.</p>
</td><td><li>1 ... 5</li></td></tr>
<tr><td><p>Channel_Index_List</p>
</td><td><p>Channel_Number</p>
</td><td><p>List of channel indexes for which the primitive applies.</p>
</td><td></tr>
</table><h2><a name="ACI_L2CAP_COC_RECONF_CONFIRM_EVENT_anchor">ACI_L2CAP_COC_RECONF_CONFIRM_EVENT</a></h2><h3>Description</h3><p>This event is generated when receiving a valid Credit Based Reconfigure Response packet.<br>See Bluetooth spec. v.5.4 [Vol 3, Part A].</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the connection where this event occurred.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Result</p>
</td><td><p>2</p>
</td><td><p>This parameter indicates the outcome of the request. A value of 0x0000 indicates success while a non-zero value indicates the request is refused.</p>
</td><td><li>0x0000 ... 0x000C</li></td></tr>
</table><h2><a name="ACI_L2CAP_COC_DISCONNECT_EVENT_anchor">ACI_L2CAP_COC_DISCONNECT_EVENT</a></h2><h3>Description</h3><p>This event is generated when a connection-oriented channel is disconnected following an L2CAP channel termination procedure.<br>See Bluetooth spec. v.5.4 [Vol 3, Part A].</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Channel_Index</p>
</td><td><p>1</p>
</td><td><p>Index of the connection-oriented channel for which the primitive applies.</p>
</td><td></tr>
</table><h2><a name="ACI_L2CAP_COC_FLOW_CONTROL_EVENT_anchor">ACI_L2CAP_COC_FLOW_CONTROL_EVENT</a></h2><h3>Description</h3><p>This event is generated when receiving a valid Flow Control Credit signaling packet.<br>See Bluetooth spec. v.5.4 [Vol 3, Part A].</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Channel_Index</p>
</td><td><p>1</p>
</td><td><p>Index of the connection-oriented channel for which the primitive applies.</p>
</td><td></tr>
<tr><td><p>Credits</p>
</td><td><p>2</p>
</td><td><p>Number of credits the receiving device can increment, corresponding to the number of K-frames that can be sent to the peer device sending the Flow Control Credit packet.</p>
</td><td><li>1 ... 65535</li></td></tr>
</table><h2><a name="ACI_L2CAP_COC_RX_DATA_EVENT_anchor">ACI_L2CAP_COC_RX_DATA_EVENT</a></h2><h3>Description</h3><p>This event is generated when receiving a valid K-frame packet on a connection-oriented channel.<br>See Bluetooth spec. v.5.4 [Vol 3, Part A].<br>Note: for the first K-frame of the SDU, the Information data contains the L2CAP SDU Length coded on two octets followed by the K-frame information payload. For the next K-frames of the SDU, the Information data only contains the K-frame information payload.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Channel_Index</p>
</td><td><p>1</p>
</td><td><p>Index of the connection-oriented channel for which the primitive applies.</p>
</td><td></tr>
<tr><td><p>Length</p>
</td><td><p>2</p>
</td><td><p>Length of Data (in octets)</p>
</td><td></tr>
<tr><td><p>Data</p>
</td><td><p>Length</p>
</td><td><p>Information data</p>
</td><td></tr>
</table><h2><a name="ACI_L2CAP_COC_TX_POOL_AVAILABLE_EVENT_anchor">ACI_L2CAP_COC_TX_POOL_AVAILABLE_EVENT</a></h2><h3>Description</h3><p>Each time ACI_L2CAP_COC_TX_DATA raises the error code BLE_STATUS_INSUFFICIENT_RESOURCES (0x64), the ACI_L2CAP_COC_TX_POOL_AVAILABLE_EVENT event is generated as soon as there is a free buffer available for sending K-frames.</p><h3>Event parameters</h3><p>None</p><h2><a name="ACI HAL events_anchor">ACI HAL events</a></h2><h2></h2><table width="800" border="1" class="reference">
<tr><th>Event name</th><th>Vendor specific subevent code</th><th>BF</th><th>PO</th><th>LO</th><th>LB</th><th>BO</th></tr>
<tr><td><a href="#ACI_HAL_END_OF_RADIO_ACTIVITY_EVENT_anchor">ACI_HAL_END_OF_RADIO_ACTIVITY_EVENT</a></td><td><p>0x0004</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td></tr>
<tr><td><a href="#ACI_HAL_SCAN_REQ_REPORT_EVENT_anchor">ACI_HAL_SCAN_REQ_REPORT_EVENT</a></td><td><p>0x0005</p>
</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="#ACI_HAL_FW_ERROR_EVENT_anchor">ACI_HAL_FW_ERROR_EVENT</a></td><td><p>0x0006</p>
</td><td><p>Y</p>
</td><td><p>Y</p>
</td><td></td><td></td><td></td></tr>
</table><h2><a name="ACI_HAL_END_OF_RADIO_ACTIVITY_EVENT_anchor">ACI_HAL_END_OF_RADIO_ACTIVITY_EVENT</a></h2><h3>Description</h3><p>This event is generated when the device completes a radio activity and provide information when a new radio activity will be performed.<br>Information provided includes type of radio activity and absolute time in system ticks when a new radio activity is schedule, if any. Application can use this information to schedule user activities synchronous to selected radio activities. A command <a href="#ACI_HAL_SET_RADIO_ACTIVITY_MASK_anchor">ACI_HAL_SET_RADIO_ACTIVITY_MASK</a> is provided to enable radio activity events of user interests, by default no events are enabled.<br>User should take into account that enabling radio events in application with intense radio activity could lead to a fairly high rate of events generated.<br>Application use cases includes synchronizing notification with connection interval, switching antenna at the end of advertising or performing flash erase operation while radio is idle.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Last_State</p>
</td><td><p>1</p>
</td><td><p>Completed radio event</p>
</td><td><li>0x00: Idle</li><li>0x01: Advertising</li><li>0x02: Peripheral connection</li><li>0x03: Scanning</li><li>0x05: Central connection</li><li>0x06: TX test mode</li><li>0x07: RX test mode</li><li>0x09: Periodic advertising (only for STM32WBA)</li><li>0x0A: Periodic sync (only for STM32WBA)</li><li>0x0B: Iso broadcast (only for STM32WBA)</li><li>0x0C: Iso sync (only for STM32WBA)</li><li>0x0D: Iso peripheral connection (only for STM32WBA)</li><li>0x0E: Iso central connection (only for STM32WBA)</li></td></tr>
<tr><td><p>Next_State</p>
</td><td><p>1</p>
</td><td><p>Incoming radio event</p>
</td><td><li>0x00: Idle</li><li>0x01: Advertising</li><li>0x02: Peripheral connection</li><li>0x03: Scanning</li><li>0x05: Central connection</li><li>0x06: TX test mode</li><li>0x07: RX test mode</li><li>0x09: Periodic advertising (only for STM32WBA)</li><li>0x0A: Periodic sync (only for STM32WBA)</li><li>0x0B: Iso broadcast (only for STM32WBA)</li><li>0x0C: Iso sync (only for STM32WBA)</li><li>0x0D: Iso peripheral connection (only for STM32WBA)</li><li>0x0E: Iso central connection (only for STM32WBA)</li></td></tr>
<tr><td><p>Next_State_SysTime</p>
</td><td><p>4</p>
</td><td><p>32bit absolute current time expressed in internal time units.</p>
</td><td></tr>
<tr><td><p>Last_State_Slot</p>
</td><td><p>1</p>
</td><td><p>Slot number of completed radio event</p>
</td><td><li>0xFF: Idle</li><li>0x00 ... 0x07</li></td></tr>
<tr><td><p>Next_State_Slot</p>
</td><td><p>1</p>
</td><td><p>Slot number of incoming radio event</p>
</td><td><li>0xFF: Idle</li><li>0x00 ... 0x07</li></td></tr>
</table><h2><a name="ACI_HAL_SCAN_REQ_REPORT_EVENT_anchor">ACI_HAL_SCAN_REQ_REPORT_EVENT</a></h2><h3>Description</h3><p>This event is reported to the application after a scan request is received and a scan response is scheduled to be transmitted.<br>Note: RSSI in this event is valid only when privacy is not used.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>RSSI</p>
</td><td><p>1</p>
</td><td><p>RSSI (signed integer).
Units: dBm.</p>
</td><td><li>127: RSSI not available</li><li>-127 ... 20</li></td></tr>
<tr><td><p>Peer_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Address type
0x00 Public Device Address
0x01 Random Device Address
0x02 Public Identity Address (Corresponds to Resolved Private Address)
0x03 Random (Static) Identity Address (Corresponds to Resolved Private Address)</p>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li><li>0x02: Public Identity Address</li><li>0x03: Random (Static) Identity Address</li></td></tr>
<tr><td><p>Peer_Address</p>
</td><td><p>6</p>
</td><td><p>Public Device Address or Random Device Address of the peer device</p>
</td><td></tr>
</table><h2><a name="ACI_HAL_FW_ERROR_EVENT_anchor">ACI_HAL_FW_ERROR_EVENT</a></h2><h3>Description</h3><p>This event is generated to report firmware error information.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>FW_Error_Type</p>
</td><td><p>1</p>
</td><td><p>FW Error type</p>
</td><td><li>0x01: L2CAP recombination failure</li><li>0x02: GATT unexpected peer message</li><li>0x03: NVM level warning</li><li>0x04: COC RX data length too large</li></td></tr>
<tr><td><p>Data_Length</p>
</td><td><p>1</p>
</td><td><p>Length of Data in octets</p>
</td><td></tr>
<tr><td><p>Data</p>
</td><td><p>Data_Length</p>
</td><td><p>The error event info</p>
</td><td></tr>
</table><h2><a name="Annex_anchor">Annex</a></h2><p><a href="#Status error codes_anchor">Status error codes</a></p><p><a href="#TX Power Level_anchor">TX Power Level</a></p><p></p><h1><a name="Status error codes_anchor">Status error codes</a></h1><p>Status error codes are used for the return status of all commands. Only the codes from 0 to 0x45 are used for HCI commands (see Bluetooth spec. v.5.4 [Vol 1, Part F]), while more codes are defined for ACI commands (see table below).</p><h2></h2><table width="800" border="1" class="reference">
<tr><th>Status error code</th><th>Description</th></tr>
<tr><td><p>0x00</p>
</td><td><p>Success</p>
</td></tr>
<tr><td><p>0x01</p>
</td><td><p>Unknown HCI Command</p>
</td></tr>
<tr><td><p>0x02</p>
</td><td><p>Unknown Connection Identifier</p>
</td></tr>
<tr><td><p>0x03</p>
</td><td><p>Hardware Failure</p>
</td></tr>
<tr><td><p>0x05</p>
</td><td><p>Authentication Failure</p>
</td></tr>
<tr><td><p>0x06</p>
</td><td><p>PIN or Key Missing</p>
</td></tr>
<tr><td><p>0x07</p>
</td><td><p>Memory Capacity Exceeded</p>
</td></tr>
<tr><td><p>0x08</p>
</td><td><p>Connection Timeout</p>
</td></tr>
<tr><td><p>0x09</p>
</td><td><p>Connection Limit Exceeded</p>
</td></tr>
<tr><td><p>0x0B</p>
</td><td><p>ACL Connection Already Exists</p>
</td></tr>
<tr><td><p>0x0C</p>
</td><td><p>Command Disallowed</p>
</td></tr>
<tr><td><p>0x11</p>
</td><td><p>Unsupported Feature Or Parameter Value</p>
</td></tr>
<tr><td><p>0x12</p>
</td><td><p>Invalid HCI Command Parameters</p>
</td></tr>
<tr><td><p>0x13</p>
</td><td><p>Remote User Terminated Connection</p>
</td></tr>
<tr><td><p>0x14</p>
</td><td><p>Remote Device Terminated Connection due to Low Resources</p>
</td></tr>
<tr><td><p>0x15</p>
</td><td><p>Remote Device Terminated Connection due to Power Off</p>
</td></tr>
<tr><td><p>0x16</p>
</td><td><p>Connection Terminated By Local Host</p>
</td></tr>
<tr><td><p>0x1A</p>
</td><td><p>Unsupported Remote Feature</p>
</td></tr>
<tr><td><p>0x1E</p>
</td><td><p>Invalid LL Parameters</p>
</td></tr>
<tr><td><p>0x1F</p>
</td><td><p>Unspecified Error</p>
</td></tr>
<tr><td><p>0x22</p>
</td><td><p>LL Response Timeout</p>
</td></tr>
<tr><td><p>0x23</p>
</td><td><p>LL Procedure Collision</p>
</td></tr>
<tr><td><p>0x24</p>
</td><td><p>LMP PDU Not Allowed</p>
</td></tr>
<tr><td><p>0x28</p>
</td><td><p>Instant Passed</p>
</td></tr>
<tr><td><p>0x2A</p>
</td><td><p>Different Transaction Collision</p>
</td></tr>
<tr><td><p>0x2E</p>
</td><td><p>Channel Assessment Not Supported</p>
</td></tr>
<tr><td><p>0x2F</p>
</td><td><p>Insufficient Security</p>
</td></tr>
<tr><td><p>0x30</p>
</td><td><p>Parameter Out Of Mandatory Range</p>
</td></tr>
<tr><td><p>0x38</p>
</td><td><p>Host Busy - Pairing</p>
</td></tr>
<tr><td><p>0x3A</p>
</td><td><p>Controller Busy</p>
</td></tr>
<tr><td><p>0x3B</p>
</td><td><p>Unacceptable Connection Parameters</p>
</td></tr>
<tr><td><p>0x3C</p>
</td><td><p>Directed Advertising Timeout</p>
</td></tr>
<tr><td><p>0x3D</p>
</td><td><p>Connection Terminated Due to MIC Failure</p>
</td></tr>
<tr><td><p>0x3E</p>
</td><td><p>Connection Failed to be Established</p>
</td></tr>
<tr><td><p>0x42</p>
</td><td><p>Unknown Advertising Identifier</p>
</td></tr>
<tr><td><p>0x43</p>
</td><td><p>Limit Reached</p>
</td></tr>
<tr><td><p>0x45</p>
</td><td><p>Packet Too Long</p>
</td></tr>
<tr><td><p>0x59</p>
</td><td><p>Device in blacklist</p>
</td></tr>
<tr><td><p>0x5A</p>
</td><td><p>CSRK not found</p>
</td></tr>
<tr><td><p>0x5B</p>
</td><td><p>IRK not found</p>
</td></tr>
<tr><td><p>0x5C</p>
</td><td><p>Device not found in DB</p>
</td></tr>
<tr><td><p>0x5E</p>
</td><td><p>Device not bonded</p>
</td></tr>
<tr><td><p>0x60</p>
</td><td><p>Invalid handle</p>
</td></tr>
<tr><td><p>0x61</p>
</td><td><p>Out of handles</p>
</td></tr>
<tr><td><p>0x62</p>
</td><td><p>Invalid operation</p>
</td></tr>
<tr><td><p>0x64</p>
</td><td><p>Insufficient resources</p>
</td></tr>
<tr><td><p>0x65</p>
</td><td><p>Security permission error</p>
</td></tr>
<tr><td><p>0x70</p>
</td><td><p>Address not resolved</p>
</td></tr>
<tr><td><p>0x82</p>
</td><td><p>No valid slot</p>
</td></tr>
<tr><td><p>0x83</p>
</td><td><p>Short window</p>
</td></tr>
<tr><td><p>0x84</p>
</td><td><p>New interval failed</p>
</td></tr>
<tr><td><p>0x85</p>
</td><td><p>Too large interval</p>
</td></tr>
<tr><td><p>0x86</p>
</td><td><p>Slot length failed</p>
</td></tr>
<tr><td><p>0x91</p>
</td><td><p>Failed</p>
</td></tr>
<tr><td><p>0x92</p>
</td><td><p>Invalid parameters</p>
</td></tr>
<tr><td><p>0x93</p>
</td><td><p>Busy</p>
</td></tr>
<tr><td><p>0x95</p>
</td><td><p>Pending</p>
</td></tr>
<tr><td><p>0x97</p>
</td><td><p>Host error</p>
</td></tr>
<tr><td><p>0x98</p>
</td><td><p>Out of memory</p>
</td></tr>
</table><p></p><h1><a name="TX Power Level_anchor">TX Power Level</a></h1><p>The following table gives the values in dBm corresponding to the possible values of PA_Level parameter from <a href="#ACI_HAL_SET_TX_POWER_LEVEL_anchor">ACI_HAL_SET_TX_POWER_LEVEL</a>. Output power is indicative and depends on the PCB layout and associated components. Here the values are given at the STM32WB output</p><h2></h2><table width="800" border="1" class="reference">
<tr><th>PA_Level</th><th>Output power</th></tr>
<tr><td><p>0x00</p>
</td><td><p>-40 dBm</p>
</td></tr>
<tr><td><p>0x01</p>
</td><td><p>-20.85 dBm</p>
</td></tr>
<tr><td><p>0x02</p>
</td><td><p>-19.75 dBm</p>
</td></tr>
<tr><td><p>0x03</p>
</td><td><p>-18.85 dBm</p>
</td></tr>
<tr><td><p>0x04</p>
</td><td><p>-17.6 dBm</p>
</td></tr>
<tr><td><p>0x05</p>
</td><td><p>-16.5 dBm</p>
</td></tr>
<tr><td><p>0x06</p>
</td><td><p>-15.25 dBm</p>
</td></tr>
<tr><td><p>0x07</p>
</td><td><p>-14.1 dBm</p>
</td></tr>
<tr><td><p>0x08</p>
</td><td><p>-13.15 dBm</p>
</td></tr>
<tr><td><p>0x09</p>
</td><td><p>-12.05 dBm</p>
</td></tr>
<tr><td><p>0x0A</p>
</td><td><p>-10.9 dBm</p>
</td></tr>
<tr><td><p>0x0B</p>
</td><td><p>-9.9 dBm</p>
</td></tr>
<tr><td><p>0x0C</p>
</td><td><p>-8.85 dBm</p>
</td></tr>
<tr><td><p>0x0D</p>
</td><td><p>-7.8 dBm</p>
</td></tr>
<tr><td><p>0x0E</p>
</td><td><p>-6.9 dBm</p>
</td></tr>
<tr><td><p>0x0F</p>
</td><td><p>-5.9 dBm</p>
</td></tr>
<tr><td><p>0x10</p>
</td><td><p>-4.95 dBm</p>
</td></tr>
<tr><td><p>0x11</p>
</td><td><p>-4 dBm</p>
</td></tr>
<tr><td><p>0x12</p>
</td><td><p>-3.15 dBm</p>
</td></tr>
<tr><td><p>0x13</p>
</td><td><p>-2.45 dBm</p>
</td></tr>
<tr><td><p>0x14</p>
</td><td><p>-1.8 dBm</p>
</td></tr>
<tr><td><p>0x15</p>
</td><td><p>-1.3 dBm</p>
</td></tr>
<tr><td><p>0x16</p>
</td><td><p>-0.85 dBm</p>
</td></tr>
<tr><td><p>0x17</p>
</td><td><p>-0.5 dBm</p>
</td></tr>
<tr><td><p>0x18</p>
</td><td><p>-0.15 dBm</p>
</td></tr>
<tr><td><p>0x19</p>
</td><td><p>0 dBm</p>
</td></tr>
<tr><td><p>0x1A</p>
</td><td><p>+1 dBm</p>
</td></tr>
<tr><td><p>0x1B</p>
</td><td><p>+2 dBm</p>
</td></tr>
<tr><td><p>0x1C</p>
</td><td><p>+3 dBm</p>
</td></tr>
<tr><td><p>0x1D</p>
</td><td><p>+4 dBm</p>
</td></tr>
<tr><td><p>0x1E</p>
</td><td><p>+5 dBm</p>
</td></tr>
<tr><td><p>0x1F</p>
</td><td><p>+6 dBm</p>
</td></tr>
</table><p>Other values are reserved.</p></font></body></html>